# Install | Avalonia Docs
- Get Started
- Install
## Install
### Preinstallation​
Please start with the supported IDE of your choice installed. Avalonia supports Visual Studio, Rider, and Visual Studio Code.
### Install Avalonia UI Templates​
The best way to get started with Avalonia is by creating an application using a project template.
To install the Avalonia templates, run the following command:
```bash
dotnet new install Avalonia.Templates
```
For .NET 6.0 and earlier, replace install with --install
`install` `--install` To list the installed templates run
```bash
dotnet new list
```
You should see the installed Avalonia templates:
```bash
Template Name                 Short Name         Language  Tags-------------------------------------------- -------------------------- ---------- ---------------------------------------------------------Avalonia App                 avalonia.app        [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia MVVM App               avalonia.mvvm        [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia Cross Platform Application      avalonia.xplat       [C#],F#   Desktop/Xaml/Avalonia/Web/MobileAvalonia Resource Dictionary         avalonia.resource            Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia Styles                avalonia.styles             Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia TemplatedControl           avalonia.templatedcontrol  [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia UserControl             avalonia.usercontrol    [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia Window                avalonia.window       [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOS
```
### Create a new Application​
Once the project templates are installed, you can create a new Avalonia UI application from CLI by running the following command:
```bash
dotnet new avalonia.app -o MyApp
```
This will create a new folder called MyApp containing your application files. To run the application, navigate to the MyApp folder and run:
`MyApp` `MyApp` ```bash
cd MyAppdotnet run
```
The project templates will also allow for project creation from your IDE.
### Installation Troubleshooting​
#### Ensure .NET SDK is installed​
```bash
dotnet --list-sdks8.0.202 [C:\Program Files\dotnet\sdk] <-- Your version may vary
```
If dotnet is not a recognized program, then ensure you've installed your IDE first. Next, ensure that dotnet is associated with the terminal. On Windows, this involves checking environment variables: echo %PATH% in the command prompt or echo $Env:PATH in PowerShell.
`dotnet` `dotnet` `echo %PATH%` `echo $Env:PATH` #### Ensure NuGet source is correct​
If while installing the project templates, you receive an error stating the Avalonia.Templates package cannot be found, then ensure NuGet is correctly setup with .NET's standard global package source.
`Avalonia.Templates` ```bash
dotnet nuget list sourceRegistered Sources: 1. nuget.org [Enabled]   https://api.nuget.org/v3/index.json
```
If this source is not listed, add it:
```bash
dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org
```
If the package install still fails despite NuGet being listed, then suspect a network connectivity or firewall issue.
- Preinstallation
- Install Avalonia UI Templates
- Create a new Application
- Installation TroubleshootingEnsure .NET SDK is installedEnsure NuGet source is correct
- Ensure .NET SDK is installed
- Ensure NuGet source is correct
- Ensure .NET SDK is installed
- Ensure NuGet source is correct
# Get Started | Avalonia Docs
- Get Started
## Get Started
# Set Up an Editor | Avalonia Docs
- Get Started
- Set Up an Editor
## Set Up an Editor
You can create an Avalonia application using any code editor, but using an IDE will give you support for authoring Avalonia XAML files with a previewer and code completion.
### Recommended IDE: JetBrains Rider​
The JetBrains Rider IDE has built-in support for Avalonia XAML starting in 2020.3 including first-class support for Avalonia-specific XAML features and custom code inspections. Now that Rider is free for individual use, we strongly recommend it as the primary IDE for Avalonia development, especially for developers on macOS and Linux.
Rider offers the most complete and polished development experience for Avalonia, with built-in features including:
- Advanced XAML completion and navigation
- Rich code analysis and quick-fixes
- Comprehensive debugging tools
- Built-in performance profiling
#### AvaloniaRider Plugin​
The 3rd party AvaloniaRider plugin adds the Avalonia file templates to Rider, as well as enables live XAML preview functionality.
While Rider includes native Avalonia XAML support out of the box, This plugin provides a live preview of your XAML changes as you type, similar to the preview feature available in Visual Studio and Visual Studio Code.
Note that the plugin is optional - you can develop Avalonia applications in Rider without it, but the live preview capability and file templates makes XAML development more efficient.
### Visual Studio​
If you're developing Avalonia with Visual Studio you should install the Avalonia for Visual Studio extension.
The extension provides IntelliSense support for Avalonia XAML together with a previewer.
To install the Avalonia for Visual Studio extension:
- In Visual Studio click Manage Extensions on the Extensions menu
- In the Search box, type "Avalonia"
- Click Download and follow the instructions (you will need to close Visual Studio to complete the installation)
![](https://docs.avaloniaui.net/assets/images/avalonia-vs-extension-nuget-b0890d494f3989af25b990e19d61d974.png)
Alternatively you can download the extension here.
If you are using VS2019 or VS2017 you will need to download the extension for older versions here.
### Visual Studio Code​
The Avalonia for Visual Studio Code Extension contains basic support for Avalonia XAML autocomplete and previewer. While functional, the development experience is not as rich as what you'll find in Rider or Visual Studio. For developers on macOS and Linux requiring a full IDE experience, we recommend using JetBrains Rider instead.
If you still prefer to use VS Code, you can install the extension from the Visual Studio Code marketplace.
### Editor Comparison​
For the best Avalonia development experience:
- Windows: Use either JetBrains Rider or Visual Studio
- macOS/Linux: Use JetBrains Rider
- Lightweight Editor: Visual Studio Code can be used but offers a more limited feature set
- Recommended IDE: JetBrains RiderAvaloniaRider Plugin
- AvaloniaRider Plugin
- Visual Studio
- Visual Studio Code
- Editor Comparison
- AvaloniaRider Plugin
# Test Drive | Avalonia Docs
- Get Started
- Test Drive
## Test Drive
# Introduction | Avalonia Docs
- Get Started
- Test Drive
- Introduction
## Introduction
You can use this section to get started right away with Avalonia. This will take you through a simple tutorial example, step-by-step, and introduce you to some of the Avalonia concepts and techniques.
You do not need any prior knowledge of Avalonia or other XAML-based frameworks to learn from this section.
Click the Next button to get started.
If you are a developer experienced with using XAML and Avalonia project creation, you may want to skip ahead to our Basics section here or one of the How-To Guides here.
### Prerequisites​
#### Install Templates​
Before starting, ensure that you have installed the Avalonia templates:
```bash
dotnet new install Avalonia.Templates
```
- Rider
- Visual Studio
- Visual Studio Code
JetBrains Rider provides native support for Avalonia XAML, offering a rich development experience without requiring additional extensions.
For real-time XAML preview capabilities, you can enhance your workflow by installing the optional Avalonia Rider plugin.
Visual Studio 2022 users can enhance their Avalonia development experience by installing our official extension from the Visual Studio Marketplace.
The extension provides XAML code completion and an integrated live previewer, allowing you to see your UI updates in real-time.
While we maintain a Visual Studio Code extension that provides basic XAML support and a live previewer, we recommend using JetBrains Rider for the best possible development experience with Avalonia.
However, if you prefer to continue with Visual Studio Code, you can install our extension from the marketplace.
- PrerequisitesInstall Templates
- Install Templates
# Basics | Avalonia Docs
- Basics
## Basics
This section will introduce you to the basic concepts required to build an application with Avalonia.
# Conclusion | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Conclusion
## Conclusion
In this tutorial you have seen how Avalonia UI can be used to create a highly graphical desktop app.
### Application Solution Architecture​
This tutorial has used an application solution architecture that uses the MVVM pattern with the help of the ReactiveUI framework. It manages multiple windows from the code-behind files.
Application state is kept in the 'top level' view model, and can be persisted to disk. The main window and search dialog are composed from in Avalonia UI window controls, built-in controls and user controls.
This tutorial application targets a windowing platform such as Apple Mac OS or Windows.
To learn more about targeting applications for iOS (Apple) platforms, see here.
To learn more about targeting applications for Android mobile devices, see here.
### Further Reading​
For a full list of the Avalonia UI tutorials, see here.
- Application Solution Architecture
- Further Reading
# Samples & Tutorials | Avalonia Docs
- Samples & Tutorials
## Samples & Tutorials
This section has practical tutorials that are designed to help you learn Avalonia UI and build your confidence. Here is a brief guide to what you can expect from each of the tutorials:
### To Do List App​
A simple to do list application using the Model View View-Model (MVVM) pattern, with binding to a collection, from which you will meet:
- How to use Bindings
- How to use Commands
- Some basic Styling
- Some very basic I/O operations
This is a very good introduction to the MVVM pattern recommended for Avalonia UI programming. Follow the tutorial here.
### Music Store App​
This app was made for a demonstration on a webinar hosted by JetBrains, and co-hosted by Dan Walmsley, one of the creators of Avalonia UI.
To view the JetBrains and Avalonia UI webinar on YouTube, see here.
It uses the JetBrains Rider IDE running on macOS, but the steps will be equivalent on other platforms; and the developer experience will also be similar on other IDEs such as Visual Studio.
The app features a highly graphical application using the MVVM pattern, and including how to display a dialog, present images and collections of data, and implement data persistence.
Follow this demonstration here.
- To Do List App
- Music Store App
# Music Store App | Avalonia Docs
- Samples & Tutorials
- Music Store App
## Music Store App
In this tutorial you will create a desktop app based on the idea of a music store. The app is highly graphical - it presents images of album covers, and uses semi-transparent 'acrylic' blurred window backgrounds to give a very up-to-date look. By the end of the tutorial, you will be able search the iTunes online list of albums, and select albums for your own list.
![](https://docs.avaloniaui.net/assets/images/image-20210310184538120-2f78353c6bef2d413da67fc8396887af.png)
In this tutorial you will use the MVVM pattern with the ReactiveUI framework to manage multiple application windows. Also you will use advanced asynchronous techniques to implement the album search and other features, so that application responsiveness is maintained.
This is a more advanced tutorial. The 'To Do List App' is a recommended prerequisite if you have limited experience with the MVVM pattern. Read about the 'To Do List App' tutorial here.
For information and background on the concept of the MVVM pattern, see here.
This tutorial contains instructions for using the Rider IDE on macOS; however the steps will be similar on other operating systems, and using other IDEs such as Visual Studio on Microsoft Windows.
You can find the code for the completed application here.
# The MVVM Pattern | Avalonia Docs
- Deep Dives
- The MVVM Pattern
## The MVVM Pattern
The Model-View-View Model (MVVM) pattern is a common way of structuring a UI application. It uses a data binding system that helps move data between its view and view model parts. This means it achieves separation of application logic (view model) from the display of the UI (view).
Separation between the application logic and the business services (model) is commonly achieved by a Dependency Injection (DI) system.
MVVM might be overkill for a simple application; but as applications grow over time, they will often reach a point where keeping display definition and application logic in the same UI component modules becomes a problem:
- Interactions between UI components become complicated and error-prone.
- It becomes difficult to unit test UI components due to dependencies on the target UI platform.
MVVM solves this by abstracting the application logic into code-only classes that do not depend on the target UI platform, and can therefore be unit tested independently.
To discover more about the background to the MVVM pattern, see the Microsoft Patterns and Practices article here.
### When to use MVVM?​
MVVM is a more complex pattern of programming compared to the event-driven code-behind pattern. You have an additional learning overhead to master the techniques of the ReactiveUI framework which you will use to implement MVVM with Avalonia UI.
In fact, the code-behind pattern may well be easier for you to understand and maintain for a small simple application.
For details of how to program Avalonia UI with the code-behind pattern, see here.
The advantages of using the MVVM pattern may only become apparent when an application grows and becomes more complex. You therefore have two development strategies to consider:
- Start by using the simpler code-behind pattern. Aim to convert to MVVM should the application become difficult to maintain.
- Use MVVM from the start because you expect the application to grow.
You can use the following pages to learn about using MVVM with Avalonia UI whichever of the above strategies you adopt.
- When to use MVVM?
# Deep Dives | Avalonia Docs
- Deep Dives
## Deep Dives
This section contains pages that will help you understand some of the concepts used by Avalonia UI. This is background and theory information, often supported by code samples you can work through. This section is arranged alphabetically by title.
If you are new to Avalonia UI, we recommend that you complete the 'Get Started' before you read these pages.
If you are looking for practical advice on how to achieve any of the above, learn the Basics.
# Get Started | Avalonia Docs
- Get Started
## Get Started
# Migrating from WPF | Avalonia Docs
- Get Started
- Coming from WPF?
## Migrating from WPF
This reference will help you leverage your existing knowledge of Windows Presentation Foundation (WPF) to learn Avalonia UI quickly.
You will see how although Avalonia UI is often very similar to WPF; there are some differences. In particular, in the way in which the following work:
- Styling
- Data Templates
### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# Styling | Avalonia Docs
- Get Started
- Coming from WPF?
- Styling
## Styling
The most obvious difference from other XAML frameworks is in its styling system. There are two ways of styling controls in Avalonia:
- A Style is a CSS-like style. Styles aren't stored in a Resources collection as in WPF, they are stored in a separate Styles collection.
- A ControlTheme is similar to a WPF Style and is usually used to create themes for lookless controls
`Style` `Resources` `Styles` `ControlTheme` `Style` ### Example​
The following code shows a UserControl which defines its own CSS-like style.
`UserControl` ```bash
<UserControl>  <UserControl.Styles>    <!-- Make TextBlocks with the h1 style class have a font size of 24 points -->    <Style Selector="TextBlock.h1">      <Setter Property="FontSize" Value="24"/>    </Style>  </UserControl.Styles>  <TextBlock Classes="h1">Header</TextBlock></UserControl>
```
### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
- Example
# Styling | Avalonia Docs
- Basics
- User Interface
- Styling
## Styling
Avalonia provides two primary mechanisms for styling controls:
### Styles​
- Styles are similar to CSS styles and are usually used to style controls based on their content or purpose within the application; for example creating a style for header text blocks.
### Control themes​
- Control Themes are similar to WPF/UWP styles and are usually used to apply a theme to controls.
- Styles
- Control themes
# Basics | Avalonia Docs
- Basics
## Basics
This section will introduce you to the basic concepts required to build an application with Avalonia.
# Avalonia XAML | Avalonia Docs
- Basics
- User Interface
- Avalonia XAML
## Avalonia XAML
Avalonia UI uses XAML to define a user interface. XAML is an XML-based mark-up language that is used by many UI frameworks.
These pages will introduce you to how XAML is used specifically in Avalonia UI. For background information about how XAML is used elsewhere in Microsoft technologies, you can use these references:
- Microsoft XAML documentation for WPF, see here.
- Microsoft XAML documentation for UWP, see here.
### AXAML File Extension​
The file extension for XAML files used elsewhere is .xaml but due to technical issues integrating with Visual Studio, Avalonia UI uses its own .axaml extension - 'Avalonia XAML'.
`.xaml` `.axaml` ### File Format​
A typical Avalonia XAML file looks like this:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    x:Class="AvaloniaApplication1.MainWindow"></Window>
```
In common with all XML files, there is a root element. The root element tag <Window></Window> defines the type of the root. This will correspond to a type of Avalonia UI control, in the above example a window.
`<Window></Window>` The sample above uses three interesting attributes:
- xmlns="https://github.com/avaloniaui" - this is the XAML namespace declaration for Avalonia UI itself. This is required, without it the file will not be recognised as an Avalonia XAML document.
- xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" - this is the declaration for the XAML language namespace.
- x:Class="AvaloniaApplication1.MainWindow" - this is an extension of the above declaration (for 'x') that tells the XAML compiler where to find the associated class for this file. The class is defined in a code-behind file, usually written in C#.
`xmlns="https://github.com/avaloniaui"` `xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"` `x:Class="AvaloniaApplication1.MainWindow"` For information about the code-behind concept, see here.
### Control Elements​
You can compose a UI for your application by adding XML elements that represent one of the Avalonia UI controls. The element tag uses the same name as the control class name.
A UI can be composed of several different types of control. To learn more about the concept of UI composition, see here.
For example, this XAML adds a button to the content of a window:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <Button>Hello World!</Button></Window>
```
For a complete list of the Avalonia UI built-in controls, see the reference here.
### Control Attributes​
The XML elements that represent controls have attributes corresponding to control properties that can be set. You can set a control property by adding an attribute to an element.
For example, to specify a blue background for a button control, you add the Background attribute set the value to "Blue". Like this:
`Background` `"Blue"` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <Button Background="Blue">Hello World!</Button></Window>
```
### Control Content​
You might have noticed that the button in the above sample has its content (the 'Hello World' string) placed between its opening and closing tags. As an alternative, you can set the content attribute, as follows:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <Button Content="Hello World!"/></Window>
```
This behaviour is specific to the content of an Avalonia UI control.
### Data Binding​
You will often use the Avalonia UI binding system to link a control property to an underlying object. The link is declared using the {Binding} mark-up extension. For example:
`{Binding}` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <Button Content="{Binding Greeting}"/></Window>
```
For further information about the concept behind data binding, see here.
### Code-behind Files​
Many Avalonia XAML files also have an associated code-behind file that is usually written in C#, and has the file extension .axaml.cs.
`.axaml.cs` For guidance about programming using code-behind files, see here.
### XML Namespaces​
In common with any XML format, in Avalonia XAML files you can declare namespaces. This allows the XML processor to find the definitions of the elements in the file.
For background information, see the Microsoft XML namespaces documentation here.
You can add a namespace using the xmlns attribute. The format of a namespace declaration is as follows:
`xmlns` ```bash
xmlns:alias="definition"
```
It is standard practice to define all the namespaces you are going to use in the root element.
Only one namespace in a file can be defined without using the alias part of the attribute name. The alias must always be unique with in a file.
The definition part of the namespace declaration can be either a URL or a code definition. Both of these are used to locate the definition of the elements in the file.
For detailed guidance on how namespace declarations work, see here.
There are two valid syntax options for the definition part of a XAML namespace attribute that references code:
#### Using Prefix​
The prefix using: can be used when providing an alias for a namespace in either the current assembly or a referenced assembly. The syntax is the same in both cases. For example:
`using:` ```bash
xmlns:myAlias1="using:AppNameSpace.MyNamespace"
```
#### CLR Namespace Prefix​
The prefix clr-namespace:, the same as in WPF, is also supported. However, the syntax depends on whether the namespace for which an alias is required is in the current assembly or a referenced assembly.
`clr-namespace:` For example, when the namespace is in the same assembly as the XAML, you can use this syntax:
```bash
<Window ...  xmlns:myAlias1="clr-namespace:AppNameSpace.MyNamespace" ... >
```
If the namespace is in another referenced assembly (for example in a library), you must extend the description to include the name of the referenced assembly:
```bash
<Window ...  xmlns:myAlias2="clr-namespace:OtherAssembly.MyNameSpace;assembly=OtherAssembly" ... >
```
- AXAML File Extension
- File Format
- Control Elements
- Control Attributes
- Control Content
- Data Binding
- Code-behind Files
- XML NamespacesUsing PrefixCLR Namespace Prefix
- Using Prefix
- CLR Namespace Prefix
- Using Prefix
- CLR Namespace Prefix
# Code-behind | Avalonia Docs
- Basics
- User Interface
- Code-behind
## Code-behind
In addition to a XAML file, most Avalonia controls also have a code-behind file that is commonly written in C#. The code-behind file by convention has the file extension .axaml.cs and is often displayed nested below the XAML file in your IDE.
`.axaml.cs` For instance, in the Visual Studio solution explorer, you can see a MainWindow.axaml file along with its code-behind file MainWindow.axaml.cs:
`MainWindow.axaml` `MainWindow.axaml.cs` The code-behind file contains a class that shares the same name as the XAML file. For example:
```bash
using Avalonia.Controls;namespace AvaloniaApplication1.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();    }  }}
```
Notice that the class name matches the name of the XAML file, and is also referenced in the x:Class attribute of the window element.
`x:Class` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    x:Class="AvaloniaApplication1.Views.MainWindow"> ...</Window>
```
If you make any changes to the class name in code, or its namespace, ensure that the x:Class attribute always matches, or you will get an error.
`x:Class` When the code-behind file is first added, it has only a constructor, which calls the InitializeComponent() method. This method call is required to load the XAML at runtime.
`InitializeComponent()` ### Locating Controls​
When working with code-behind, you often need to access the controls defined in XAML.
To do this, you first need to obtain a reference to the desired control. Give the control a name using the Name (or x:Name) attribute in XAML.
`Name` `x:Name` Here's an example of a XAML file with a named button:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    x:Class="AvaloniaApplication5.MainWindow"> <Button Name="greetingButton">Hello World</Button></Window>
```
You can now access the button via an auto-generated greetingButton field from the code-behind:
`greetingButton` ```bash
using Avalonia.Controls;namespace AvaloniaApplication1.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();      greetingButton.Content = "Goodbye Cruel World!";    }  }}
```
### Set Properties​
With the control reference available in the code-behind, you can set properties. For example, you can change the background property like this:
```bash
greetingButton.Background = Brushes.Blue;
```
### Handling Events​
Any useful application will require you to implement some action! When using the code-behind pattern, you write event handlers in the code-behind file.
Event handlers are written as methods in the code-behind file, and then referenced in the XAML using an event attribute. For example, to add a handler for a button click event:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    x:Class="AvaloniaApplication4.MainWindow"> <Button Click="GreetingButtonClickHandler">Hello World</Button></Window>
```
```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();  }  public void GreetingButtonClickHandler(object sender, RoutedEventArgs e)  {    // code here.  }}
```
Note that many Avalonia event handlers pass a special argument of class RoutedEventArgs. This includes information about how the event has been generated and propagated.
`RoutedEventArgs` For more information on the concepts of event routing, see here.
- Locating Controls
- Set Properties
- Handling Events
# Routed Events | Avalonia Docs
- Deep Dives
- Input
- Routed Events
## Routed Events
Most events in Avalonia are implemented as Routed Events. Routed events are events that are raised on the whole tree rather than just the control that raised the event.
### What Is a Routed Event​
A typical Avalonia application contains many elements. Whether created in code or declared in XAML, these elements exist in an element tree relationship to each other. The event route can travel in one of two directions depending on the event definition, but generally the route travels from the source element and then "bubbles" upward through the element tree until it reaches the element tree root (typically a page or a window). This bubbling concept might be familiar to you if you have worked with the HTML DOM previously.
#### Top-level Scenarios for Routed Events​
The following is a brief summary of the scenarios that motivated the routed event concept, and why a typical CLR event was not adequate for these scenarios:
Control composition and encapsulation: Various controls in Avalonia have a rich content model. For example, you can place an image inside of a Button, which effectively extends the visual tree of the button. However, the added image must not break the hit-testing behavior that causes a button to respond to a Click of its content, even if the user clicks on pixels that are technically part of the image.
`Button` `Click` Singular handler attachment points: In Windows Forms, you would have to attach the same handler multiple times to process events that could be raised from multiple elements. Routed events enable you to attach that handler only once, as was shown in the previous example, and use handler logic to determine where the event came from if necessary. For instance, this might be the handler for the previously shown XAML:
```bash
private void CommonClickHandler(object sender, RoutedEventArgs e){ var source = e.Source as Control; switch (source.Name) {  case "YesButton":   // do something here ...   break;  case "NoButton":   // do something ...   break;  case "CancelButton":   // do something ...   break; } e.Handled=true;}
```
Class handling: Routed events permit a static handler that is defined by the class. This class handler has the opportunity to handle an event before any attached instance handlers can.
Referencing an event without reflection: Certain code and markup techniques require a way to identify a specific event. A routed event creates a RoutedEvent field as an identifier, which provides a robust event identification technique that does not require static or run-time reflection.
`RoutedEvent` #### How Routed Events Are Implemented​
A routed event is a CLR event that is backed by an instance of the RoutedEvent class and registered with the Avalonia event system. RoutedEvent instance obtained from registration is typically retained as a public static readonly field member of the class that registers and thus "owns" the routed event. The connection to the identically named CLR event (which is sometimes termed the "wrapper" event) is accomplished by overriding the add and remove implementations for the CLR event. Ordinarily, the add and remove are left as an implicit default that uses the appropriate language-specific event syntax for adding and removing handlers of that event. The routed event backing and connection mechanism is conceptually similar to how an avalonia property is a CLR property that is backed by the AvaloniaProperty class and registered with the Avalonia property system.
`RoutedEvent` `RoutedEvent` `public` `static` `readonly` `add` `remove` `add` `remove` `AvaloniaProperty` The following example shows the declaration for a custom Tap routed event, including the registration and exposure of the RoutedEvent identifier field and the add and remove implementations for the Tap CLR event.
`Tap` `RoutedEvent` `add` `remove` `Tap` ```bash
public class SampleControl: Control{ public static readonly RoutedEvent<RoutedEventArgs> TapEvent =  RoutedEvent.Register<SampleControl, RoutedEventArgs>(nameof(Tap), RoutingStrategies.Bubble); // Provide CLR accessors for the event public event EventHandler<RoutedEventArgs> Tap {   add => AddHandler(TapEvent, value);  remove => RemoveHandler(TapEvent, value); }}
```
#### Routed Event Handlers and XAML​
To add a handler for an event using XAML, you declare the event name as an attribute on the element that is an event listener. The value of the attribute is the name of your implemented handler method, which must exist in the class of the code-behind file.
```bash
<Button Click="b1SetColor">button</Button>
```
The XAML syntax for adding standard CLR event handlers is the same for adding routed event handlers, because you are really adding handlers to the CLR event wrapper, which has a routed event implementation underneath.
### Routing Strategies​
Routed events use one of three routing strategies:
- Bubbling: Event handlers on the event source are invoked. The routed event then routes to successive parent elements until reaching the element tree root. Most routed events use the bubbling routing strategy. Bubbling routed events are generally used to report input or state changes from distinct controls or other UI elements.
- Direct: Only the source element itself is given the opportunity to invoke handlers in response. This is analogous to the "routing" that Windows Forms uses for events. However, unlike a standard CLR event, direct routed events support class handling (class handling is explained in an upcoming section).
- Tunneling: Initially, event handlers at the element tree root are invoked. The routed event then travels a route through successive child elements along the route, towards the node element that is the routed event source (the element that raised the routed event). Tunneling routed events are often used or handled as part of the compositing for a control, such that events from composite parts can be deliberately suppressed or replaced by events that are specific to the complete control. Input events provided in Avalonia often raise both tunneling and bubbling events.
### Why Use Routed Events?​
As an application developer, you do not always need to know or care that the event you are handling is implemented as a routed event. Routed events have special behavior, but that behavior is largely invisible if you are handling an event on the element where it is raised.
Where routed events become powerful is if you use any of the suggested scenarios: defining common handlers at a common root, compositing your own control, or defining your own custom control class.
Routed event listeners and routed event sources do not need to share a common event in their hierarchy. Any control can be an event listener for any routed event. Therefore, you can use the full set of routed events available throughout the working API set as a conceptual "interface" whereby disparate elements in the application can exchange event information. This "interface" concept for routed events is particularly applicable for input events.
Routed events can also be used to communicate through the element tree, because the event data for the event is perpetuated to each element in the route. One element could change something in the event data, and that change would be available to the next element in the route.
Other than the routing aspect, there are two other reasons that any given Avalonia event might be implemented as a routed event instead of a standard CLR event. If you are implementing your own events, you might also consider these principles:
- Certain styling and templating features require the referenced event to be a routed event. This is the event identifier scenario mentioned earlier.
- Routed events support a class handling mechanism whereby the class can specify static methods that have the opportunity to handle routed events before any registered instance handlers can access them. This is very useful in control design, because your class can enforce event-driven class behaviors that cannot be accidentally suppressed by handling an event on an instance.
Each of the above considerations is discussed in a separate section of this topic.
### Adding and Implementing an Event Handler for a Routed Event​
To add an event handler in XAML, you simply add the event name to an element as an attribute and set the attribute value as the name of the event handler that implements an appropriate delegate, as in the following example.
```bash
<Button Click="b1SetColor">button</Button>
```
b1SetColor is the name of the implemented handler that contains the code that handles the Click event. b1SetColor must have the same signature as the RoutedEventHandler<RoutedEventArgs> delegate, which is the event handler delegate for the Click event. The first parameter of all routed event handler delegates specifies the element to which the event handler is added, and the second parameter specifies the data for the event.
`b1SetColor` `Click` `b1SetColor` `RoutedEventHandler<RoutedEventArgs>` `Click` ```bash
void b1SetColor(object sender, RoutedEventArgs args){ //logic to handle the Click event}
```
RoutedEventHandler<RoutedEventArgs> is the basic routed event handler delegate. For routed events that are specialized for certain controls or scenarios, the delegates to use for the routed event handlers also might become more specialized, so that they can transmit specialized event data. For instance, in a common input scenario, you might handle a PointerPressed routed event. Your handler should implement the RoutedEventHandler<PointerPressedEventArgs> delegate. By using the most specific delegate, you can process the PointerPressedEventArgs in the handler and read the PointerEventArgs.Pointer property, which contains information about the pointer that caused the press.
`RoutedEventHandler<RoutedEventArgs>` `PointerPressed` `RoutedEventHandler<PointerPressedEventArgs>` `PointerPressedEventArgs` `PointerEventArgs.Pointer` Adding a handler for a routed event in an application that is created in code is straightforward. Routed event handlers can always be added through a helper method AddHandler (which is the same method that the existing backing calls for add.) However, existing Avalonia routed events generally have backing implementations of add and remove logic that allow the handlers for routed events to be added by a language-specific event syntax, which is more intuitive syntax than the helper method. The following is an example usage of the helper method:
`AddHandler` `add` `add` `remove` ```bash
void MakeButton(){  Button b2 = new Button();  b2.AddHandler(Button.ClickEvent, Onb2Click);}void Onb2Click(object sender, RoutedEventArgs e){  //logic to handle the Click event   }
```
The next example shows the C# operator syntax:
```bash
void MakeButton2(){ Button b2 = new Button(); b2.Click += Onb2Click2;}void Onb2Click2(object sender, RoutedEventArgs e){ //logic to handle the Click event   }
```
The Concept of Handled
All routed events share a common event data base class, RoutedEventArgs. RoutedEventArgs defines the Handled property, which takes a Boolean value. The purpose of the Handled property is to enable any event handler along the route to mark the routed event as handled, by setting the value of Handled to true. After being processed by the handler at one element along the route, the shared event data is again reported to each listener along the route.
`RoutedEventArgs` `RoutedEventArgs` `Handled` `Handled` `Handled` `true` The value of Handled affects how a routed event is reported or processed as it travels further along the route. If Handled is true in the event data for a routed event, then handlers that listen for that routed event on other elements are generally no longer invoked for that particular event instance. This is true both for handlers attached in XAML and for handlers added by language-specific event handler attachment syntaxes such as +=. For most common handler scenarios, marking an event as handled by setting Handled to true will "stop" routing for either a tunneling route or a bubbling route, and also for any event that is handled at a point in the route by a class handler.
`Handled` `Handled` `true` `+=` `Handled` `true` However, there is a "handledEventsToo" mechanism whereby listeners can still run handlers in response to routed events where Handled is true in the event data. In other words, the event route is not truly stopped by marking the event data as handled. You can only use the handledEventsToo mechanism in code:
`Handled` `true` - In code, instead of using a language-specific event syntax that works for general CLR events, call the Avalonia method AddHandler<TEventArgs>(RoutedEvent<TEventArgs>, EventHandler<TEventArgs> handler, RoutingStrategies, bool) to add your handler. Specify the value of handledEventsToo as true.
`AddHandler<TEventArgs>(RoutedEvent<TEventArgs>, EventHandler<TEventArgs> handler, RoutingStrategies, bool)` `handledEventsToo` `true` In addition to the behavior that Handled state produces in routed events, the concept of Handled has implications for how you should design your application and write the event handler code. You can conceptualize Handled as being a simple protocol that is exposed by routed events. Exactly how you use this protocol is up to you, but the conceptual design for how the value of Handled is intended to be used is as follows:
`Handled` `Handled` `Handled` `Handled` - If a routed event is marked as handled, then it does not need to be handled again by other elements along that route.
- If a routed event is not marked as handled, then other listeners that were earlier along the route have chosen either not to register a handler, or the handlers that were registered chose not to manipulate the event data and set Handled to true. (Or, it is of course possible that the current listener is the first point in the route.) Handlers on the current listener now have three possible courses of action: Take no action at all; the event remains unhandled, and the event routes to the next listener. Execute code in response to the event, but make the determination that the action taken was not substantial enough to warrant marking the event as handled. The event routes to the next listener. Execute code in response to the event. Mark the event as handled in the event data passed to the handler, because the action taken was deemed substantial enough to warrant marking as handled. The event still routes to the next listener, but with Handled=true in its event data, so only handledEventsToo listeners have the opportunity to invoke further handlers.
- Take no action at all; the event remains unhandled, and the event routes to the next listener.
- Execute code in response to the event, but make the determination that the action taken was not substantial enough to warrant marking the event as handled. The event routes to the next listener.
- Execute code in response to the event. Mark the event as handled in the event data passed to the handler, because the action taken was deemed substantial enough to warrant marking as handled. The event still routes to the next listener, but with Handled=true in its event data, so only handledEventsToo listeners have the opportunity to invoke further handlers.
`Handled` `true` - Take no action at all; the event remains unhandled, and the event routes to the next listener.
- Execute code in response to the event, but make the determination that the action taken was not substantial enough to warrant marking the event as handled. The event routes to the next listener.
- Execute code in response to the event. Mark the event as handled in the event data passed to the handler, because the action taken was deemed substantial enough to warrant marking as handled. The event still routes to the next listener, but with Handled=true in its event data, so only handledEventsToo listeners have the opportunity to invoke further handlers.
`Handled=true` `handledEventsToo` This conceptual design is reinforced by the routing behavior mentioned earlier: it is more difficult (although still possible in code or styles) to attach handlers for routed events that are invoked even if a previous handler along the route has already set Handled to true.
`Handled` `true` In applications, it is quite common to just handle a bubbling routed event on the object that raised it, and not be concerned with the event's routing characteristics at all. However, it is still a good practice to mark the routed event as handled in the event data, to prevent unanticipated side effects just in case an element that is further up the element tree also has a handler attached for that same routed event.
### Class Handlers​
If you are defining a class that derives in some way from AvaloniaObject, you can also define and attach a class handler for a routed event that is a declared or inherited event member of your class. Class handlers are invoked before any instance listener handlers that are attached to an instance of that class, whenever a routed event reaches an element instance in its route.
`AvaloniaObject` Some Avalonia controls have inherent class handling for certain routed events. This might give the outward appearance that the routed event is not ever raised, but in reality it is being class handled, and the routed event can potentially still be handled by your instance handlers if you use certain techniques. Also, many base classes and controls expose virtual methods that can be used to override class handling behavior.
To attach a class handler in one of your own controls, use the AddClassHandler method from a static constructor:
`AddClassHandler` ```bash
static MyControl(){  MyEvent.AddClassHandler<MyControl>((x, e) => x.OnMyEvent(e));}protected virtual void OnMyEvent(MyEventArgs e){  // Handle event here.}
```
### Attached Events in Avalonia​
The XAML language also defines a special type of event called an attached event. An attached event enables you to add a handler for a particular event to an arbitrary element. The element handling the event need not define or inherit the attached event, and neither the object potentially raising the event nor the destination handling instance must define or otherwise "own" that event as a class member.
The Avalonia input system uses attached events extensively. However, nearly all of these attached events are forwarded through base elements. The input events then appear as equivalent non-attached routed events that are members of the base element class. For instance, the underlying attached event Gestures.Tapped can more easily be handled on any given Control by using Tapped on that control rather than dealing with attached event syntax either in XAML or code.
`Gestures.Tapped` `Control` `Tapped` ### Qualified Event Names in XAML​
Another syntax usage that resembles typename.eventname attached event syntax but is not strictly speaking an attached event usage is when you attach handlers for routed events that are raised by child elements. You attach the handlers to a common parent, to take advantage of event routing, even though the common parent might not have the relevant routed event as a member. Consider this example again:
```bash
<Border Height="50" Width="300"> <StackPanel Orientation="Horizontal" Button.Click="CommonClickHandler">  <Button Name="YesButton">Yes</Button>  <Button Name="NoButton">No</Button>  <Button Name="CancelButton">Cancel</Button> </StackPanel></Border>
```
Here, the parent element listener where the handler is added is a StackPanel. However, it is adding a handler for a routed event that was declared and will be raised by the Button class. Button "owns" the event, but the routed event system permits handlers for any routed event to be attached to any control instance listener that could otherwise attach listeners for a common language runtime (CLR) event. The default xmlns namespace for these qualified event attribute names is typically the default Avalonia xmlns namespace, but you can also specify prefixed namespaces for custom routed events.
`StackPanel` `Button` `Button` ### Input Events​
One frequent application of routed events within the Avalonia platform is for input events. Input events often come in pairs, with one being the bubbling event and the other being the tunneling event. Occasionally, input events only have a bubbling version, or perhaps only a direct routed version.
Avalonia input events that come in pairs are implemented so that a single user action from input, such as a mouse button press, will raise both routed events of the pair in sequence. First, the tunneling event is raised and travels its route. Then the bubbling event is raised and travels its route. The two events literally share the same event data instance, because the RaiseEvent method call in the implementing class that raises the bubbling event listens for the event data from the tunneling event and reuses it in the new raised event. Listeners with handlers for the tunneling event have the first opportunity to mark the routed event handled (class handlers first, then instance handlers). If an element along the tunneling route marked the routed event as handled, the already-handled event data is sent on for the bubbling event, and typical handlers attached for the equivalent bubbling input events will not be invoked. To outward appearances it will be as if the handled bubbling event has not even been raised. This handling behavior is useful for control compositing, where you might want all hit-test based input events or focus-based input events to be reported by your final control, rather than its composite parts. The final control element is closer to the root in the compositing, and therefore has the opportunity to class handle the tunneling event first and perhaps to "replace" that routed event with a more control-specific event, as part of the code that backs the control class.
`RaiseEvent` As an illustration of how input event processing works, consider the following input event example. In the following tree illustration, leaf element #2 is the source of a PointerPressed event:
`leaf element #2` `PointerPressed` The order of event processing is as follows:
- PointerPressed (tunnel) on root element.
- PointerPressed (tunnel) on intermediate element #1.
- PointerPressed (tunnel) on source element #2.
- PointerPressed (bubble) on source element #2.
- PointerPressed (bubble) on intermediate element #1.
- PointerPressed (bubble) on root element.
`PointerPressed` `PointerPressed` `PointerPressed` `PointerPressed` `PointerPressed` `PointerPressed` A routed event handler delegate provides references to two objects: the object that raised the event and the object where the handler was invoked. The object where the handler was invoked is the object reported by the sender parameter. The object where the event was first raised is reported by the Source property in the event data. A routed event can still be raised and handled by the same object, in which case sender and Source are identical (this is the case with Steps 3 and 4 in the event processing example list).
`sender` `Source` `sender` `Source` Because of tunneling and bubbling, parent elements receive input events where the Source is one of their child elements. When it is important to know what the source element is, you can identify the source element by accessing the Source property.
`Source` `Source` Usually, once the input event is marked Handled, further handlers are not invoked. Typically, you should mark input events as handled as soon as a handler is invoked that addresses your application-specific logical handling of the meaning of the input event.
`Handled` The exception to this general statement about Handled state is that input event handlers that are registered to deliberately ignore Handled state of the event data would still be invoked along either route.
`Handled` `Handled` Certain classes choose to class-handle certain input events, usually with the intent of redefining what a particular user-driven input event means within that control and raising a new event.
- What Is a Routed EventTop-level Scenarios for Routed EventsHow Routed Events Are ImplementedRouted Event Handlers and XAML
- Top-level Scenarios for Routed Events
- How Routed Events Are Implemented
- Routed Event Handlers and XAML
- Routing Strategies
- Why Use Routed Events?
- Adding and Implementing an Event Handler for a Routed Event
- Class Handlers
- Attached Events in Avalonia
- Qualified Event Names in XAML
- Input Events
- Top-level Scenarios for Routed Events
- How Routed Events Are Implemented
- Routed Event Handlers and XAML
# Input | Avalonia Docs
- Deep Dives
- Input
## Input
Avalonia operates on the abstraction called pointer devices.
Various Controls that implement ICommandSource have a HotKey property
`ICommandSource` `HotKey` Controls most often detect and respond to user input. The Avalonia input system uses both direct and routed events to support text input, focus management, and mouse positioning.
Applications often have complex input requirements. Avalonia provides a command system that separates user-input actions from the code that responds to those actions.
# Adding Interactivity | Avalonia Docs
- Basics
- User Interface
- Adding Interactivity
## Adding Interactivity
One of the fundamental things that a user interface must do is interact with the user. In Avalonia, you can add interactivity to your applications by leveraging events and commands. This guide will introduce events and commands with simple examples.
### Handling Events​
Events in Avalonia provide a way to respond to user interactions and control-specific actions. You can handle events by following these steps:
- Implement the Event Handler: Write an event handler in the code-behind that will be executed when the event is triggered. The event handler should contain the logic you want to execute in response to the event.
```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();  }  private void HandleButtonClick(object sender, RoutedEventArgs e)  {    // Event handling logic goes here  }}
```
- Subscribe to the Event: Identify the event you want to handle in your control. Most controls in Avalonia expose various events, such as Click or SelectionChanged. Subscribe to the event in XAML by locating the control and adding an attribute with the name of the event and a value indicating the name of the event handler method.
`Click` `SelectionChanged` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    x:Class="AvaloniaApplication1.Views.MainWindow"> <Button Name="myButton" Content="Click Me" Click="HandleButtonClick" /></Window>
```
The above example adds a handler called HandleButtonClick to a Button's Click event.
`HandleButtonClick` `Button` `Click` ### Using Commands​
Commands in Avalonia provide a higher-level approach to handling user interactions, decoupling the user action from the implementation logic. Whereas events are defined in a control's code-behind, commands are usually bound to a property or method on the data context.
Commands are available in all controls which provide a Command property. The command is usually triggered when the control's primary method of interaction occurs, for example a button click.
`Command` The simplest way of using commands is to bind to a method in the object's data context.
- Add a method to the view model: Define a method in a view model which will handle the command.
```bash
public class MainWindowViewModel  {    public bool HandleButtonClick()    {      // Event handling logic here    }  }
```
- Bind the Method: Associate the method with the control that triggers it. XAML<Button Content="Click Me" Command="{Binding HandleButtonClick}" />
Bind the Method: Associate the method with the control that triggers it.
```bash
<Button Content="Click Me" Command="{Binding HandleButtonClick}" />
```
- Handling Events
- Using Commands
# Data Context | Avalonia Docs
- Basics
- Data
- Data Binding
- Data Context
## Data Context
When Avalonia performs data binding, it has to locate an application object to bind to. This location is represented by a Data Context.
Every control in Avalonia has a property called DataContext, and this includes built-in controls, user controls and windows.
`DataContext` When binding, Avalonia performs a hierarchical search of the logical control tree, starting with the control where the binding is defined, until it finds a data context to use.
This means that a control defined in a window can use the data context of the window; or (as above) a control in a control in a window can use the window's data context.
For information about the control trees in Avalonia, and how to see them at run-time, see here.
### Example​
You can see the window's data context being set if you create a new project using the Avalonia MVVM Application template. Locate and open the App.axaml.cs file to see the code:
```bash
public override void OnFrameworkInitializationCompleted(){  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)  {    desktop.MainWindow = new MainWindow    {      DataContext = new MainWindowViewModel(),    };  }  base.OnFrameworkInitializationCompleted();}
```
You can trace the object being set to the window's data context in the file MainWindowViewModel.cs. The code looks like this:
```bash
public class MainWindowViewModel : ViewModelBase{  public string Greeting => "Welcome to Avalonia!";}
```
In the main window file MainWindow.axaml you can see that the window content zone is comprised a text block that has its text property bound to the Greeting property.
`Greeting` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:vm="using:AvaloniaMVVMApplication2.ViewModels"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaMVVMApplication2.Views.MainWindow"    Icon="/Assets/avalonia-logo.ico"    Title="AvaloniaMVVMApplication2">  <Design.DataContext>    <vm:MainWindowViewModel/>  </Design.DataContext>  <TextBlock Text="{Binding Greeting}" HorizontalAlignment="Center" VerticalAlignment="Center"/></Window>
```
When the project runs, the data binder searches up the logical control tree from the text block and finds a data context set at the main window level. So the bound text appears as:
### Design Data Context​
You may have noticed, after you first compiled this project, that the preview pane also shows the greeting.
This is because Avalonia can also set a data context for a control for use at design-time. You will find this useful because it means that the preview pane can show some realistic data while you adjust layout and styles.
You can see the design-time data context being set in the XAML:
```bash
<Design.DataContext>  <vm:MainWindowViewModel/></Design.DataContext>
```
For a more detailed guide about using the design-time data context, see here.
Further discussion of data binding requires you to have a background in the MVVM pattern of programming. For an introduction to the concepts of the MVVM pattern, see here.
Further Information
Bind to Commands
- Example
- Design Data Context
# Data Binding | Avalonia Docs
- Basics
- Data
- Data Binding
## Data Binding
Avalonia uses data binding to move data from application objects into UI controls, change the data in application objects in response to user input, and initiate actions on the application objects in response to commands from the user.
In this arrangement, the control is the binding target, and the object is the data source.
Avalonia runs a data binding system to complete much of the above activity from simple mappings declared in the XAML; that is without requiring you to add a lot of additional coding.
Data binding mappings are defined using XML between the attributes of an Avalonia control, and the properties of an application object. In general terms, the syntax is like this:
```bash
<SomeControl Attribute="{Binding PropertyName}" />
```
The mappings can be bidirectional: where changes in the properties of a bound application object are reflected in the control, and changes in the control (however caused) are applied to the underlying object. An example of bidirectional binding is a text input bound to a string property of an object. The XML might look like this:
```bash
<TextBox Text="{Binding FirstName}" />
```
If the user edits the text in the text box, then the FirstName property of the underlying object is automatically updated. In the other direction, if the FirstName property of the underlying object changes, then the text visible in the text box is updated.
`FirstName` `FirstName` Bindings can be unidirectional: where changes in the properties of a bound application object are reflected in the control, but the user cannot change the control. An example of this would be the text block control, which is read-only.
```bash
<TextBlock Text="{Binding StatusMessage}" />
```
Binding is used with the MVVM architectural pattern, and this is one of the principle ways of programming with Avalonia UI.
For more information about how to use the MVVM Pattern with Avalonia, see the concept page here.
For background information on the origins and development of the MVVM pattern at Microsoft, see the Microsoft Patterns and Practices article here.
On the next page, you will learn where the data binder gets the data object from.
# MessageBox | Avalonia Docs
- Basics
- User Interface
- MessageBox
## MessageBox
At present, Avalonia does not provide a native MessageBox component. This feature is under consideration for future development as we continuously seek to expand and enhance the capabilities of our toolkit. Developers requiring MessageBox functionality can explore various third-party solutions (listed below).
`MessageBox` We invite you to refer to the issue on our GitHub repository for ongoing updates and discussions about the MessageBox feature in Avalonia UI.
### 3rd Party MessageBox Implementations​
- Actipro Avalonia UI Controls
- DialogHost.Avalonia
- MessageBox.Avalonia
- Ursa.Avalonia
- 3rd Party MessageBox Implementations
# Multi-Touch | Avalonia Docs
- Basics
- User Interface
- Multi-Touch
## Multi-Touch
Avalonia UI, unlike some other frameworks, doesn't segregate touch events. Instead, it uses a pointer event system which unifies mouse, stylus, and touch events. This means that rather than having separate TouchEnter or TouchLeave events, you would use PointerPressed, PointerMoved, and PointerReleased events to track touch inputs.
`TouchEnter` `TouchLeave` `PointerPressed` `PointerMoved` `PointerReleased` ### Using Gesture Recognizers​
In addition to basic touch events, Avalonia provides built-in gesture recognizers that make handling common touch gestures like pinch and scroll a breeze. Here's how you can use them:
```bash
<Image Stretch="UniformToFill"    Margin="5"    Name="PinchImage"    Source="/Assets/delicate-arch-896885_640.jpg">  <Image.GestureRecognizers>    <PinchGestureRecognizer/>    <ScrollGestureRecognizer CanHorizontallyScroll="True" CanVerticallyScroll="True"/>  </Image.GestureRecognizers></Image>
```
In this example, an Image control is set up to respond to pinch and scroll gestures. The PinchGestureRecognizer enables pinch-to-zoom functionality, and the ScrollGestureRecognizer allows the image to be scrolled both horizontally and vertically.
`Image` `PinchGestureRecognizer` `ScrollGestureRecognizer` - Using Gesture Recognizers
# File Dialogs | Avalonia Docs
- Basics
- User Interface
- File Dialogs
## File Dialogs
The file dialog functionality is accessed through the StorageProvider service API, which is available from the Window or TopLevel classes. This page shows only basic usage and for more information about this API please visit StorageProvider page.
`StorageProvider` `Window` `TopLevel` ### OpenFilePickerAsync​
This method opens a file picker dialog, allowing the user to select a file. FilePickerOpenOptions defines options that are passed to the OS dialog.
`FilePickerOpenOptions` ```bash
public class MyView : UserControl{  private async void OpenFileButton_Clicked(object sender, RoutedEventArgs args)  {    // Get top level from the current control. Alternatively, you can use Window reference instead.    var topLevel = TopLevel.GetTopLevel(this);    // Start async operation to open the dialog.    var files = await topLevel.StorageProvider.OpenFilePickerAsync(new FilePickerOpenOptions    {      Title = "Open Text File",      AllowMultiple = false    });    if (files.Count >= 1)    {      // Open reading stream from the first file.      await using var stream = await files[0].OpenReadAsync();      using var streamReader = new StreamReader(stream);      // Reads all the content of file as a text.      var fileContent = await streamReader.ReadToEndAsync();    }  }}
```
### SaveFilePickerAsync​
This method opens a file save dialog, allowing the user to save a file. FilePickerSaveOptions defines options that are passed to the OS dialog.
`FilePickerSaveOptions` #### Example​
```bash
public class MyView : UserControl{  private async void SaveFileButton_Clicked(object sender, RoutedEventArgs args)  {    // Get top level from the current control. Alternatively, you can use Window reference instead.    var topLevel = TopLevel.GetTopLevel(this);    // Start async operation to open the dialog.    var file = await topLevel.StorageProvider.SaveFilePickerAsync(new FilePickerSaveOptions    {      Title = "Save Text File"    });    if (file is not null)    {      // Open writing stream from the file.      await using var stream = await file.OpenWriteAsync();      using var streamWriter = new StreamWriter(stream);      // Write some content to the file.      await streamWriter.WriteLineAsync("Hello World!");    }  }}
```
For more information on StorageProvider service including on how to keep access to the picked files and what possible options are supported, please visit StorageProvider documentation page and subpages.
`StorageProvider` The provided examples directly access the StorageProvider API inside the ViewModel for learning purposes. In a real-world application, it's recommended to adhere to MVVM principles by creating service classes and locating them with Dependency Injection / Inversion of Control (DI/IoC). Please refer to the IoCFileOps and DepInject projects for samples of how to achieve this.
`StorageProvider` - OpenFilePickerAsync
- SaveFilePickerAsyncExample
- Example
# StorageProvider | Avalonia Docs
- Deep Dives
- Services
- Storage Provider
## StorageProvider
The StorageProvider is central to file and folder management. It provides methods for file and folder selection, checking platform capabilities, and interacting with stored bookmarks.
`StorageProvider` The StorageProvider can be access through an instance of TopLevel or Window, for more details on accessing TopLevel please visit TopLevel page:
`StorageProvider` `TopLevel` `Window` `TopLevel` ```bash
var storage = window.StorageProvider;
```
### Properties​
#### CanOpen​
Indicates whether it's possible to open a open file picker on the current platform.
`open file picker` ```bash
bool CanOpen { get; }
```
#### CanSave​
Indicates whether it's possible to open a save file picker on the current platform.
`save file picker` ```bash
bool CanSave { get; }
```
#### CanPickFolder​
Indicates whether it's possible to open a folder picker on the current platform.
`folder picker` ```bash
bool CanPickFolder { get; }
```
### Methods​
#### OpenFilePickerAsync​
Opens a file picker dialog.
```bash
Task<IReadOnlyList<IStorageFile>> OpenFilePickerAsync(FilePickerOpenOptions options);
```
The method returns an array of selected IStorageFile instances or an empty collection if the user cancels the dialog.
`IStorageFile` #### SaveFilePickerAsync​
Opens a save file picker dialog.
```bash
Task<IStorageFile?> SaveFilePickerAsync(FilePickerSaveOptions options);
```
The method returns a saved IStorageFile instance or null if the user cancels the dialog.
`IStorageFile` #### OpenFolderPickerAsync​
Opens a folder picker dialog.
```bash
Task<IReadOnlyList<IStorageFolder>> OpenFolderPickerAsync(FolderPickerOpenOptions options);
```
The method returns an array of selected IStorageFolder instances or an empty collection if the user cancels the dialog.
`IStorageFolder` #### OpenFileBookmarkAsync​
Opens a IStorageBookmarkFile from the bookmark ID.
`IStorageBookmarkFile` ```bash
Task<IStorageBookmarkFile?> OpenFileBookmarkAsync(string bookmark);
```
The method returns a bookmarked file or null if the operating system denied the request.
#### OpenFolderBookmarkAsync​
Opens a IStorageBookmarkFolder from the bookmark ID.
`IStorageBookmarkFolder` ```bash
Task<IStorageBookmarkFolder?> OpenFolderBookmarkAsync(string bookmark);
```
The method returns a bookmarked folder or null if the operating system denied the request.
#### TryGetFileFromPathAsync​
Attempts to read a file from the file system by its path.
```bash
Task<IStorageFile?> TryGetFileFromPathAsync(Uri filePath);
```
The method returns a file or null if it doesn't exist. The filePath parameter is expected to be an absolute path with a "file" scheme, but can be a URI with a "content" scheme on Android.
#### TryGetFolderFromPathAsync​
Attempts to read a folder from the file system by its path.
```bash
Task<IStorageFolder?> TryGetFolderFromPathAsync(Uri folderPath);
```
The method returns a folder or null if it doesn't exist. The folderPath parameter is expected to be an absolute path with a "file" scheme, but can be a URI with a "content" scheme on Android.
#### TryGetWellKnownFolderAsync​
Attempts to read a folder from the file system by its well-known folder identifier.
```bash
Task<IStorageFolder?> TryGetWellKnownFolderAsync(WellKnownFolder wellKnownFolder);
```
The method returns a folder or null if it doesn't exist.
### Extension methods​
#### TryGetFileFromPathAsync​
Attempts to read a file from the file system by its path.
```bash
Task<IStorageFile?> TryGetFileFromPathAsync(this IStorageProvider provider, string filePath);
```
The method returns a file or null if it doesn't exist. This method accepts local file path string as a parameter without any scheme. Only supported on the OS, with physical file paths, primarily only desktop.
#### TryGetFolderFromPathAsync​
Attempts to read a folder from the file system by its path.
```bash
Task<IStorageFolder?> TryGetFolderFromPathAsync(this IStorageProvider provider, string folderPath);
```
The method returns a folder or null if it doesn't exist. This method accepts local folder path string as a parameter without any scheme. Only supported on the OS, with physical file paths, primarily only desktop.
### Platform compatibility:​
`OpenFileBookmarkAsync` `OpenFolderBookmarkAsync` `OpenFilePickerAsync` `SaveFilePickerAsync` `OpenFolderPickerAsync` `TryGetFileFromPathAsync` `TryGetFolderFromPathAsync` `TryGetWellKnownFolderAsync` * Bookmarks are not properly supported on desktop platforms and instead return file path instead. macOS support is planned in order to get it work with Sandboxed Apple Store apps.
** Managed file picker works only on desktop platforms where it's possible to open a custom window.
*** Only Chromium based browsers have a proper support for file pickers.
- PropertiesCanOpenCanSaveCanPickFolder
- CanOpen
- CanSave
- CanPickFolder
- MethodsOpenFilePickerAsyncSaveFilePickerAsyncOpenFolderPickerAsyncOpenFileBookmarkAsyncOpenFolderBookmarkAsyncTryGetFileFromPathAsyncTryGetFolderFromPathAsyncTryGetWellKnownFolderAsync
- OpenFilePickerAsync
- SaveFilePickerAsync
- OpenFolderPickerAsync
- OpenFileBookmarkAsync
- OpenFolderBookmarkAsync
- TryGetFileFromPathAsync
- TryGetFolderFromPathAsync
- TryGetWellKnownFolderAsync
- Extension methodsTryGetFileFromPathAsyncTryGetFolderFromPathAsync
- TryGetFileFromPathAsync
- TryGetFolderFromPathAsync
- Platform compatibility:
- CanOpen
- CanSave
- CanPickFolder
- OpenFilePickerAsync
- SaveFilePickerAsync
- OpenFolderPickerAsync
- OpenFileBookmarkAsync
- OpenFolderBookmarkAsync
- TryGetFileFromPathAsync
- TryGetFolderFromPathAsync
- TryGetWellKnownFolderAsync
- TryGetFileFromPathAsync
- TryGetFolderFromPathAsync
# Services | Avalonia Docs
- Deep Dives
- Services
## Services
This section will introduce you to the services included in an application.
# Activatable Lifetime | Avalonia Docs
- Deep Dives
- Services
- Activatable Lifetime
## Activatable Lifetime v11.1
The IActivatableLifetime service defines a set of methods and events related to the activation and deactivation lifecycle of an application. IActivatableLifetime is a global app-level service that can be accessed from the Application instance using the TryGetService method: Application.Current.TryGetService<IActivatableLifetime>().
`IActivatableLifetime` `IActivatableLifetime` `TryGetService` `Application.Current.TryGetService<IActivatableLifetime>()` ### Events​
#### Activated​
An event that is raised when the application is Activated for various reasons as described by the ActivationKind enumeration.
#### Deactivated​
An event that is raised when the application is Deactivated for various reasons as described by the ActivationKind enumeration.
### Methods​
#### TryLeaveBackground​
Tells the application that it should attempt to leave its background state. Returns true if it was possible and the platform supports this. False otherwise.
For example on macOS this would be [NSApp unhide].
#### TryEnterBackground​
Tells the application that it should attempt to enter its background state.
Returns true if it was possible and the platform supports this. False otherwise.
For example on macOS this would be [NSApp hide].
### Examples​
#### Handling app entering and exiting background state​
In some applications, you might want to pause or stop some code processing, while application is in background. It might be pausing multimedia playback, or disabling recurrent HTTP requests.
```bash
if (Application.Current.TryGetFeature<IActivatableLifetime>() is { } activatableLifetime){  activatableLifetime.Activated += (sender, args) =>  {    if (args.Kind == ActivationKind.Background)    {      Console.WriteLine($"App exited background");    }  };  activatableLifetime.Deactivated += (sender, args) =>  {    if (args.Kind == ActivationKind.Background)    {      Console.WriteLine($"App entered background");    }  };}
```
#### Handling URI activation​
Some apps might need to supports Protocol Activation, or as it's often called - deep linking. Link schemas (protocols) that are registered in the system and associated with the app. Once registered, OS will always redirect these links to the app.
App can handle these links in different ways. But typical use cases would be either enabling navigation to the specific page, or using it as a redirect URL in OAuth operations.
```bash
if (Application.Current.TryGetFeature<IActivatableLifetime>() is { } activatableLifetime){  activatableLifetime.Activated += (s, a) =>  {    if (a is ProtocolActivatedEventArgs protocolArgs && protocolArgs.Kind == ActivationKind.OpenUri)    {      Console.WriteLine($"App activated via Uri: {protocolArgs.Uri}");    }  };}
```
In order to enable protocol handling for your app, you need to follow platform specific instructions on updating manifest. On macOS and iOS, you need to add CFBundleURLTypes with CFBundleURLSchemes segment to your Info.plist. See https://rderik.com/blog/creating-app-custom-url-scheme/ (skip Swift part, as it's handled by IActivatableLifetime). On Android, you need to add intent-filter with specific android:scheme to your AndroidManifest.xml. See https://developer.android.com/training/app-links/deep-linking for details (skip Kotlin/Java parts, as it's handled by IActivatableLifetime).
`Info.plist` `IActivatableLifetime` `intent-filter` `android:scheme` `AndroidManifest.xml` `IActivatableLifetime` ### Platform compatibility:​
`ActivationKind.Background` `ActivationKind.File` `ActivationKind.OpenUri` `ActivationKind.Reopen` `TryLeaveBackground` `TryEnterBackground` See https://github.com/AvaloniaUI/Avalonia/issues/15316 for more information on currently supported and unsupported platforms.
- EventsActivatedDeactivated
- Activated
- Deactivated
- MethodsTryLeaveBackgroundTryEnterBackground
- TryLeaveBackground
- TryEnterBackground
- ExamplesHandling app entering and exiting background stateHandling URI activation
- Handling app entering and exiting background state
- Handling URI activation
- Platform compatibility:
- Activated
- Deactivated
- TryLeaveBackground
- TryEnterBackground
- Handling app entering and exiting background state
- Handling URI activation
# Clipboard | Avalonia Docs
- Deep Dives
- Services
- Clipboard
## Clipboard
The Clipboard class enables interacting with the system clipboard, providing functionality for setting and retrieving text, clearing the clipboard, handling data objects and working with different data formats.
`Clipboard` The Clipboard can be access through an instance of TopLevel or Window, for more details on accessing TopLevel please visit TopLevel page:
`Clipboard` `TopLevel` `Window` `TopLevel` ```bash
var clipboard = window.Clipboard;
```
### Methods​
#### GetTextAsync()​
Retrieves text from the clipboard asynchronously. The resulting value of the task is the text from the clipboard. If the clipboard doesn't contain text or is empty, the method returns null.
`null` ```bash
Task<string?> GetTextAsync()
```
Avalonia clipboard always operates with Unicode text.
#### SetTextAsync(string? text)​
Sets the clipboard text asynchronously and flushes it immediately. This method accepts a string? parameter for a text that needs to be copied. If the provided text is null, the clipboard will be cleared.
`string?` `null` ```bash
Task SetTextAsync(string? text)
```
Unlikely different Win32 clipboard APIs, Avalonia clipboard always flushes data and is never delayed.
#### ClearAsync()​
Clears the clipboard asynchronously flushes it immediately.
```bash
Task ClearAsync()
```
#### SetDataObjectAsync(IDataObject data)​
Sets the clipboard content to the specified data object asynchronously. This method accepts an IDataObject parameter. The data object can contain multiple data formats.
`IDataObject` ```bash
Task SetDataObjectAsync(IDataObject data)
```
Unlikely different Win32 clipboard APIs, Avalonia clipboard always flushes data and is never delayed.
#### GetFormatsAsync()​
Retrieves the list of formats currently stored in the clipboard asynchronously. The resulting value of the task is an array of string format names.
```bash
Task<string[]> GetFormatsAsync()
```
#### GetDataAsync(string format)​
Retrieves data in the specified format from the clipboard asynchronously. This method returns a Task<object?> that represents the operation. The resulting value of the task is the clipboard data in the specified format. If there's no data in the clipboard in the specified format, the method returns null.
`Task<object?>` `null` ```bash
Task<object?> GetDataAsync(string format)
```
### Creating a DataObject to be sent to the clipboard​
You can store objects on the clipboard on some platforms with different formats.
```bash
private async void CopyButton_OnClick(object? sender, RoutedEventArgs args){  var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;  var dataObject = new DataObject();  dataObject.Set(DataFormats.Text, "Hello World");  await clipboard.SetDataObjectAsync(dataObject);}
```
### Platform compatibility:​
`GetTextAsync` `SetTextAsync` `ClearAsync` `GetFormatsAsync` `SetDataObjectAsync` `GetDataAsync` * Technically possible, but wasn't implemented yet. Contributions are welcome!
** In the Mozilla browser, the GetTextAsync method only functions after the "Paste" gesture has been triggered, typically by using Ctrl+V.
- MethodsGetTextAsync()SetTextAsync(string? text)ClearAsync()SetDataObjectAsync(IDataObject data)GetFormatsAsync()GetDataAsync(string format)
- GetTextAsync()
- SetTextAsync(string? text)
- ClearAsync()
- SetDataObjectAsync(IDataObject data)
- GetFormatsAsync()
- GetDataAsync(string format)
- Creating a DataObject to be sent to the clipboard
- Platform compatibility:
- GetTextAsync()
- SetTextAsync(string? text)
- ClearAsync()
- SetDataObjectAsync(IDataObject data)
- GetFormatsAsync()
- GetDataAsync(string format)
# The TopLevel | Avalonia Docs
- Deep Dives
- The TopLevel
## The TopLevel
The TopLevel act as the visual root, and is the base class for all top level controls, eg. Window. It handles scheduling layout, styling and rendering as well as keeping track of the client size. Most services are accessed through the TopLevel.
`Window` ### Getting the TopLevel​
Here are two common ways to access TopLevel instance.
#### Using TopLevel.GetTopLevel​
You can use the static GetTopLevel method of the TopLevel class to get the top-level control that contains the current control.
`GetTopLevel` ```bash
var topLevel = TopLevel.GetTopLevel(control);// Here you can reference various services like Clipboard or StorageProvider from topLevel instance.
```
This method can be helpful if you're working within a user control or a lower-level component and need access to the TopLevel services.
If TopLevel.GetTopLevel returns null, likely control is not yet attached to the root. To ensure control is attached, you should handle Control.Loaded and Control.Unloaded events and keep track of current top level from these events.
`TopLevel.GetTopLevel` `Control.Loaded` `Control.Unloaded` #### Using the Window Class​
Since theWindow class inherits from TopLevel, you can directly access services from an instance of Window:
`Window` `TopLevel` `Window` ```bash
var topLevel = window;
```
This method is typically used when you're already working within the context of a window, such as in a ViewModel or an event handler within the Window class.
`Window` ### Common Properties​
#### ActualTransparencyLevel​
Gets the achieved WindowTransparencyLevel that the platform was able to provide.
`WindowTransparencyLevel` ```bash
WindowTransparencyLevel ActualTransparencyLevel { get; }
```
#### ClientSize​
Gets the client size of the window.
```bash
Size ClientSize { get; }
```
#### Clipboard​
Gets the platform's Clipboard implementation.
```bash
IClipboard? Clipboard { get; }
```
#### FocusManager​
Gets focus manager of the root.
```bash
IFocusManager? FocusManager { get; }
```
#### FrameSize​
Gets the total size of the top level including system frame if presented.
```bash
Size? FrameSize { get; }
```
#### InsetsManager​
Gets the platform's InsetsManager implementation.
```bash
IInsetsManager? InsetsManager { get; }
```
#### PlatformSettings​
Represents a contract for accessing top-level platform-specific settings.
```bash
IPlatformSettings? PlatformSettings { get; }
```
#### RendererDiagnostics​
Gets a value indicating whether the renderer should draw specific diagnostics.
```bash
RendererDiagnostics RendererDiagnostics { get; }
```
#### RenderScaling​
Gets the scaling factor to use in rendering.
```bash
double RenderScaling { get; }
```
#### RequestedThemeVariant​
Gets or sets the UI theme variant that is used by the control (and its child elements) for resource determination. The UI theme you specify with ThemeVariant can override the app-level ThemeVariant.
```bash
ThemeVariant? RequestedThemeVariant { get; set; }
```
#### StorageProvider​
File System storage service used for file pickers and bookmarks.
```bash
IStorageProvider StorageProvider { get; }
```
#### TransparencyBackgroundFallback​
Gets or sets the IBrush that transparency will blend with when transparency is not supported. By default this is a solid white brush.
`IBrush` ```bash
IBrush TransparencyBackgroundFallback { get; set; }
```
#### TransparencyLevelHint​
Gets or sets the WindowTransparencyLevel that the TopLevel should use when possible. Accepts multiple values which are applied in a fallback order. For instance, with "Mica, Blur" Mica will be applied only on platforms where it is possible, and Blur will be used on the rest of them. Default value is an empty array or "None".
`WindowTransparencyLevel` ```bash
IReadOnlyList<WindowTransparencyLevel> TransparencyLevelHint { get; set; }
```
### Common Events​
#### BackRequested​
Occurs when physical Back Button is pressed or a back navigation has been requested.
```bash
event EventHandler<RoutedEventArgs> BackRequested { add; remove; }
```
#### Closed​
Fired when the window is closed.
```bash
event EventHandler Closed;
```
#### Opened​
Fired when the window is opened.
```bash
event EventHandler Opened;
```
#### ScalingChanged​
Occurs when the TopLevel's scaling changes.
```bash
event EventHandler ScalingChanged;
```
### Common Methods​
#### GetTopLevel​
Gets the TopLevel for which the given Visual is hosted in.
`TopLevel` `Visual` ##### Parameters​
control The visual to query its TopLevel
`control` ```bash
static TopLevel? GetTopLevel(Visual? visual)
```
#### RequestAnimationFrame​
Enqueues a callback to be called on the next animation tick
```bash
void RequestAnimationFrame(Action<TimeSpan> action)
```
#### RequestPlatformInhibition​
Requests a PlatformInhibitionType to be inhibited. The behavior remains inhibited until the return value is disposed. The available set of PlatformInhibitionTypes depends on the platform. If a behavior is inhibited on a platform where this type is not supported the request will have no effect.
`PlatformInhibitionType` `PlatformInhibitionType` ```bash
async Task<IDisposable> RequestPlatformInhibition(PlatformInhibitionType type, string reason)
```
#### TryGetPlatformHandle​
Tries to get the platform handle for the TopLevel-derived control.
```bash
IPlatformHandle? TryGetPlatformHandle()
```
### More Information​
View the source code on GitHub TopLevel.cs
`TopLevel.cs` - Getting the TopLevelUsing TopLevel.GetTopLevelUsing the Window Class
- Using TopLevel.GetTopLevel
- Using the Window Class
- Common PropertiesActualTransparencyLevelClientSizeClipboardFocusManagerFrameSizeInsetsManagerPlatformSettingsRendererDiagnosticsRenderScalingRequestedThemeVariantStorageProviderTransparencyBackgroundFallbackTransparencyLevelHint
- ActualTransparencyLevel
- ClientSize
- Clipboard
- FocusManager
- FrameSize
- InsetsManager
- PlatformSettings
- RendererDiagnostics
- RenderScaling
- RequestedThemeVariant
- StorageProvider
- TransparencyBackgroundFallback
- TransparencyLevelHint
- Common EventsBackRequestedClosedOpenedScalingChanged
- BackRequested
- Closed
- Opened
- ScalingChanged
- Common MethodsGetTopLevelRequestAnimationFrameRequestPlatformInhibitionTryGetPlatformHandle
- GetTopLevel
- RequestAnimationFrame
- RequestPlatformInhibition
- TryGetPlatformHandle
- More Information
- Using TopLevel.GetTopLevel
- Using the Window Class
- ActualTransparencyLevel
- ClientSize
- Clipboard
- FocusManager
- FrameSize
- InsetsManager
- PlatformSettings
- RendererDiagnostics
- RenderScaling
- RequestedThemeVariant
- StorageProvider
- TransparencyBackgroundFallback
- TransparencyLevelHint
- BackRequested
- Closed
- Opened
- ScalingChanged
- GetTopLevel
- RequestAnimationFrame
- RequestPlatformInhibition
- TryGetPlatformHandle
# Focus Manager | Avalonia Docs
- Deep Dives
- Services
- Focus Manager
## Focus Manager
The FocusManager service is responsible for managing the keyboard focus for the application. It keeps track of the currently focused element and the current focus scope.
`FocusManager` The FocusManager can be access through an instance of TopLevel or Window, for more details on accessing TopLevel please visit TopLevel page:
`FocusManager` `TopLevel` `Window` `TopLevel` ```bash
var focusManager = window.FocusManager;
```
### Methods​
#### GetFocusedElement()​
Returns the currently focused element.
```bash
IInputElement? GetFocusedElement()
```
#### ClearFocus()​
Clears the currently focused element.
```bash
void ClearFocus()
```
### Tips​
#### Focusing a control​
Developers usually don't need a FocusManager service to focus a control. It can be achieved with a method call directly on the control:
`FocusManager` ```bash
var hasFocused = button.Focus();
```
Focus method might return false is control is not visible and has Focusable property set to false.
`Focus` `false` `Focusable` #### Listening for global focus changes​
While FocusManager.GetFocusedElement method allows to get currently focused control, it's not suitable as an event. Instead, please use InputElement.GotFocusEvent.Raised.Subscribe(handler) method. Note, it listens events globally across all top levels.
`FocusManager.GetFocusedElement` `InputElement.GotFocusEvent.Raised.Subscribe(handler)` - MethodsGetFocusedElement()ClearFocus()
- GetFocusedElement()
- ClearFocus()
- TipsFocusing a controlListening for global focus changes
- Focusing a control
- Listening for global focus changes
- GetFocusedElement()
- ClearFocus()
- Focusing a control
- Listening for global focus changes
# Launcher | Avalonia Docs
- Deep Dives
- Services
- Launcher
## Launcher v11.1
The Launcher allows you to open file or a URI link in the default app associated with the specified argument.
`Launcher` The Launcher can be access through an instance of TopLevel or Window, for more details on accessing TopLevel please visit TopLevel page:
`Launcher` `TopLevel` `Window` `TopLevel` ```bash
var launcher = TopLevel.GetTopLevel(control).Launcher;
```
### Methods​
#### LaunchUriAsync​
Starts the default app associated with the URI scheme name for the specified URI.
```bash
Task<bool> LaunchUriAsync(Uri uri)
```
Input URI can have any scheme including custom ones. But it's up to the Operating System to accept or deny this launcher request.
#### LaunchFileAsync​
Starts the default app associated with the specified storage file or folder.
```bash
Task<bool> LaunchFileAsync(IStorageItem storageItem);
```
IStorageItem is a file or folder retrieved from sandboxed APIs such as IStorageProvider or IClipboard. If you only target non-sandboxed desktop platforms, consider using extension methods accepting FileInfo or DirectoryInfo.
### Extension Methods​
#### LaunchFileInfoAsync​
Starts the default app associated with the specified storage file.
```bash
Task<bool> LaunchFileInfoAsync(FileInfo fileInfo)
```
#### LaunchFileAsync​
Starts the default app associated with the specified storage directory (folder).
```bash
Task<bool> LaunchDirectoryInfoAsync(DirectoryInfo directoryInfo);
```
Each of these methods returns a boolean result indicating whether OS can handle request or not. It does not guarantee, that there is an app than can handle launcher request.
### Platform compatibility:​
`LaunchUriAsync` `LaunchFileAsync` `LaunchFileInfoAsync` `LaunchDirectoryInfoAsync` - MethodsLaunchUriAsyncLaunchFileAsync
- LaunchUriAsync
- LaunchFileAsync
- Extension MethodsLaunchFileInfoAsyncLaunchFileAsync
- LaunchFileInfoAsync
- LaunchFileAsync
- Platform compatibility:
- LaunchUriAsync
- LaunchFileAsync
- LaunchFileInfoAsync
- LaunchFileAsync
# Input Pane | Avalonia Docs
- Deep Dives
- Services
- Input Pane
## Input Pane v11.1
The InputPane allows developers to listen for the platform's input pane (e.g., software keyboard or on-screen keyboard) current state and boundaries.
`InputPane` The InputPane can be access through an instance of TopLevel or Window, for more details on accessing TopLevel please visit TopLevel page:
`InputPane` `TopLevel` `Window` `TopLevel` ```bash
var inputPane = TopLevel.GetTopLevel(control).InputPane;
```
Currently, Avalonia does not automatically adjust root view and scrolling position depending on state of the input pane. Instead, it is recommended for developers to use IInputPane API and adjust their apps accordingly.
Automatic adjustment is planned for future 11.* releases.
### Properties​
#### State​
The current input pane state. Possible values:
- InputPaneState.Closed
- InputPaneState.Opened
`InputPaneState.Closed` `InputPaneState.Opened` ```bash
InputPaneState State { get; }
```
#### OccludedRect​
The current input pane bounds.
```bash
Rect OccludedRect { get; }
```
Return value is in client coordinates relative to the current top level. Empty rectangle will be returned in case of floating/detached input pane, that is positioned on top of the view.
### Events​
#### StateChanged​
Occurs when the input pane's state has changed.
```bash
event EventHandler<InputPaneStateEventArgs>? StateChanged;
```
Notably, event arguments include several useful parameters:
- InputPaneStateEventArgs.NewState - new state of the input pane.
- InputPaneStateEventArgs.StartRect - initial bounds of the input pane.
- InputPaneStateEventArgs.EndRect - final bounds of the input pane.
- InputPaneStateEventArgs.AnimationDuration - duration of the input pane's state change animation.
- InputPaneStateEventArgs.Easing - easing of the input pane's state changed animation.
`InputPaneStateEventArgs.NewState` `InputPaneStateEventArgs.StartRect` `InputPaneStateEventArgs.EndRect` `InputPaneStateEventArgs.AnimationDuration` `InputPaneStateEventArgs.Easing` Having AnimationDuration and Easing allows developer to create a transition between two states.
`AnimationDuration` `Easing` ### Platform compatibility:​
`State` `OccludedRect` `StateChanged` `StateChanged.StartRect` `StateChanged.AnimationDuration` `StateChanged.Easing` * - only mobile Chromium browsers support IInputPane API.
- PropertiesStateOccludedRect
- State
- OccludedRect
- EventsStateChanged
- StateChanged
- Platform compatibility:
- State
- OccludedRect
- StateChanged
# Insets Manager | Avalonia Docs
- Deep Dives
- Services
- Insets Manager
## Insets Manager
The InsetsManager allows you to interact with the platform's system bars and handle changes to the safe area of the mobile window.
`InsetsManager` The InsetsManager can be access through an instance of TopLevel or Window, for more details on accessing TopLevel please visit TopLevel page:
`InsetsManager` `TopLevel` `Window` `TopLevel` ```bash
var insetsManager = TopLevel.GetTopLevel(control).InsetsManager;
```
As for now, this service has implementation only on mobile and browser backends. If you need to adjust desktop window decorations, please use Window.ExtendClientAreaToDecorationsHint, Window.ExtendClientAreaChromeHints, Window.ExtendClientAreaTitleBarHeightHint properties.
`Window.ExtendClientAreaToDecorationsHint` `Window.ExtendClientAreaChromeHints` `Window.ExtendClientAreaTitleBarHeightHint` Starting with Avalonia 11.1, any Avalonia app will automatically adjust its root view accordingly to the inset values. This behavior can be disabled by setting TopLevel.AutoSafeAreaPadding="False" attached property value on the root view.
`TopLevel.AutoSafeAreaPadding="False"` ### Properties​
#### IsSystemBarVisible​
Gets or sets a value indicating whether the system bars are visible. Returns null if the platform doesn't support showing or hiding system bars.
```bash
bool? IsSystemBarVisible { get; set; }
```
#### DisplayEdgeToEdge​
Gets or sets a value indicating whether the window should be drawn edge-to-edge behind any visible system bars.
```bash
bool DisplayEdgeToEdge { get; set; }
```
#### SafeAreaPadding​
Gets the current safe area padding. The safe area represents the portion of the window that is not obscured by system bars.
```bash
Thickness SafeAreaPadding { get; }
```
#### SystemBarColor​
Gets or sets the color of the platform's system bars. Returns null if the platform doesn't support setting the system bar color.
```bash
Color? SystemBarColor { get; set; }
```
### Events​
#### SafeAreaChanged​
Occurs when the safe area for the current window changes. This can happen when system bars are shown or hidden, or when the window's size or orientation changes.
```bash
event EventHandler<SafeAreaChangedArgs>? SafeAreaChanged;
```
## SafeAreaChangedArgs
SafeAreaChangedArgs is a class that provides data for the SafeAreaChanged event.
### Properties​
#### SafeAreaPadding​
Gets the new safe area padding.
```bash
public Thickness SafeAreaPadding { get; }
```
## SystemBarTheme
SystemBarTheme is an enumeration with values that represent light and dark themes for the system bar.
### Values​
#### Light​
The system bar has a light background and a dark foreground.
#### Dark​
The system bar has a dark background and a light foreground.
### Platform compatibility:​
`IsSystemBarVisible` `DisplayEdgeToEdge` `SafeAreaPadding` `SystemBarColor` `SafeAreaChanged` * - only mobile Chromium browsers support IInsetsManager API.
- PropertiesIsSystemBarVisibleDisplayEdgeToEdgeSafeAreaPaddingSystemBarColor
- IsSystemBarVisible
- DisplayEdgeToEdge
- SafeAreaPadding
- SystemBarColor
- EventsSafeAreaChanged
- SafeAreaChanged
- PropertiesSafeAreaPadding
- SafeAreaPadding
- ValuesLightDark
- Light
- Dark
- Platform compatibility:
- IsSystemBarVisible
- DisplayEdgeToEdge
- SafeAreaPadding
- SystemBarColor
- SafeAreaChanged
- SafeAreaPadding
- Light
- Dark
# Platform Settings | Avalonia Docs
- Deep Dives
- Services
- Platform Settings
## Platform Settings
The PlatformSettings class represents a contract for accessing platform-specific settings and information. Some of these settings might be changed by the user globally in the OS in runtime.
`PlatformSettings` The PlatformSettings can be access through an instance of TopLevel or Window, for more details on accessing TopLevel please visit TopLevel page:
`PlatformSettings` `TopLevel` `Window` `TopLevel` ```bash
var platformSettings = window.PlatformSettings;
```
### Methods​
#### GetTapSize(PointerType type)​
Returns the size of the rectangle around the location of a pointer down that a pointer up must occur within in order to register a tap gesture, in device-independent pixels.
```bash
Size GetTapSize(PointerType type);
```
#### GetDoubleTapSize(PointerType type)​
Returns the size of the rectangle around the location of a pointer down that a pointer up must occur within in order to register a double-tap gesture, in device-independent pixels.
```bash
Size GetDoubleTapSize(PointerType type);
```
#### GetDoubleTapTime(PointerType type)​
Returns the maximum time that may occur between the first and second click of a double-tap gesture.
```bash
TimeSpan GetDoubleTapTime(PointerType type);
```
#### GetColorValues()​
Returns the current system color values, including dark mode and accent colors.
```bash
PlatformColorValues GetColorValues();
```
While build-in FluentTheme supports automatic switching between accent colors, this method is useful to apply custom logic with OS color settings.
### Properties​
#### HoldWaitDuration​
The duration between pointer press and when the Holding event is fired.
`Holding` ```bash
TimeSpan HoldWaitDuration { get; }
```
#### HotkeyConfiguration​
The configuration for platform-specific hotkeys in an Avalonia application.
```bash
PlatformHotkeyConfiguration HotkeyConfiguration { get; }
```
HotkeyConfiguration is especially useful when application needs to handle well known gestures like Copy, Paste or Cut.
```bash
protected override void OnKeyDown(KeyEventArgs e){  var hotkeys = TopLevel.GetTopLevel(this).PlatformSettings.HotkeyConfiguration;  if (hotkeys.Copy.Any(g => g.Matches(e)))  {    // Handle Copy hotkey.  }}
```
### Events​
#### ColorValuesChanged​
Raised when current system color values are changed. This includes changes to dark mode and accent colors.
```bash
event EventHandler<PlatformColorValues>? ColorValuesChanged;
```
Use the IPlatformSettings interface to adapt your application's behavior to user-specific platform settings.
`IPlatformSettings` - MethodsGetTapSize(PointerType type)GetDoubleTapSize(PointerType type)GetDoubleTapTime(PointerType type)GetColorValues()
- GetTapSize(PointerType type)
- GetDoubleTapSize(PointerType type)
- GetDoubleTapTime(PointerType type)
- GetColorValues()
- PropertiesHoldWaitDurationHotkeyConfiguration
- HoldWaitDuration
- HotkeyConfiguration
- EventsColorValuesChanged
- ColorValuesChanged
- GetTapSize(PointerType type)
- GetDoubleTapSize(PointerType type)
- GetDoubleTapTime(PointerType type)
- GetColorValues()
- HoldWaitDuration
- HotkeyConfiguration
- ColorValuesChanged
# StorageProvider | Avalonia Docs
- Deep Dives
- Services
- Storage Provider
## StorageProvider
The StorageProvider is central to file and folder management. It provides methods for file and folder selection, checking platform capabilities, and interacting with stored bookmarks.
`StorageProvider` The StorageProvider can be access through an instance of TopLevel or Window, for more details on accessing TopLevel please visit TopLevel page:
`StorageProvider` `TopLevel` `Window` `TopLevel` ```bash
var storage = window.StorageProvider;
```
### Properties​
#### CanOpen​
Indicates whether it's possible to open a open file picker on the current platform.
`open file picker` ```bash
bool CanOpen { get; }
```
#### CanSave​
Indicates whether it's possible to open a save file picker on the current platform.
`save file picker` ```bash
bool CanSave { get; }
```
#### CanPickFolder​
Indicates whether it's possible to open a folder picker on the current platform.
`folder picker` ```bash
bool CanPickFolder { get; }
```
### Methods​
#### OpenFilePickerAsync​
Opens a file picker dialog.
```bash
Task<IReadOnlyList<IStorageFile>> OpenFilePickerAsync(FilePickerOpenOptions options);
```
The method returns an array of selected IStorageFile instances or an empty collection if the user cancels the dialog.
`IStorageFile` #### SaveFilePickerAsync​
Opens a save file picker dialog.
```bash
Task<IStorageFile?> SaveFilePickerAsync(FilePickerSaveOptions options);
```
The method returns a saved IStorageFile instance or null if the user cancels the dialog.
`IStorageFile` #### OpenFolderPickerAsync​
Opens a folder picker dialog.
```bash
Task<IReadOnlyList<IStorageFolder>> OpenFolderPickerAsync(FolderPickerOpenOptions options);
```
The method returns an array of selected IStorageFolder instances or an empty collection if the user cancels the dialog.
`IStorageFolder` #### OpenFileBookmarkAsync​
Opens a IStorageBookmarkFile from the bookmark ID.
`IStorageBookmarkFile` ```bash
Task<IStorageBookmarkFile?> OpenFileBookmarkAsync(string bookmark);
```
The method returns a bookmarked file or null if the operating system denied the request.
#### OpenFolderBookmarkAsync​
Opens a IStorageBookmarkFolder from the bookmark ID.
`IStorageBookmarkFolder` ```bash
Task<IStorageBookmarkFolder?> OpenFolderBookmarkAsync(string bookmark);
```
The method returns a bookmarked folder or null if the operating system denied the request.
#### TryGetFileFromPathAsync​
Attempts to read a file from the file system by its path.
```bash
Task<IStorageFile?> TryGetFileFromPathAsync(Uri filePath);
```
The method returns a file or null if it doesn't exist. The filePath parameter is expected to be an absolute path with a "file" scheme, but can be a URI with a "content" scheme on Android.
#### TryGetFolderFromPathAsync​
Attempts to read a folder from the file system by its path.
```bash
Task<IStorageFolder?> TryGetFolderFromPathAsync(Uri folderPath);
```
The method returns a folder or null if it doesn't exist. The folderPath parameter is expected to be an absolute path with a "file" scheme, but can be a URI with a "content" scheme on Android.
#### TryGetWellKnownFolderAsync​
Attempts to read a folder from the file system by its well-known folder identifier.
```bash
Task<IStorageFolder?> TryGetWellKnownFolderAsync(WellKnownFolder wellKnownFolder);
```
The method returns a folder or null if it doesn't exist.
### Extension methods​
#### TryGetFileFromPathAsync​
Attempts to read a file from the file system by its path.
```bash
Task<IStorageFile?> TryGetFileFromPathAsync(this IStorageProvider provider, string filePath);
```
The method returns a file or null if it doesn't exist. This method accepts local file path string as a parameter without any scheme. Only supported on the OS, with physical file paths, primarily only desktop.
#### TryGetFolderFromPathAsync​
Attempts to read a folder from the file system by its path.
```bash
Task<IStorageFolder?> TryGetFolderFromPathAsync(this IStorageProvider provider, string folderPath);
```
The method returns a folder or null if it doesn't exist. This method accepts local folder path string as a parameter without any scheme. Only supported on the OS, with physical file paths, primarily only desktop.
### Platform compatibility:​
`OpenFileBookmarkAsync` `OpenFolderBookmarkAsync` `OpenFilePickerAsync` `SaveFilePickerAsync` `OpenFolderPickerAsync` `TryGetFileFromPathAsync` `TryGetFolderFromPathAsync` `TryGetWellKnownFolderAsync` * Bookmarks are not properly supported on desktop platforms and instead return file path instead. macOS support is planned in order to get it work with Sandboxed Apple Store apps.
** Managed file picker works only on desktop platforms where it's possible to open a custom window.
*** Only Chromium based browsers have a proper support for file pickers.
- PropertiesCanOpenCanSaveCanPickFolder
- CanOpen
- CanSave
- CanPickFolder
- MethodsOpenFilePickerAsyncSaveFilePickerAsyncOpenFolderPickerAsyncOpenFileBookmarkAsyncOpenFolderBookmarkAsyncTryGetFileFromPathAsyncTryGetFolderFromPathAsyncTryGetWellKnownFolderAsync
- OpenFilePickerAsync
- SaveFilePickerAsync
- OpenFolderPickerAsync
- OpenFileBookmarkAsync
- OpenFolderBookmarkAsync
- TryGetFileFromPathAsync
- TryGetFolderFromPathAsync
- TryGetWellKnownFolderAsync
- Extension methodsTryGetFileFromPathAsyncTryGetFolderFromPathAsync
- TryGetFileFromPathAsync
- TryGetFolderFromPathAsync
- Platform compatibility:
- CanOpen
- CanSave
- CanPickFolder
- OpenFilePickerAsync
- SaveFilePickerAsync
- OpenFolderPickerAsync
- OpenFileBookmarkAsync
- OpenFolderBookmarkAsync
- TryGetFileFromPathAsync
- TryGetFolderFromPathAsync
- TryGetWellKnownFolderAsync
- TryGetFileFromPathAsync
- TryGetFolderFromPathAsync
# Storage Items | Avalonia Docs
- Deep Dives
- Services
- Storage Provider
- Storage Items
## Storage Items
### Common members for StorageFile and StorageFolder​
#### Name​
Gets a short name of the item including the file name extension if there is one.
#### Path​
Gets the file-system path of the item.
Android backend might return file path with "content:" scheme. Browser and iOS backends might return relative uris.
DO NOT use Path property to preserve access to the file or folder. Instead see Bookmarks page on how to keep access to the storage items.
DO NOT use Path property to directly read file by its path, as it won't work on most of mobile and browser platforms. Instead use OpenReadAsync and OpenWriteAsync.
#### CanBookmark​
Returns true is item can be bookmarked and reused later.
#### SaveBookmarkAsync​
Saves items to a bookmark. Returns identifier of a bookmark. Can be null if OS denied request.
#### GetBasicPropertiesAsync​
Gets the basic properties of the current item. Currently available properties:
- Size
- DateCreated
- DateModified
#### GetParentAsync​
Gets the parent folder of the current storage item.
#### DeleteAsync​
Deletes the current storage item and it's contents
#### MoveAsync​
Moves the current storage item and it's contents to a IStorageFolder
### StorageFile members​
#### OpenReadAsync​
Opens a stream for read access.
#### OpenWriteAsync​
Opens stream for writing to the file.
### StorageFolder members​
#### GetItemsAsync​
Gets the files and subfolders in the current folder. When this method completes successfully, it returns a list of the files and folders in the current folder. Each item in the list is represented by an IStorageItem implementation object.
This method is lazily evaluate and is async.
#### CreateFileAsync​
Creates a file with specified name as a child of the current storage folder
#### CreateFolderAsync​
Creates a folder with specified name as a child of the current storage folder
### Extension methods​
#### TryGetLocalPath​
Gets the local file system path of the item as a string. Android platform usually uses "content:" virtual file paths and Browser platform has isolated access without full paths, so on these platforms this method will return null.
If you want to save file path to reuse it later (in combination with TryGetFileFromPathAsync), please consider using Bookmarks instead as they are designed to work in sandboxed environment, where user app might not have direct access to the physical file system.
- Common members for StorageFile and StorageFolderNamePathCanBookmarkSaveBookmarkAsyncGetBasicPropertiesAsyncGetParentAsyncDeleteAsyncMoveAsync
- Name
- Path
- CanBookmark
- SaveBookmarkAsync
- GetBasicPropertiesAsync
- GetParentAsync
- DeleteAsync
- MoveAsync
- StorageFile membersOpenReadAsyncOpenWriteAsync
- OpenReadAsync
- OpenWriteAsync
- StorageFolder membersGetItemsAsyncCreateFileAsyncCreateFolderAsync
- GetItemsAsync
- CreateFileAsync
- CreateFolderAsync
- Extension methodsTryGetLocalPath
- TryGetLocalPath
- Name
- Path
- CanBookmark
- SaveBookmarkAsync
- GetBasicPropertiesAsync
- GetParentAsync
- DeleteAsync
- MoveAsync
- OpenReadAsync
- OpenWriteAsync
- GetItemsAsync
- CreateFileAsync
- CreateFolderAsync
- TryGetLocalPath
# Bookmarks | Avalonia Docs
- Deep Dives
- Services
- Storage Provider
- Bookmarks
## Bookmarks
Bookmarks are particularly important for maintaining access to files and folders in modern operating systems that have strict security and privacy controls. For instance, on platforms like iOS and newer versions of macOS, direct file system access is heavily restricted. Instead, applications request the user to select a file or folder through a system-provided file picker, and the operating system then gives the application a security-scoped bookmark that it can use to access that file or folder in the future.
In Avalonia's StorageProvider, these bookmarks are represented as IStorageBookmarkFile and IStorageBookmarkFolder interfaces.
`StorageProvider` `IStorageBookmarkFile` `IStorageBookmarkFolder` To get bookmark ID from the specific folder or file, please use SaveBookmarkAsync async method on storage item. After retrieving bookmark ID, it can be saved in a local database for the further use instead of asking user to pick a folder each time. You can use the OpenFileBookmarkAsync and OpenFolderBookmarkAsync methods to open a bookmarked file or folder using its bookmark ID. This will return the bookmarked file or folder, or null if the operating system denies the request.
`SaveBookmarkAsync` `OpenFileBookmarkAsync` `OpenFolderBookmarkAsync` The exact behavior and capabilities can depend on the specific operating system and its security policies. For instance, on some platforms, a bookmark might become invalid if the user moves or renames the file or folder that it points to.
It's not recommended to store bookmark IDs in a remote database, as bookmarks might not be persistent and might contain sensitive file path information.
# File Picker Options | Avalonia Docs
- Deep Dives
- Services
- Storage Provider
- File Picker Options
## File Picker Options
### Common PickerOptions​
#### Title​
Gets or sets the text that appears in the title bar of a picker.
#### SuggestedStartLocation​
Gets or sets the initial location where the file open picker looks for files to present to the user. Can be obtained from previously picked folder or using StorageProvider.TryGetFolderFromPathAsync or StorageProvider.TryGetWellKnownFolderAsync.
`StorageProvider.TryGetFolderFromPathAsync` `StorageProvider.TryGetWellKnownFolderAsync` This is a suggestion for the system, that can ignore this parameter, if application doesn't have access to the folder or it doesn't exist.
On Linux some DBus file picker don't support start location. For using GTK Free Desktop disable UseDBusFilePicker in X11PlatformOptions
`UseDBusFilePicker` `X11PlatformOptions` ### FilePickerOpenOptions​
#### AllowMultiple​
Gets or sets an option indicating whether open picker allows users to select multiple files.
#### FileTypeFilter​
Gets or sets the collection of file types that the file open picker displays.
To create a list of file types for the file picker:
```bash
//This can also be applied for SaveFilePicker.var files = await _target.StorageProvider.OpenFilePickerAsync(new FilePickerOpenOptions(){ Title = title,//You can add either custom or from the built-in file types. See "Defining custom file types" on how to create a custom one. FileTypeFilter = new[] { ImageAll, FilePickerFileTypes.TextPlain }});
```
### FilePickerSaveOptions​
#### SuggestedFileName​
Gets or sets the file name that the file save picker suggests to the user.
#### DefaultExtension​
Gets or sets the default extension to be used to save the file.
#### FileTypeChoices​
Gets or sets the collection of valid file types that the user can choose to assign to a file.
#### ShowOverwritePrompt​
Gets or sets a value indicating whether file open picker displays a warning if the user specifies the name of a file that already exists.
### FolderPickerOpenOptions​
#### AllowMultiple​
Gets or sets an option indicating whether open picker allows users to select multiple folders.
### Platform compatibility:​
`Title` `SuggestedStartLocation` `AllowMultiple` `FileTypeFilter` `SuggestedFileName` `DefaultExtension` `FileTypeChoices` `ShowOverwritePrompt` ## Defining custom file types
Avalonia has set of built-in file types:
- FilePickerFileTypes.All - all files
- FilePickerFileTypes.TextPlain - txt files
- FilePickerFileTypes.ImageAll - all images
- FilePickerFileTypes.ImageJpg - jpg images
- FilePickerFileTypes.ImagePng - png images
- FilePickerFileTypes.ImageWebP - webp images
- FilePickerFileTypes.Pdf - pdf documents
However it is possible to define custom file types that can be used by the picker.
For instance, the built-in ImageAll type is defined as:
```bash
public static FilePickerFileType ImageAll { get; } = new("All Images"){  Patterns = new[] { "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp", "*.webp" },  AppleUniformTypeIdentifiers = new[] { "public.image" },  MimeTypes = new[] { "image/*" }};
```
Where each file type has the following hints that are used by the different platforms:
- Patterns are used by most Windows, Linux and Browser platforms, and is a basic GLOB patten that can be matched on types.
- AppleUniformTypeIdentifiers is a standard identifier defined by Apple and is used on macOS and iOS platforms. You can find the correct value for a given file in the macOS terminal with mdls -name kMDItemContentType yourfile.ext.
- MimeTypes is a web identifier for the files used on most platforms, but not Windows and iOS.
`Patterns` `AppleUniformTypeIdentifiers` `mdls -name kMDItemContentType yourfile.ext` `MimeTypes` Defining all hints is recommended if the information is known.
If specific hint is not known, don't set random values or "." wildcard, instead keep this collection null. It will tell the platform to ignore this collection and instead try to use another one.
### WebP Inclusion in Options v11.1​
Keep in mind that FilePickerFileTypes.ImageWebP and the addition of "*.webp" to the "All Images" patterns were introduced in version 11.1. You can still create custom file picker types in older versions to incorporate WebP images. For example, to allow only a WebP image to be picked, you can use this:
`FilePickerFileTypes.ImageWebP` ```bash
var customWebPFileType = new FilePickerFileType("Only WebP Images"){  Patterns = new[] { "*.webp" },  AppleUniformTypeIdentifiers = new[] { "org.webmproject.webp" },  MimeTypes = new[] { "image/webp" }};
```
And if you want to include WebP as one of the file types you consider to be an image, you can use the "ImageAll" example shown above.
- Common PickerOptionsTitleSuggestedStartLocation
- Title
- SuggestedStartLocation
- FilePickerOpenOptionsAllowMultipleFileTypeFilter
- AllowMultiple
- FileTypeFilter
- FilePickerSaveOptionsSuggestedFileNameDefaultExtensionFileTypeChoicesShowOverwritePrompt
- SuggestedFileName
- DefaultExtension
- FileTypeChoices
- ShowOverwritePrompt
- FolderPickerOpenOptionsAllowMultiple
- AllowMultiple
- Platform compatibility:
- WebP Inclusion in Options
- Title
- SuggestedStartLocation
- AllowMultiple
- FileTypeFilter
- SuggestedFileName
- DefaultExtension
- FileTypeChoices
- ShowOverwritePrompt
- AllowMultiple
# Image Interpolation | Avalonia Docs
- Deep Dives
- Image Interpolation
## Image Interpolation
When displaying images in Avalonia, particularly when scaling them to sizes different from their native resolution, the quality of the rendering depends on the interpolation mode being used. This guide explains how to control image interpolation in your Avalonia applications.
### Default Behavior​
As of Avalonia 11, the default interpolation mode is set to LowQuality. This setting prioritizes performance but may result in less smooth image rendering when scaling images, particularly when displaying them at sizes significantly smaller than their original dimensions.
`LowQuality` ### Interpolation Modes​
Avalonia supports several bitmap interpolation modes that can be applied to image rendering:
- None: No interpolation
- LowQuality: Basic interpolation (default)
- MediumQuality: Balanced interpolation
- HighQuality: Smooth interpolation, best for downsizing images
`None` `LowQuality` `MediumQuality` `HighQuality` ### Setting the Interpolation Mode​
#### Per-Control Setting​
You can set the interpolation mode on individual controls using the RenderOptions.BitmapInterpolationMode attached property:
`RenderOptions.BitmapInterpolationMode` ```bash
<Image Source="assets/myimage.png"    RenderOptions.BitmapInterpolationMode="HighQuality" />
```
This can also be applied to containers:
```bash
<Border RenderOptions.BitmapInterpolationMode="HighQuality">  <Image Source="assets/myimage.png" /></Border>
```
#### Common Use Cases​
- Icon Display: When displaying icons that are being scaled down, using HighQuality interpolation can prevent jagged edges:
`HighQuality` ```bash
<Button>  <Image Source="assets/icon.png"      Width="16"      Height="16"      RenderOptions.BitmapInterpolationMode="HighQuality" /></Button>
```
- Image Galleries: For image galleries where quality is important:
```bash
<ItemsControl RenderOptions.BitmapInterpolationMode="HighQuality">  <ItemsControl.ItemTemplate>    <DataTemplate>      <Image Source="{Binding ImagePath}" />    </DataTemplate>  </ItemsControl.ItemTemplate></ItemsControl>
```
### Performance Considerations​
The interpolation mode is set per-control by design for performance reasons. Higher quality interpolation requires more computational resources, so consider these guidelines:
- Use HighQuality for: Important UI elements like logos Scaled-down images where quality is crucial Photo galleries or image-focused interfaces
- Important UI elements like logos
- Scaled-down images where quality is crucial
- Photo galleries or image-focused interfaces
- Use default LowQuality for: Background images Decorative elements where quality is less critical Performance-sensitive applications
- Background images
- Decorative elements where quality is less critical
- Performance-sensitive applications
`HighQuality` - Important UI elements like logos
- Scaled-down images where quality is crucial
- Photo galleries or image-focused interfaces
`LowQuality` - Background images
- Decorative elements where quality is less critical
- Performance-sensitive applications
### Creating a Global Setting​
While Avalonia doesn't provide a built-in way to set a global interpolation mode, you can create a custom attached property or behavior to manage this across your application. Here's an example approach:
```bash
public static class GlobalImageOptions{  public static readonly AttachedProperty<BitmapInterpolationMode> InterpolationModeProperty =    AvaloniaProperty.RegisterAttached<Image, BitmapInterpolationMode>(      "InterpolationMode",      typeof(GlobalImageOptions),      defaultValue: BitmapInterpolationMode.HighQuality);  public static void SetInterpolationMode(Image image, BitmapInterpolationMode value)  {    image.SetValue(RenderOptions.BitmapInterpolationModeProperty, value);  }}
```
Then in your XAML:
```bash
<Style Selector="Image">  <Setter Property="(local:GlobalImageOptions.InterpolationMode)"      Value="HighQuality" /></Style>
```
### Tips for Best Results​
- Asset Preparation: Provide images at appropriate resolutions for their intended display size Consider including multiple resolutions for important assets Use vector formats (SVG) when possible for resolution-independent graphics
- Provide images at appropriate resolutions for their intended display size
- Consider including multiple resolutions for important assets
- Use vector formats (SVG) when possible for resolution-independent graphics
- Layout Considerations: Be mindful of the original image dimensions versus display size Use appropriate containers and layout panels to manage image scaling Consider using UniformToFill or Uniform stretch modes with high-quality interpolation
- Be mindful of the original image dimensions versus display size
- Use appropriate containers and layout panels to manage image scaling
- Consider using UniformToFill or Uniform stretch modes with high-quality interpolation
- Testing: Test image rendering on different screen densities Verify performance impact when using high-quality interpolation on many images Check memory usage with different interpolation settings
- Test image rendering on different screen densities
- Verify performance impact when using high-quality interpolation on many images
- Check memory usage with different interpolation settings
Asset Preparation:
- Provide images at appropriate resolutions for their intended display size
- Consider including multiple resolutions for important assets
- Use vector formats (SVG) when possible for resolution-independent graphics
Layout Considerations:
- Be mindful of the original image dimensions versus display size
- Use appropriate containers and layout panels to manage image scaling
- Consider using UniformToFill or Uniform stretch modes with high-quality interpolation
`UniformToFill` `Uniform` Testing:
- Test image rendering on different screen densities
- Verify performance impact when using high-quality interpolation on many images
- Check memory usage with different interpolation settings
- Default Behavior
- Interpolation Modes
- Setting the Interpolation ModePer-Control SettingCommon Use Cases
- Per-Control Setting
- Common Use Cases
- Performance Considerations
- Creating a Global Setting
- Tips for Best Results
- Per-Control Setting
- Common Use Cases
# Bitmap Blend Modes | Avalonia Docs
- Deep Dives
- Bitmap Blend Modes
## Bitmap Blend Modes
When rendering bitmaps graphics on screen, Avalonia supports specifying what blend mode to use while rendering. Blend modes changes the calculations performed when drawing new pixels (source) over existing pixels (destination).
Currently Avalonia Composite modes and Pixel Blend modes are located in a single enum called BitmapBlendingMode.
`BitmapBlendingMode` Composite modes enums mainly describes how the new pixels interact with the current on-screen pixels according to the alpha channel, this can be used to create, for example: "cookie cutters", exclusion zones or masks.
Pixel Blend modes on the other hand, specifies how the new colors will interact with the current colors. These modes can be used for example: on special effects, change color hues or other more complex image compositions.
See the Wikipedia page on blend modes for examples of how they work and the math behind them.
Currently Avalonia only supports Blend Modes when using the Skia renderer. Trying to use these modes with the D2D renderer will result in the same behavior as the default mode.
### Default Behavior​
The default blend mode is SourceOver, meaning replacing all pixels values by the new values, dictated by the alpha channel. This is the standard way most applications overlay two images.
`SourceOver` ### How to use it​
In XAML, you can specify what blend mode to use when rendering a Image control. The following example will render a color overlay over the picture of a very cute cat:
```bash
<Panel>  <Image Source="./Cat.jpg"/>  <Image Source="./Overlay-Color.png" BlendMode="Multiply"/></Panel>
```
If you're creating a Custom User control and want to render a bitmap with code using one of these modes, you can do so by setting the BitmapBlendingMode in the control context render options:
`BitmapBlendingMode` ```bash
// Inside the "Render" method, draw the bitmap like this:using (context.PushRenderOptions(RenderOptions with { BitmapBlendingMode = BitmapBlendingMode.Multiply })){  context.DrawImage(source, sourceRect, destRect);}
```
### Bitmap Blend Mode Gallery​
Avalonia supports several bitmap blend modes that can be applied to rendering:
#### Pixel Blend Modes​
Pixel blend modes affect only the color without taking into consideration the alpha channel.
These are the images used in the examples:
![](https://docs.avaloniaui.net/assets/images/Cat-44eeead5cc60794cd0b55449ae5e29d9.jpg)
![](https://docs.avaloniaui.net/assets/images/Overlay-Color-28c8dc6fcaa34cb9947b9412919fc2ff.png)
Below are all the values currently supported by Avalonia
![](https://docs.avaloniaui.net/assets/images/Nothing-c8d59555a6a91099b248b335db723a17.png)
`Unspecified` `SourceOver` ![](https://docs.avaloniaui.net/assets/images/Plus-12f45bb07dfd844dc3917e0624b8c773.png)
`Plus` ![](https://docs.avaloniaui.net/assets/images/Screen-891115109aee5fe85e5b362a191fb624.png)
`Screen` ![](https://docs.avaloniaui.net/assets/images/Overlay-2d7a92f166c2e32b3e07b06c19761b9e.png)
`Overlay` ![](https://docs.avaloniaui.net/assets/images/Darken-bed7b699959e87b0180cb606e019716a.png)
`Darken` ![](https://docs.avaloniaui.net/assets/images/Lighten-459a5c910abb1841a598a297c4b04fdd.png)
`Lighten` ![](https://docs.avaloniaui.net/assets/images/ColorDodge-58570d85b49adb9f962db7bda78774e3.png)
`ColorDodge` ![](https://docs.avaloniaui.net/assets/images/ColorBurn-a497ef531684d9db655deca731ef545a.png)
`ColorBurn` ![](https://docs.avaloniaui.net/assets/images/HardLight-f5f96a4c94a38dba0a946bafc7831ced.png)
`HardLight` ![](https://docs.avaloniaui.net/assets/images/SoftLight-c7dfa829e985568754f4eb1f8d47f93a.png)
`SoftLight` ![](https://docs.avaloniaui.net/assets/images/Difference-29088ea519868fb765ba3982c14d6fdd.png)
`Difference` ![](https://docs.avaloniaui.net/assets/images/Exclusion-d694725bd89a730a09b44073e1553a6f.png)
`Exclusion` ![](https://docs.avaloniaui.net/assets/images/Multiply-967632c7e6504c50d2a36ad753911449.png)
`Multiply` ![](https://docs.avaloniaui.net/assets/images/Hue-300c62fa32d85de9afbca7e48147b052.png)
`Hue` ![](https://docs.avaloniaui.net/assets/images/Saturation-75970c235393d1f2bf7dfbcd75d9b51f.png)
`Saturation` ![](https://docs.avaloniaui.net/assets/images/Color-05149add0a03f9894d42a072cdcf65ac.png)
`Color` ![](https://docs.avaloniaui.net/assets/images/Luminosity-39e5659ddc1e269a42f66e212673065c.png)
`Luminosity` #### Composition Blend modes​
Composition blend modes affect only the alpha channel without messing with the colors.
These are the images used in the examples:
Below are all the values currently supported by Avalonia. Please note that this demo is sensitive to the alpha channel and therefore the website background bleed through the images.
`Source` `SourceOver` `Unspecified` `SourceIn` `SourceOut` `SourceAtop` `Xor` `Destination` `DestinationOver` `DestinationIn` `DestinationOut` `DestinationAtop` - Default Behavior
- How to use it
- Bitmap Blend Mode GalleryPixel Blend ModesComposition Blend modes
- Pixel Blend Modes
- Composition Blend modes
- Pixel Blend Modes
- Composition Blend modes
# Templated Controls | Avalonia Docs
- Deep Dives
- Templated Controls
## Templated Controls
TemplatedControls are best used for generic controls that can be shared among various applications. They are lookless controls, meaning that they can be restyled for different themes and applications. The majority of standard controls defined by Avalonia fit into this category.
`TemplatedControl` If you want to provide a Style for your TemplatedControl in a separate file, remember to include this file in your Application via StyleInclude.
`Style` `TemplatedControl` `StyleInclude`
# Styles | Avalonia Docs
- Basics
- User Interface
- Styling
- Styles
## Styles
The Avalonia UI style system is a mechanism that can share property settings between controls.
A Style in Avalonia is more similar to a CSS style than a WPF/UWP style. The equivalent of a WPF/UWP Style in Avalonia is a ControlTheme.
`Style` `ControlTheme` ### How It Works​
In essence, the styling mechanism has two steps: selection and substitution. The XAML for the style can define how both of these steps are to be done, but often you will help the selection step by defining 'class' labels on control elements.
The Avalonia UI styling system's use of 'class' labels on control elements is analogous to how CSS (cascading style sheets) work with HTML elements.
The styling system implements cascading styles by searching the logical tree upwards from a control, during the selection step. This means styles defined at the highest level of the application (the App.axaml file) can be used anywhere in an application, but may still be overridden closer to a control (for example in a window, or user control).
`App.axaml` When a match is located by the selection step, then the matched control's properties are altered according to the setters in the style.
### How it is Written​
The XAML for a style has two parts: a selector attribute, and one or more setter elements. The selector value contains a string that uses the Avalonia UI style selector syntax. Each setter element identifies the property that will be changed by name, and the new value that will be substituted. The pattern is like this:
```bash
<Style Selector="selector syntax">   <Setter Property="property name" Value="new value"/>   ...</Style>
```
The Avalonia UI style selector syntax is analogous to that used by CSS (cascading style sheets). For detailed reference information, see here.
### Example​
This is an example of how a style is written and applied to a control element, with a style class to help selection:
```bash
<Window ... >  <Window.Styles>    <Style Selector="TextBlock.h1">      <Setter Property="FontSize" Value="24"/>      <Setter Property="FontWeight" Value="Bold"/>    </Style>  </Window.Styles>  <StackPanel Margin="20">    <TextBlock Classes="h1">Heading 1</TextBlock>  </StackPanel></Window>
```
In this example, all TextBlock elements with the h1 style class will be displayed with the font size and weight set by the style. This works in the preview pane:
`TextBlock` `h1` ### Where to put Styles​
Styles are placed inside a Styles collection element on a Control or on the Application. For example, a window styles collection looks like this:
`Styles` `Control` `Application` ```bash
<Window.Styles>  <Style> ... </Style></Window.Styles>
```
The location of a styles collection defines the scope of the styles it contains. In the above example, the styles will apply to the window and all of its contents. If a style is added to the Application then it will apply globally.
`Application` ### The Selector​
The style selector defines what controls the style will act upon. The selector uses a variety of formats, one of the simplest is this:
```bash
<Style Selector="TargetControlClass.styleClassName">
```
This selector will match all controls with a style key of TargetControlClass, having a style class of styleClassName.
`TargetControlClass` `styleClassName` A full list of selectors can be found here.
### Setters​
Setters describe what will happen when the selector matches a control. They are simple property/value pairs written in the format:
```bash
<Setter Property="FontSize" Value="24"/><Setter Property="Padding" Value="4 2 0 4"/>
```
Whenever a style is matched with a control, all of the setters within the style will be applied to the control.
For more information on setters see here.
### Nested Styles​
Styles can be nested in other styles. To nest a style, simply include the child style as a child of the parent <Style> element, and start the selector with the Nesting Selector (^):
`<Style>` `Nesting Selector (^)` ```bash
<Style Selector="TextBlock.h1">  <Setter Property="FontSize" Value="24"/>  <Setter Property="FontWeight" Value="Bold"/>    <Style Selector="^:pointerover">    <Setter Property="Foreground" Value="Red"/>  </Style></Style>
```
When this happens, the selector from the parent style will automatically apply to the child style. In the above example the nested style will effectively have a selector of TextBlock.h1:pointerover, meaning that it will display with a red foreground when the pointer is over the control.
`TextBlock.h1:pointerover` The nesting selector must be present and must appear at the start of the child selector.
### Style Key​
The type of an object matched by a style selector is not determined by the concrete type of the control, but rather by examining its StyleKey property.
`StyleKey` By default, the StyleKey property returns the type of the current instance. However, if you want your control, which inherits from Button, to be styled as a Button, you can override the StyleKeyOverride property in your class and have it return typeof(Button).
`StyleKey` `StyleKeyOverride` `typeof(Button)` ```bash
public class MyButton : Button{  // `MyButton` will be styled as a standard `Button` control.  protected override Type StyleKeyOverride => typeof(Button);}
```
Note this this logic is inverted as compared with WPF/UWP: in those frameworks, when you derive a new control it will be styled as its base control unless you override the DefaultStyleKey property. In Avalonia the control will be styled using its concrete type unless a different style key is provided.
`DefaultStyleKey` Before Avalonia 11, the style key was overridden by implementing IStyleable and providing a new implementation of the IStyleable.StyleKey property. This mechanism is still supported in Avalonia 11 for compatibility, but may be removed in a future version.
`IStyleable` `IStyleable.StyleKey` ### Styles and Resources​
Resources are often used with styles to help maintain consistent presentation. Resources can help define standard colors and icons in an application; or across multiple applications when included from separate files.
For guidance on how to use resources in you application, see here.
### Further Information​
For guidance on how to share styles by including a styles file, see here.
- How It Works
- How it is Written
- Example
- Where to put Styles
- The Selector
- Setters
- Nested Styles
- Style Key
- Styles and Resources
- Further Information
# Styling | Avalonia Docs
- Basics
- User Interface
- Styling
## Styling
Avalonia provides two primary mechanisms for styling controls:
### Styles​
- Styles are similar to CSS styles and are usually used to style controls based on their content or purpose within the application; for example creating a style for header text blocks.
### Control themes​
- Control Themes are similar to WPF/UWP styles and are usually used to apply a theme to controls.
- Styles
- Control themes
# Control Themes | Avalonia Docs
- Basics
- User Interface
- Styling
- Control Themes
## Control Themes
Control themes build upon Styles to create switchable themes for controls. Control themes are analogous to Styles in WPF/UWP, though their mechanism is slightly different.
Because control themes are based on styles, it is important to understand the Avalonia styling system first.
### Introduction​
Before Avalonia 11, control themes were created using standard styles. However, this approach had a fundamental problem: once a style was applied to a control, there was no way to remove it. Consequently, if you wanted to change the theme for a specific instance of a control or a section of the user interface (UI), the only option was to apply a second theme to the control and hope that it would override all the properties set in the original theme.
The solution for this was introduced in Avalonia 11 in the form of Control Themes.
Control themes are themselves styles, but with some important differences:
- Control themes don't have a selector: instead they have a TargetType property which describes the control that they target
- Control themes are stored in a ResourceDictionary instead of a Styles collection
- Control themes are assigned to a control by setting the Theme property, usually using the {StaticResource} markup extension
`TargetType` `ResourceDictionary` `Styles` `Theme` `{StaticResource}` Control themes are typically applied to templated (lookless) controls, but they can actually be applied to any control. However, for non-templated controls, it is often more convenient to use standard styles instead.
### Example: Round Button​
The following example shows a simple Button theme which displays a button with an ellipse background with a 90's Geocities aesthetic:
`Button` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"> <Application.Styles>  <FluentTheme /> </Application.Styles> <Application.Resources>  <ControlTheme x:Key="EllipseButton" TargetType="Button">   <Setter Property="Background" Value="Blue"/>   <Setter Property="Foreground" Value="Yellow"/>   <Setter Property="Padding" Value="8"/>   <Setter Property="Template">    <ControlTemplate>     <Panel>      <Ellipse Fill="{TemplateBinding Background}"           HorizontalAlignment="Stretch"           VerticalAlignment="Stretch"/>      <ContentPresenter x:Name="PART_ContentPresenter"               Content="{TemplateBinding Content}"               Margin="{TemplateBinding Padding}"/>     </Panel>    </ControlTemplate>   </Setter>  </ControlTheme> </Application.Resources></Application>
```
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml'    x:Class="Sandbox.MainWindow"> <Button Theme="{StaticResource EllipseButton}"     HorizontalAlignment="Center"     VerticalAlignment="Center">  Hello World! </Button></Window>
```
### Interaction in Control Themes​
Like standard styles, control themes support nested styles which can be used to add interactions such as pointer-over and pressed states.
### Example: Round Button Hover State​
Using nested styles we can make our button change color when the pointer is hovered over it:
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"> <Application.Styles>  <FluentTheme /> </Application.Styles> <Application.Resources>  <ControlTheme x:Key="EllipseButton" TargetType="Button">   <Setter Property="Background" Value="Blue"/>   <Setter Property="Foreground" Value="Yellow"/>   <Setter Property="Padding" Value="8"/>   <Setter Property="Template">    <ControlTemplate>     <Panel>      <Ellipse Fill="{TemplateBinding Background}"           HorizontalAlignment="Stretch"           VerticalAlignment="Stretch"/>      <ContentPresenter x:Name="PART_ContentPresenter"               Content="{TemplateBinding Content}"               Margin="{TemplateBinding Padding}"/>     </Panel>    </ControlTemplate>   </Setter>      <Style Selector="^:pointerover">    <Setter Property="Background" Value="Red"/>    <Setter Property="Foreground" Value="White"/>   </Style>  </ControlTheme> </Application.Resources></Application>
```
### Control Theme Lookup​
There a two ways in which a control theme can be found:
- If the control's Theme property is set, then that control theme will be used; otherwise
- Avalonia will search the upwards through the logical tree for a ControlTheme resource with an x:Key which matches the control's style key
`Theme` `ControlTheme` `x:Key` If you're having trouble getting Avalonia to find your theme, make sure it's returning a style key which matches the x:Key and TargetType of your control theme
`x:Key` `TargetType` In effect this means that you have two choices for how to define your control theme:
- If you want the control theme to apply to all instances of the control then use an {x:Type} as the resource key. For example <ControlTheme x:Key="{x:Type Button}" TargetType="Button">
- If you want the control theme to be applied to selected instances of the control then use anything else as the resource key and look up this resource using {StaticResource}. Commonly this key will be a string
`{x:Type}` `<ControlTheme x:Key="{x:Type Button}" TargetType="Button">` `{StaticResource}` `string` Notice that this means that only a single control theme can be applied to a control at any one time.
### Example: Make all the Buttons Round​
We can apply our new control theme to all of the buttons in the application by simply changing the x:Key of the control theme to match the Button type.
`x:Key` `Button` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"> <Application.Styles>  <FluentTheme /> </Application.Styles> <Application.Resources>  <ControlTheme x:Key="{x:Type Button}" TargetType="Button">   <Setter Property="Background" Value="Blue"/>   <Setter Property="Foreground" Value="Yellow"/>   <Setter Property="Padding" Value="8"/>   <Setter Property="Template">    <ControlTemplate>     <Panel>      <Ellipse Fill="{TemplateBinding Background}"           HorizontalAlignment="Stretch"           VerticalAlignment="Stretch"/>      <ContentPresenter x:Name="PART_ContentPresenter"               Content="{TemplateBinding Content}"               Margin="{TemplateBinding Padding}"/>     </Panel>    </ControlTemplate>   </Setter>      <Style Selector="^:pointerover">    <Setter Property="Background" Value="Red"/>    <Setter Property="Foreground" Value="White"/>   </Style>  </ControlTheme> </Application.Resources></Application>
```
### TargetType​
The ControlTheme.TargetType property specifies the type to which setter properties apply. If you don't specify a TargetType, you must qualify the properties in your Setter objects with a class name by using the syntax Property="ClassName.Property". For example, instead of setting Property="FontSize", you must set Property to TextBlock.FontSize or Control.FontSize.
`ControlTheme.TargetType` `TargetType` `Property="ClassName.Property"` `TextBlock.FontSize` `Control.FontSize` ### Additional Resources​
- The ButtonCustomize sample has an WinClassicButtonTheme
- You can see the control themes for the built-in Avalonia controls here: Simple Theme Fluent Theme
- Simple Theme
- Fluent Theme
`WinClassicButtonTheme` - Simple Theme
- Fluent Theme
- Introduction
- Example: Round Button
- Interaction in Control Themes
- Example: Round Button Hover State
- Control Theme Lookup
- Example: Make all the Buttons Round
- TargetType
- Additional Resources
# Choosing A Custom Control Type | Avalonia Docs
- Basics
- User Interface
- Controls
- Creating Controls
- Choosing A Custom Control Type
## Choosing A Custom Control Type
Avalonia provides various approaches for creating custom controls to meet your application's specific needs. Understanding the different types of custom controls will help you choose the most appropriate approach for your requirements. In Avalonia, the three common types of custom controls are UserControls`, lookless controls, and custom-drawn controls.
### UserControl​
A UserControl is a high-level approach for creating custom controls in Avalonia. It allows you to compose a control by combining existing controls and defining the layout using XAML. A UserControl acts as a container that encapsulates multiple controls and provides a cohesive user interface.
`UserControl` `UserControl` Typically, UserControls are used to represent specialized views within an application, such as a "User Details View," rather than serving as general-purpose user interface elements.
`UserControls` Creating a UserControl involves the following steps:
`UserControl` - Define the XAML: Create a new UserControl XAML file that defines the layout and appearance of the control by placing controls, setting properties, and applying styles.
- Code-behind: Optionally, you can define additional code-behind logic to handle events, modify the behavior, or provide additional functionality to the UserControl.
- Reuse and Customization: UserControls can be easily reused and customized within an application. They are especially useful when you want to encapsulate a specific set of controls and behaviors into a reusable component or "view".
Define the XAML: Create a new UserControl XAML file that defines the layout and appearance of the control by placing controls, setting properties, and applying styles.
`UserControl` Code-behind: Optionally, you can define additional code-behind logic to handle events, modify the behavior, or provide additional functionality to the UserControl.
`UserControl` Reuse and Customization: UserControls can be easily reused and customized within an application. They are especially useful when you want to encapsulate a specific set of controls and behaviors into a reusable component or "view".
`UserControl` ### Templated (Lookless) Controls​
Templated controls (also known as "Lookless controls") provide a more advanced and customizable approach for creating custom controls in Avalonia. A templated control separates the control's behavior and logic from its visual appearance, allowing the control to be styled and templated by the application developer.
With templated controls, you define the control's behavior and properties in a code-behind class, while the visual representation is specified through control templates defined in XAML. This separation allows the application developer to customize the look and feel of the control without modifying its underlying behavior.
Templated controls are typically used for general-purpose user-interface elements that are not specific to business logic and may require different themes or visual styles. Most of the built-in controls supplied by Avalonia are templated controls.
Creating a templated control involves the following steps:
- Define the Control Class: Create a new class that derives from TemplatedControl. This class defines the behavior, properties, and events of the control.
- Control Template: Create a ControlTheme in XAML that specifies the visual appearance and structure of the control. The control template defines the parts of the control and how they should be styled.
- Styling and Templating: The application developer can customize the look of the control by modifying its control template or applying styles. This allows for a consistent and unified visual design across the application.
Define the Control Class: Create a new class that derives from TemplatedControl. This class defines the behavior, properties, and events of the control.
`TemplatedControl` Control Template: Create a ControlTheme in XAML that specifies the visual appearance and structure of the control. The control template defines the parts of the control and how they should be styled.
`ControlTheme` Styling and Templating: The application developer can customize the look of the control by modifying its control template or applying styles. This allows for a consistent and unified visual design across the application.
Templated controls provide greater flexibility and reusability, making them ideal for scenarios where you want to provide a control that can be styled to match different visual themes or adapt to various user preferences.
### Custom-drawn Controls​
Custom-drawn controls offer the highest level of customization in Avalonia. With custom-drawn controls, you have complete control over the rendering of the control's visual elements, allowing you to create unique and complex visual representations.
Custom-drawn controls are typically used where the control represents a mostly non-interactive graphical element that will not need to be themed.
To create a custom-drawn control, you override the control's Render method and use low-level drawing APIs, such as DrawingContext, to define the control's appearance. This approach provides fine-grained control over every pixel of the control's visual representation.
`Render` `DrawingContext` Creating a custom-drawn control involves the following steps:
- Define the Control Class: Create a new class that derives from Control. This class will define the behavior and rendering logic of the control.
- Override the Render Method: Override the Render method in the control class and use the DrawingContext to draw the control's content.
Define the Control Class: Create a new class that derives from Control. This class will define the behavior and rendering logic of the control.
`Control` Override the Render Method: Override the Render method in the control class and use the DrawingContext to draw the control's content.
`Render` `DrawingContext` - UserControl
- Templated (Lookless) Controls
- Custom-drawn Controls
# Controls | Avalonia Docs
- Basics
- User Interface
- Controls
## Controls
Controls in Avalonia UI are fundamental building blocks used to create user interfaces. They represent various interactive elements such as buttons, text boxes, sliders, and more. Understanding controls is essential for developing applications using Avalonia UI.
### What are Controls?​
Controls are UI elements that allow users to interact with an application. They provide functionality for input, display, and manipulation of data. Controls can be categorized into several types based on their purpose and behavior.
- Buttons: Buttons are commonly used for triggering actions when clicked or tapped. They can have text, icons, or both, and are often used for tasks like submitting forms, opening dialogs, or executing commands.
- TextBoxes: Text boxes allow users to enter and edit text. They are used for capturing user input, such as usernames, passwords, or any form of textual information. Text boxes can also be customized for specific input patterns and validation.
- Labels: Labels are used to display static text or captions for other controls. They provide additional information or context to the user and are generally non-interactive.
- Checkboxes and RadioButtons: Checkboxes and radio buttons are used for selection and multiple-choice options. Checkboxes allow users to select one or more options, while radio buttons enable users to choose a single option from a group.
- Sliders: Sliders are used to select a value from a range. They provide a visual representation of a value that can be adjusted by dragging a handle along a track. Sliders are commonly used for settings such as volume controls or image adjustments.
- ListBoxes and ComboBoxes: ListBoxes and combo boxes allow users to select an item from a list or a dropdown menu. ListBoxes display multiple items at once, while ComboBoxes show a single item initially and expand to display a list when clicked.
These are just a few examples of the many controls available in Avalonia UI. Each control has its own set of properties, methods, and events, allowing developers to customize their appearance and behavior to suit their application's needs.
### Getting Started with Builtin Controls​
To get started with using controls in Avalonia UI, you can refer to the documentation for each control type. The documentation provides detailed explanations, examples, and code snippets to help you understand and utilize the controls effectively.
- Button Control Documentation
- TextBox Control Documentation
- Label Control Documentation
- Checkbox Control Documentation
- Slider Control Documentation
- ListBox Control Documentation
By exploring these resources, you'll gain a solid foundation in using controls within Avalonia UI and be able to create rich and interactive user interfaces for your applications.
### Types of Builtin Controls​
Avalonia UI's builtin controls can be loosely classified into the below types:
- Drawn Controls
- Layout Controls
- User Controls*
- Templated Controls Fully Customizable Partially Customizable
- Fully Customizable
- Partially Customizable
- Fully Customizable
- Partially Customizable
*User controls are only available for apps.
These classifications are somewhat related to the discussion in Choosing A Custom Control Type.
#### Drawn Controls​
Drawn controls are those that are responsible for generating their own geometry or bitmaps and rendering themselves. Examples of these controls include Border, TextBlock and Image. Drawn controls are the foundational controls used to construct everything else.
`Border` `TextBlock` `Image` Most drawn controls have standard properties that can be used to adjust their appearance and size but they do not allow re-templating. This means as an app developer you can’t change the functionality or style of these controls without dropping into C#, deriving a new version of the control and intercepting the rendering methods.
#### Layout Controls​
Layout controls are special in that they have no appearance by themselves. Layout controls like Grid, StackPanel and others are responsible for defining the layout of their children and behave as a parent container. The child controls are responsible for rendering the UI while the layout parent control simply sets size and position (which have no appearance by themselves).
`Grid` `StackPanel` It is not very common for app developers to modify framework provided layout controls.
Some layout controls like Grid have properties such as Background to simplify common use cases. Using these properties does give some appearance to these controls.
`Grid` `Background` ### User Controls​
Avalonia UI never provides UserControls by itself as these are not considered general-purpose. For more information on creating and using UserControls in your app see Choosing A Custom Control Type.
`UserControl` `UserControl` #### Templated Controls​
Most standard controls in Avalonia UI are templated controls which means their visual appearance is defined in a XAML control template separated from functionality. It is the foundation for the concept of lookless controls that originated in WPF.
Application developers can change the XAML template of a templated control and make it appear completely differently. This functionality is not available in all UI frameworks and is one of the most powerful features of XAML-based UI frameworks.
Re-templating controls is a last-resort for app developers. It also means you will be responsible for keeping the template updated with any changes upstream. Instead, it is better to:
- Attempt to use existing properties to customize the control
- Create a new style with Avalonia UI's extremely powerful style selectors to modify what you need in the existing template
- As a last resort, re-template
##### Fully Customizable​
The majority of templated controls in Avalonia UI are fully customizable. This means it is possible to completely replace the control’s template and change its appearance. The Button control is a good example but all templated controls in Avalonia UI try to be fully customizable by default. With a fully customizable templated control the app has near total ability to style or change everything you see drawn in the UI.
`Button` ##### Partially Customizable​
In practice, having fully replaceable control templates is not always possible. There is a spectrum in control design between supporting common use-cases easily and making the control fully re-templatable. For high-complexity controls like the DataGrid the spectrum shifts towards supporting the intended use cases and the control cannot, and should not, be fully re-templated. These controls also usually have a very high number of template parts (required control elements that are used directly by the C# implementation of the control).
`DataGrid` In the case of a DataGrid it is still possible to re-template individual components or parts of the control. It is just extremely difficult to completely change how it looks and functions.
`DataGrid` Partially customizable templated controls on the order of DataGrid are rare as first-party controls provided by the framework itself.
`DataGrid` ### Creating Controls​
In Avalonia, you have the flexibility to create custom controls of all types tailored to your application's specific requirements. See the Creating Controls section for more information
- What are Controls?
- Getting Started with Builtin Controls
- Types of Builtin ControlsDrawn ControlsLayout Controls
- Drawn Controls
- Layout Controls
- User ControlsTemplated Controls
- Templated Controls
- Creating Controls
- Drawn Controls
- Layout Controls
- Templated Controls
# Button | Avalonia Docs
- Reference
- Controls Reference
- Button Controls
- Button
## Button
The button is a control that reacts to pointer actions (and has some keyboard equivalents). It presents visual feedback in the form of a depressed state when the pointer is down.
A pointer-down to pointer release sequence is interpreted as a click; and this behaviour is configurable.
When determining if a button is pressed by the user, always use the Click event instead of PointerPressed. Click is the high-level event specific to a Button that indicates it has been pressed.
`Click` `PointerPressed` `Click` `Button` PointerPressed is more a low-level input event: one that the Button needs to handle internally to raise the Click event. Since Button handles PointerPressed (sets IsHandled to true), applications will never receive this event as in some other controls.
`PointerPressed` `Button` `Click` `Button` `PointerPressed` `IsHandled` Click is one of many button events, for a full list see here.
A button can raise a click event in the code-behind. Alternatively you can bind an instance of ICommand to the command property. The bound command will then be executed whenever the button is clicked.
`ICommand` For guidance on how to bind to a command, see here.
### Useful Properties​
You will probably use these properties most often:
`ClickMode` `Command` `ICommand` ### Example​
This example shows a simple button and a C# code-behind click event handler.
```bash
<StackPanel Margin="20"> <Button Click="ClickHandler">Press Me!</Button> <TextBlock Margin="0 10" x:Name="message">Ready...</TextBlock></StackPanel>
```
```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();  }  public void ClickHandler(object sender, RoutedEventArgs args)  {    message.Text = "Button clicked!";  }}
```
![](https://docs.avaloniaui.net/assets/images/button-click-f878fc8349bc666ba471d42150139251.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Button.cs
`Button.cs` - Useful Properties
- Example
- More Information
# Reference | Avalonia Docs
- Reference
## Reference
# Animation Settings | Avalonia Docs
- Reference
- Animation Settings
## Animation Settings
This section describes how Animation playback can be customized.
`Animation` ### Easing Functions​
Easing functions describe how quickly an animated property changes from its starting value into its ending value across the animation time. Avalonia.Animation.Easings contains the following easings:
`Easing` `Avalonia.Animation.Easings` `LinearEasing` `SineEaseIn` `SineEaseOut` `SineEaseInOut` `QuadraticEaseIn` `QuadraticEaseOut` `QuadraticEaseInOut` `CubicEaseIn` `CubicEaseOut` `CubicEaseInOut` `QuarticEaseIn` `QuarticEaseOut` `QuarticEaseInOut` `QuinticEaseIn` `QuinticEaseOut` `QuinticEaseInOut` `ExponentialEaseIn` `ExponentialEaseOut` `ExponentialEaseInOut` `CircularEaseIn` `CircularEaseOut` `CircularEaseInOut` `BackEaseIn` `BackEaseOut` `BackEaseInOut` `ElasticEaseIn` `ElasticEaseOut` `ElasticEaseInOut` `BounceEaseIn` `BounceEaseOut` `BounceEaseInOut` Additionally, you can provide your own easing by deriving from Easing or by providing parameters to SplineEasing or SpringEasing.
`Easing` `SplineEasing` `SpringEasing` ### FillModes​
The FillMode attribute of an Animation defines how the animated property persists after an animation completes and during delays in-between runs.
`FillMode` `Animation` The following table describes the supported behaviors:
`None` `Forward` `Backward` `Both` `Forward` `Backward` ### PlaybackDirection​
PlaybackDirection defines how the Animation will be played. The following table describes the possible settings:
`PlaybackDirection` `Animation` `Normal` `Reverse` `Alternate` `AlternateReverse` ### IterationCount​
The IterationCount on an Animation element sets how many times it is to be replayed. There are two formats for this setting:
`IterationCount` `Animation` `N` `Infinite` - Easing Functions
- FillModes
- PlaybackDirection
- IterationCount
# Built-in Data Binding Converters | Avalonia Docs
- Reference
- Built-in Data Binding Converters
## Built-in Data Binding Converters
Avalonia UI includes a number of built-in data binding converters for common scenarios:
`StringConverters.IsNullOrEmpty` `true` `StringConverters.IsNotNullOrEmpty` `false` `ObjectConverters.IsNull` `true` `ObjectConverters.IsNotNull` `false` `BoolConverters.And` `true` `BoolConverters.Or` `true` ### Negation Operator Examples​
This example shows the TextBlock when the bound value is false:
`TextBlock` ```bash
<StackPanel> <TextBox Name="input" IsEnabled="{Binding AllowInput}"/> <TextBlock IsVisible="{Binding !AllowInput}">Input is not allowed</TextBlock></StackPanel>
```
Negation also works when you bind to a non-Boolean value. This works because the bound value is first converted to a Boolean (using the function Convert.ToBoolean ) and then the result is negated.
`Convert.ToBoolean` For example, as the integer zero is converted to false (by the function Convert.ToBoolean) and all other integer values are converted to true, you can use the negation operator to show a message when a collection is empty, like this:
`Convert.ToBoolean` ```bash
<Panel> <ListBox ItemsSource="{Binding Items}"/> <TextBlock IsVisible="{Binding !Items.Count}">No results found</TextBlock></Panel>
```
You can also use the negation operator twice. For example, where you want to perform the conversion from integer to Boolean, and then negate that value.
You can use this to hide a control when a collection is empty (count is zero), like this:
```bash
<Panel> <ListBox ItemsSource="{Binding Items}" IsVisible="{Binding !!Items.Count}"/></Panel>
```
### Other Conversion Examples​
This example binding will hide the text block if its bound text is null or empty:
```bash
<TextBlock Text="{Binding MyText}"      IsVisible="{Binding MyText,            Converter={x:Static StringConverters.IsNotNullOrEmpty}}"/>
```
And this example will hide the content control if the bound object is null or empty:
```bash
<ContentControl Content="{Binding MyContent}"        IsVisible="{Binding MyContent,               Converter={x:Static ObjectConverters.IsNotNull}}"/>
```
### More Information​
You can follow the Avalonia UI value converter sample, here.
- Negation Operator Examples
- Other Conversion Examples
- More Information
# Controls Reference | Avalonia Docs
- Reference
- Controls Reference
## Built-in Controls
Avalonia provides following groups of built-in controls:
# AutoCompleteBox | Avalonia Docs
- Reference
- Controls Reference
- AutoCompleteBox
## AutoCompleteBox
The AutoCompleteBox presents a text box for user input and a drop-down that contains possible matches from an items source collection, for the text typed in. The drop-down shows when the user starts to type, and the match is updated for each character typed. The user can select from the drop-down.
`AutoCompleteBox` The way in which the text is matched to possible items in the items source is configurable.
### Useful Properties​
You will probably use these properties most often:
`ItemsSource` `FilterMode` `AsyncPopulator` These are the options for the filter mode property:
`StartsWith` `StartsWithCaseSensitive` `StartsWithOrdinal` `StartsWithOrdinalCaseSensitive` `Contains` `ContainsCaseSensitive` `ContainsOrdinal` `ContainsOrdinalCaseSensitive` `Equals` `EqualsCaseSensitive` `EqualsOrdinal` `EqualsOrdinalCaseSensitive` In an ordinal string comparison, each character is compared using its simple byte value (independent of language).
culture-sensitive refers to considering the needs of users from different cultural backgrounds in design and technology implementations. This includes using different string processing and sorting patterns based on language. For example, English is typically sorted alphabetically from A-Z, Chinese may be sorted based on pinyin or stroke order, and other languages may have different sorting rules.
### Examples​
This example has a fixed items source (array) that is set in the C# code-behind.
```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5">Choose an animal:</TextBlock> <AutoCompleteBox x:Name="animals" FilterMode="StartsWith" /></StackPanel>
```
```bash
using Avalonia.Controls;using System.Linq;namespace AvaloniaControls.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();      animals.ItemsSource = new string[]         {"cat", "camel", "cow", "chameleon", "mouse", "lion", "zebra" }      .OrderBy(x=>x);    }  }}
```
![](https://docs.avaloniaui.net/assets/images/autocompletebox-15f0c274b731beb71f0d3c719b9e17e6.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub AutoCompleteBox.cs
`AutoCompleteBox.cs` - Useful Properties
- Examples
- More Information
# Border | Avalonia Docs
- Reference
- Controls Reference
- Border
## Border
The border control decorates a (single) child with a border and background. It can also be used to display rounded corners.
### Useful Properties​
You will probably use these properties most often:
`Background` `BorderBrush` `BorderThickness` `CornerRadius` `BoxShadow` ### Corner Radius Property​
You can give the value of the corner radius property as a single value. In this case, Avalonia UI will use the same radius on all four corners of the child control.
Alternatively you can specify a list of values; this must be in one of the following two formats.
When only two values are in the list, Avalonia UI will interpret them using the pattern:
CornerRadius="Top Bottom"
`CornerRadius="Top Bottom"` The top-left and top-right radii are set from the first value, and the bottom-left and bottom-right radii are set from the second value.
When all four values are in the list, Avalonia UI will interpret them using the pattern:
CornerRadius="TopLeft TopRight BottomRight BottomLeft"
`CornerRadius="TopLeft TopRight BottomRight BottomLeft"` If you use the four value pattern; you must provide all four values, even if one of them is zero. Three values are not permitted in the list.
#### Example​
This example adds some border controls to create a 'pod' look in the layout:
```bash
<StackPanel> <Border Background="Gainsboro"    BorderBrush="Black"    BorderThickness="2"    CornerRadius="3"    Padding="10" Margin="10">  <TextBlock>Box 1</TextBlock> </Border> <Border Background="Gainsboro"     BorderBrush="Black"     BorderThickness="2"     CornerRadius="3"     Padding="10" Margin="10">  <TextBlock>Box 2</TextBlock> </Border></StackPanel>
```
### Box Shadows​
You can define a shadow to a border by setting its box shadow property. You specify a single box shadow using:
- An optional inset keyword - this will draw the shadow inside the border - not often useful!
- Two, three, or four length values - see below.
- A color value.
`inset` If only two length values are given, will interpret them as the offset-x and offset-y. If a third value is given, it is interpreted as a blur-radius, and if a fourth value is given, it is interpreted as a spread-radius.
`offset-x` `offset-y` `blur-radius` `spread-radius` You can specify multiple shadows by providing a comma-separated list of shadow definitions.
This table describes the box shadow values, in the order in which they appear:
`inset` `offset-x` `offset-y` `blur-radius` `spread-radius` `color` If both offset values are set to zero, the shadow is placed behind the element, and will only generate a blur effect if blur-radius and/or spread-radius are set.
`blur-radius` `spread-radius` #### Example​
This is an example of a drop-shadow:
```bash
<StackPanel> <Border Background="Gainsboro"    BorderBrush="Black"    BorderThickness="2"    CornerRadius="3"     BoxShadow="5 5 10 0 DarkGray"    Padding="10" Margin="40">  <TextBlock>Box with a drop shadow</TextBlock> </Border></StackPanel>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Border.cs
`Border.cs` - Useful Properties
- Corner Radius PropertyExample
- Example
- Box ShadowsExample
- Example
- More Information
- Example
# Button Controls | Avalonia Docs
- Reference
- Controls Reference
- Button Controls
## Button Controls
Avalonia UI has a variety of button-type controls:
# Calendar | Avalonia Docs
- Reference
- Controls Reference
- Calendar
## Calendar
The calendar is a control for users to select dates or date ranges.
![](https://docs.avaloniaui.net/assets/images/calendar3-1828bca0fb75b637b86e3eaed5a848e1.gif)
### Useful Properties​
You will probably use these properties most often:
`SelectionMode` `DisplayMode` `SelectedDate` `SelectedDates` `DisplayDate` `DisplayDateStart` `DisplayDateEnd` `BlackoutDates` ### Examples​
This is a basic calendar allowing a single date selection. The calendar's selected date is shown in the text block below.
```bash
<StackPanel Margin="20"> <Calendar x:Name="calendar" SelectionMode="MultipleRange"/> <TextBlock Margin="20"       Text="{Binding #calendar.SelectedDate}"/></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/calendar-20ffb643df9016967ee213134195de1c.gif)
This example allows multiple range selections:
```bash
<StackPanel Margin="20"> <Calendar SelectionMode="MultipleRange"/></StackPanel>
```
After clicking a start date you can extend a single range by holding the shift key and clicking on the end date. You can add extra dates and ranges by holding the control key and clicking on other dates.
![](https://docs.avaloniaui.net/assets/images/calendar2-b9649f1acf179f76de21e3f0b2cb355f.gif)
This example has custom start and end dates, and some dates unavailable. This uses C# code behind the window.
```bash
<StackPanel Margin="20"> <Calendar x:Name="calendar" SelectionMode="SingleDate"/></StackPanel>
```
```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();    var today = DateTime.Today;    calendar.DisplayDateStart = today.AddDays(-25);    calendar.DisplayDateEnd = today.AddDays(25);    calendar.BlackoutDates.Add(      new CalendarDateRange( today.AddDays(5), today.AddDays(10)));  } }
```
![](https://docs.avaloniaui.net/assets/images/calendar4-3693498028628d485f2a30d7b3bbb4c3.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Calendar.cs
`Calendar.cs` - Useful Properties
- Examples
- More Information
# ToggleSplitButton | Avalonia Docs
- Reference
- Controls Reference
- Button Controls
- ToggleSplitButton
## ToggleSplitButton
The ToggleSplitButton functions as a ToggleButton with primary and secondary parts that can each be pressed separately. The primary part behaves like a normal ToggleButton and the secondary part opens a Flyout with additional actions.
`ToggleSplitButton` `ToggleButton` `ToggleButton` `Flyout` The ToggleSplitButton has only two states: checked and unchecked. Indeterminate is not supported like it is with a standard ToggleButton. This was done intentionally to match WinUI and restricts the control’s usage. The ToggleSplitButton should only be used to turn features on/off. Anything other than that is currently considered poor practice from a usability standpoint.
`ToggleSplitButton` `ToggleButton` `ToggleSplitButton` ### Is this the right control?​
A ToggleSplitButton is a fairly specialized control and its usage should be restricted to where it makes clear sense from a user-standpoint. It is intended to turn a feature on/off while allowing some additional configurations to be specified rather than the default.
`ToggleSplitButton` Like a SplitButton, the most common action should be the default and what is shown in the primary part. However, unlike the SplitButton, pressing the primary part will turn this feature on or off instead of simply invoking an action. Additional configurations for the feature should be added to the Flyout which is shown when the secondary (drop down) part is pressed.
`SplitButton` `SplitButton` `Flyout` Pressing a configuration in the Flyout should either (1) turn on the feature with the selected configuration, or (2) change the feature to the selected configuration. Pressing a configuration in the Flyout should never turn off the feature – that can only be done by toggling the primary part.
`Flyout` `Flyout` ### Common Properties​
`Content` `Flyout` `Flyout` `Command` `IsChecked` `ToggleSplitButton` ### Pseudoclasses​
`:pressed` `ToggleSplitButton` `:flyout-open` `Flyout` `:checked` `ToggleSplitButton` `IsChecked="true"` ### API Reference​
ToggleSplitButton
### Source code​
ToggleSplitButton.cs
### Examples​
#### Basic example​
```bash
<ToggleSplitButton Content="Content"          IsChecked="{Binding IsChecked}">  <ToggleSplitButton.Flyout>    <MenuFlyout Placement="Bottom">      <MenuItem Header="Item 1">        <MenuItem Header="Subitem 1" />        <MenuItem Header="Subitem 2" />        <MenuItem Header="Subitem 3" />      </MenuItem>      <MenuItem Header="Item 2"           InputGesture="Ctrl+A" />      <MenuItem Header="Item 3" />    </MenuFlyout>  </ToggleSplitButton.Flyout></ToggleSplitButton>
```
SplitButton (Flyout closed, unchecked)
SplitButton (Flyout closed, checked)
SplitButton (Flyout opened, checked)
#### Text editor with numbered or bulleted list example​
Continuing the text editor example from SplitButton, a common use case of the ToggleSplitButton is to add bulleted/numbered lists to text. In this example the primary part will toggle the list on/off while the secondary part will open a Flyout and allow selecting the bullet or number style.
`SplitButton` `ToggleSplitButton` `Flyout` ```bash
<!-- We have the following Icons defined in our Resources --><PathGeometry x:Key="IconData.NumberedList"> {{ Path Data }} </PathGeometry><PathGeometry x:Key="IconData.BulletedList"> {{ Path Data }} </PathGeometry>
```
```bash
<ToggleSplitButton IsChecked="{Binding TextEditorHasList}">  <ToggleSplitButton.Content>    <!-- Note: For this example we keep the content static, but you can use dynamic content -->    <PathIcon Data="{DynamicResource IconData.BulletedList}" />  </ToggleSplitButton.Content>  <ToggleSplitButton.Flyout>    <Flyout Placement="Bottom">      <!-- Note: For this example we keep the content static, but you can use dynamic content -->      <ListBox Height="200" Width="200" >        <ListBoxItem>          <StackPanel Orientation="Horizontal">            <PathIcon Data="{DynamicResource IconData.NumberedList}" />            <TextBlock Text="Numbered List" />          </StackPanel>        </ListBoxItem>        <ListBoxItem>          <StackPanel Orientation="Horizontal">            <PathIcon Data="{DynamicResource IconData.BulletedList}" />            <TextBlock Text="Bulleted List" />          </StackPanel>        </ListBoxItem>      </ListBox>    </Flyout>  </ToggleSplitButton.Flyout></ToggleSplitButton>
```
Sample of ToggleSplitButton for toggle text lists on and off and selecting the list format
- Is this the right control?
- Common Properties
- Pseudoclasses
- API Reference
- Source code
- ExamplesBasic exampleText editor with numbered or bulleted list example
- Basic example
- Text editor with numbered or bulleted list example
- Basic example
- Text editor with numbered or bulleted list example
# ToggleButton | Avalonia Docs
- Reference
- Controls Reference
- Button Controls
- ToggleButton
## Toggle Button
The ToggleButton can present a Boolean value by using styles and a pseudo class that is either present (true) or absent (false).
`ToggleButton` This allows a wide range of possible graphical presentations for the control in each of the pseudo class states.
### Example​
This example shows a toggle button containing a speaker icon, or a muted speaker icon, depending on whether the button has the checked pseudo class or not.
```bash
<StackPanel HorizontalAlignment="Center" VerticalAlignment="Center"> <TextBlock Margin="0 5">Audio</TextBlock> <ToggleButton IsChecked="True">  <Panel>   <PathIcon Classes="audio-on"        Data="{StaticResource speaker_regular}" />   <PathIcon Classes="audio-mute"        Data="{StaticResource speaker_off_regular}" />  </Panel> </ToggleButton></StackPanel>
```
```bash
<Window.Styles> <Style Selector="ToggleButton PathIcon.audio-on">  <Setter Property="IsVisible" Value="False"/> </Style> <Style Selector="ToggleButton:checked PathIcon.audio-on">  <Setter Property="IsVisible" Value="True"/> </Style> <Style Selector="ToggleButton PathIcon.audio-mute">  <Setter Property="IsVisible" Value="True"/> </Style> <Style Selector="ToggleButton:checked PathIcon.audio-mute">  <Setter Property="IsVisible" Value="False"/> </Style></Window.Styles>
```
```bash
<Styles xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"> <Style>  <Style.Resources>   <StreamGeometry x:Key="speaker_off_regular">M28 29.7678L41.8661 43.6339C42.3543 44.122 43.1457 44.122 43.6339 43.6339C44.122 43.1457 44.122 42.3543 43.6339 41.8661L6.13388 4.36612C5.64573 3.87796 4.85427 3.87796 4.36611 4.36612C3.87796 4.85427 3.87796 5.64573 4.36611 6.13388L13.2322 15H9C6.10051 15 3.75 17.3505 3.75 20.25V27.75C3.75 30.6495 6.10051 33 9 33H13.702C14.8734 33 16.0034 33.4328 16.875 34.2153L25.081 41.5815C26.2077 42.5929 28 41.7933 28 40.2793V29.7678ZM25.5 27.2678V38.5981L18.5451 32.3549C17.2146 31.1606 15.4898 30.5 13.702 30.5H9C7.48122 30.5 6.25 29.2688 6.25 27.75V20.25C6.25 18.7312 7.48122 17.5 9 17.5H13.702C14.3147 17.5 14.92 17.4224 15.5046 17.2723L25.5 27.2678Z M19.8115 14.5082L18.0412 12.7379L25.081 6.41847C26.2076 5.40709 28 6.20669 28 7.72074V22.6967L25.5 20.1967V9.40185L19.8115 14.5082Z M36.1857 30.8824L34.335 29.0317C34.966 27.7376 35.5 26.0404 35.5 24C35.5 21.5224 34.7127 19.5507 33.9203 18.1923C33.5242 17.5133 33.1298 16.9931 32.8397 16.6477C32.695 16.4754 32.577 16.3476 32.499 16.2664C32.46 16.2259 32.4311 16.197 32.414 16.1802L32.3972 16.164L32.398 16.1646C31.8935 15.6947 31.8647 14.9048 32.334 14.3994C32.8038 13.8935 33.5947 13.8642 34.1006 14.334L33.25 15.25C34.1006 14.334 34.1014 14.3347 34.1014 14.3347L34.1022 14.3356L34.1042 14.3374L34.1092 14.3421L34.1228 14.355C34.1336 14.3653 34.1476 14.3788 34.1646 14.3955C34.1987 14.4289 34.245 14.4753 34.3018 14.5343C34.4152 14.6524 34.5707 14.8215 34.754 15.0398C35.1202 15.4757 35.6008 16.1117 36.0797 16.9327C37.0373 18.5743 38 20.9776 38 24C38 26.9108 37.1071 29.2474 36.1857 30.8824Z M41.0185 35.7152L39.1733 33.87C40.3712 31.5479 41.5 28.2383 41.5 24C41.5 19.4474 40.1976 15.9662 38.906 13.6297C38.2594 12.46 37.6157 11.5776 37.1403 10.9943C36.9028 10.7028 36.708 10.4867 36.5767 10.3474C36.511 10.2777 36.4614 10.2274 36.4303 10.1965C36.4148 10.181 36.4039 10.1704 36.398 10.1648L36.3949 10.1617L36.393 10.16C35.8916 9.68785 35.8665 8.89867 36.3376 8.39562C36.8094 7.89169 37.6004 7.8657 38.1044 8.33755L37.2501 9.24987C38.1044 8.33755 38.1053 8.33839 38.1053 8.33839L38.1063 8.33935L38.1087 8.34162L38.115 8.34761L38.1336 8.36536C38.1485 8.37975 38.1685 8.39926 38.1932 8.42388C38.2427 8.4731 38.3112 8.54276 38.396 8.6327C38.5655 8.81253 38.8003 9.07375 39.0784 9.41509C39.6343 10.0974 40.3656 11.1025 41.094 12.4203C42.5524 15.0587 44 18.9526 44 24C44 29.0474 42.5524 32.9412 41.094 35.5797L41.0739 35.6159L41.0185 35.7152Z</StreamGeometry>   <StreamGeometry x:Key="speaker_regular">M25.081 6.41848C26.2076 5.4071 28 6.2067 28 7.72074V40.2793C28 41.7933 26.2077 42.5929 25.081 41.5815L16.875 34.2153C16.0034 33.4328 14.8734 33 13.702 33H9C6.10051 33 3.75 30.6495 3.75 27.75V20.25C3.75 17.3505 6.10051 15 9 15H13.702C14.8734 15 16.0034 14.5672 16.875 13.7847L25.081 6.41848ZM25.5 9.40186L18.5451 15.6451C17.2146 16.8394 15.4898 17.5 13.702 17.5H9C7.48122 17.5 6.25 18.7312 6.25 20.25V27.75C6.25 29.2688 7.48122 30.5 9 30.5H13.702C15.4898 30.5 17.2146 31.1606 18.5451 32.3549L25.5 38.5982V9.40186Z M36.3376 8.39563C36.8095 7.8917 37.6005 7.86571 38.1044 8.33757L38.1053 8.3384C38.1053 8.3384 37.7675 8 38.1151 8.34762L38.1336 8.36537C38.1485 8.37976 38.1685 8.39927 38.1933 8.42389C38.2428 8.47311 38.3113 8.54277 38.396 8.63271C38.5655 8.81254 38.8004 9.07377 39.0785 9.4151C39.6344 10.0974 40.3656 11.1025 41.094 12.4203C42.5525 15.0588 44.0001 18.9526 44.0001 24C44.0001 29.0474 42.5525 32.9413 41.094 35.5797C40.3656 36.8975 39.6344 37.9027 39.0785 38.5849C38.8004 38.9262 38.5655 39.1875 38.396 39.3673C38.3714 39.3935 38.3481 39.4179 38.3262 39.4407C38.273 39.4961 38.2284 39.5412 38.1933 39.5761C38.1685 39.6007 38.1485 39.6202 38.1336 39.6346L38.1151 39.6524L38.1088 39.6584L38.1063 39.6607L38.1053 39.6616C38.1053 39.6616 38.2392 39.5277 38.3262 39.4407C38.4326 39.3343 38.4688 39.298 38.1044 39.6624C37.6005 40.1343 36.8095 40.1083 36.3376 39.6044C35.8666 39.1013 35.8917 38.3122 36.3931 37.84L36.3949 37.8383L36.3981 37.8352C36.404 37.8296 36.4148 37.819 36.4304 37.8035C36.4614 37.7726 36.5111 37.7223 36.5767 37.6526C36.708 37.5133 36.9029 37.2972 37.1404 37.0057C37.6157 36.4224 38.2595 35.54 38.9061 34.3703C40.1976 32.0338 41.5001 28.5526 41.5001 24C41.5001 19.4474 40.1976 15.9663 38.9061 13.6297C38.2595 12.46 37.6157 11.5776 37.1404 10.9943C36.9029 10.7028 36.708 10.4867 36.5767 10.3474C36.5111 10.2777 36.4614 10.2274 36.4304 10.1965C36.4148 10.181 36.404 10.1705 36.3981 10.1648L36.3949 10.1617L36.3931 10.16C35.8917 9.68786 35.8666 8.89869 36.3376 8.39563Z M32.3341 14.3994C32.8038 13.8936 33.5947 13.8643 34.1006 14.334C34.1008 14.3342 34.1014 14.3348 34.1014 14.3348L34.1023 14.3356L34.1043 14.3374L34.1092 14.3421L34.1229 14.355C34.1336 14.3653 34.1477 14.3788 34.1647 14.3955C34.1988 14.429 34.2451 14.4753 34.3018 14.5344C34.4152 14.6524 34.5707 14.8215 34.7541 15.0398C35.1202 15.4757 35.6009 16.1117 36.0798 16.9327C37.0374 18.5743 38.0001 20.9776 38.0001 24C38.0001 27.0224 37.0374 29.4257 36.0798 31.0673C35.6009 31.8883 35.1202 32.5243 34.7541 32.9602C34.5707 33.1785 34.4152 33.3476 34.3018 33.4656C34.2451 33.5247 34.1988 33.5711 34.1647 33.6045L34.1452 33.6235L34.1229 33.645L34.1092 33.6579L34.1043 33.6626L34.1015 33.6652L34.1006 33.666C33.5947 34.1357 32.8038 34.1065 32.3341 33.6006C31.8653 33.0958 31.8935 32.3072 32.3962 31.8371L32.3979 31.8355L32.414 31.8198C32.4312 31.803 32.4601 31.7741 32.4991 31.7336C32.5771 31.6524 32.695 31.5246 32.8398 31.3523C33.1299 31.0069 33.5242 30.4867 33.9203 29.8077C34.7127 28.4493 35.5001 26.4776 35.5001 24C35.5001 21.5224 34.7127 19.5507 33.9203 18.1923C33.5242 17.5133 33.1299 16.9931 32.8398 16.6477C32.695 16.4754 32.5771 16.3476 32.4991 16.2664C32.4601 16.2259 32.4312 16.197 32.414 16.1802L32.3973 16.164L32.3981 16.1647C31.8929 15.6949 31.8645 14.9051 32.3341 14.3994Z</StreamGeometry>   </Style.Resources> </Style></Styles>
```
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:local="using:AvaloniaControls"       x:Class="AvaloniaControls.App">    <Application.Styles>    <FluentTheme Mode="Light"/>    <StyleInclude Source="avares://AvaloniaControls/Icons.axaml" />  </Application.Styles></Application>
```
The content zone of the toggle button contains two path icon elements, only one of which is visible at a time. The path icons get their graphics from an assets file which is referenced as an included style set in the App.xaml file. The icon geometries are from the Avalonia UI Fluent icons resource.
`App.xaml` To see the full list of Fluent icons available with Avalonia UI, see https://avaloniaui.github.io/icons.html
The visibility of the path icons is set by the window styles, and these use the :checked pseudo class to determine when the toggle button is in its checked state. So, when the toggle button is checked, then the audio-on path icon is visible, and the audio-mute path icon is hidden. And conversely, when the toggle button is not checked, then the audio-mute path icon is visible, and the audio-on path icon is hidden.
`:checked` `audio-on` `audio-mute` `audio-mute` `audio-on` ![](https://docs.avaloniaui.net/assets/images/togglebutton-mute-0ef3cc0e022d5f286e3a488601e28316.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ToggleButton.cs
`ToggleButton.cs` - Example
- More Information
# SplitButton | Avalonia Docs
- Reference
- Controls Reference
- Button Controls
- SplitButton
## SplitButton
The SplitButton functions as a Button with primary and secondary parts that can each be pressed separately. The primary part behaves like normal Button and the secondary part opens a Flyout with additional actions.
`SplitButton` `Button` `Button` `Flyout` ### Is this the right control?​
A SplitButton should only be composed of similar actions. Fundamentally, this control is used to group common actions together where one has clear priority over the others. The most common action should be the default and what is shown in the primary part of the SplitButton. Less-common actions should be added to the flyout which is shown when the secondary (drop down) part is pressed.
`SplitButton` The user-selection action should be invoked immediately when pressing either the primary part or a secondary action in the flyout. All pressed actions, whether primary or secondary, are immediate.
### Common Properties​
`Content` `Flyout` `Flyout` `Command` ### Pseudoclasses​
`:pressed` `SplitButton` `:flyout-open` `Flyout` ### API Reference​
SplitButton
### Source code​
SplitButton.cs
### Examples​
#### Basic example​
```bash
<SplitButton Content="Content" >  <SplitButton.Flyout>    <MenuFlyout Placement="Bottom">      <MenuItem Header="Item 1">        <MenuItem Header="Subitem 1" />        <MenuItem Header="Subitem 2" />        <MenuItem Header="Subitem 3" />      </MenuItem>      <MenuItem Header="Item 2"           InputGesture="Ctrl+A" />      <MenuItem Header="Item 3" />    </MenuFlyout>  </SplitButton.Flyout></SplitButton>
```
SplitButton (Flyout closed)
SplitButton (Flyout opened)
#### Color-Selection example​
A common use case of a SplitButton is for coloring text within an editor. Pressing the primary part of the SplitButton will apply the current color to the selected text. Pressing the secondary part will open a Flyout and allow another color to be specified and applied. Again note that when another color is specified in the Flyout, the selected text color will immediately change and the current color will be updated as well.
`SplitButton` `SplitButton` `Flyout` `Flyout` ```bash
<!-- We have the following DataTemplate defined --><DataTemplate DataType="Color"> <Border CornerRadius="4" Width="20" Height="20" BorderBrush="Gray" BorderThickness="1">  <Border.Background>   <SolidColorBrush Color="{Binding}" />  </Border.Background> </Border></DataTemplate>
```
```bash
<!-- SelectedColor, ChangeColorCommand and AvailableColors are properties of our ViewModel --><SplitButton Content="{Binding SelectedColor}"       Command="{Binding ChangeColorCommand}"> <SplitButton.Flyout>  <Flyout Placement="Bottom">   <ListBox ItemsSource="{Binding AvailableColors}"        SelectedItem="{Binding SelectedColor}"        Height="200" Width="200">    <ListBox.ItemsPanel>     <ItemsPanelTemplate>      <WrapPanel />     </ItemsPanelTemplate>    </ListBox.ItemsPanel>   </ListBox>  </Flyout> </SplitButton.Flyout></SplitButton>
```
Sample of SplitButton for color selection
#### Export Button Sample​
Another common example of the SplitButton could be an export button. When the primary part is pressed, data will be exported using default settings. However, if the secondary part is pressed, additional export options could be specified like ‘Export to PNG’, ‘Export to JPG’, etc.
`SplitButton` ```bash
<SplitButton Content="Export to PDF"       Command="{Binding ExportCommand}"       CommandParameter=".pdf">  <SplitButton.Flyout>    <MenuFlyout Placement="RightEdgeAlignedTop">      <MenuItem Header="Export to PNG"           Command="{Binding ExportCommand}"           CommandParameter=".png" />      <MenuItem Header="Export to JPG"           Command="{Binding ExportCommand}"           CommandParameter=".jpg" />    </MenuFlyout>  </SplitButton.Flyout></SplitButton>
```
Sample of a SplitButton with different export options
- Is this the right control?
- Common Properties
- Pseudoclasses
- API Reference
- Source code
- ExamplesBasic exampleColor-Selection exampleExport Button Sample
- Basic example
- Color-Selection example
- Export Button Sample
- Basic example
- Color-Selection example
- Export Button Sample
# Flyout | Avalonia Docs
- Reference
- Controls Reference
- Flyout
## Flyout
Flyouts are dismissible containers that can be attached to some classes of 'host' control; although flyouts themselves are not controls. They show when their host control receives the focus, and are hidden again in a number of different ways.
A flyout can contain simple or richer, composed, UI content.
Flyouts can be declared as a resource and shared between two or more host controls in an Avalonia UI app.
### Examples​
A flyout is attached to a host control using the host's Flyout property. For example:
`Flyout` ```bash
<Button Content="Button with Flyout"> <Button.Flyout >  <Flyout>This is the button flyout.</Flyout> </Button.Flyout></Button>
```
Only the button and split button controls support the Flyout property. You can attach a flyout to other Avalonia UI built-in controls using the AttachedFlyout property instead.
`Flyout` `AttachedFlyout` For controls that do not have the Flyout property, use the AttachedFlyout property like this:
`Flyout` `AttachedFlyout` ```bash
<Border Background="Red" PointerPressed="Border_PointerPressed">  <FlyoutBase.AttachedFlyout>    <Flyout>      <TextBlock Text="Red Rectangle Flyout." />    </Flyout>  </FlyoutBase.AttachedFlyout></Border>
```
The flyout will not show automatically, it has to be shown from code-behind. For example:
```bash
public void Border_PointerPressed(object sender, PointerPressedEventArgs args){  var ctl = sender as Control;  if (ctl != null)  {    FlyoutBase.ShowAttachedFlyout(ctl);  }}
```
![](https://docs.avaloniaui.net/assets/images/flyout-show-attached-02776bdb4d56d90c4c4ef53fa7360b6c.gif)
### Useful Properties​
You will probably use these properties most often:
`Placement` `ShowMode` ### Show Mode​
This setting describes how the flyout shows and hides:
`Standard` `Transient` `TransientWithDismiss OnPointerMoveAway` ### Common Methods for all Flyouts​
`ShowAt(Control)` `ShowAt(Control, bool)` `Hide` ### Sharing Flyouts​
You can share flyouts between two or more elements in your app. For example, to share a flyout from the resources collection of a window:
```bash
<Window.Resources>  <Flyout x:Key="MySharedFlyout">    <!-- Flyout content here -->  </Flyout></Window.Resources><Button Content="Click me!" Flyout="{StaticResource MySharedFlyout}" /><Button Content="Now click me!" Flyout="{StaticResource MySharedFlyout}" />
```
### Styling Flyouts​
Although flyouts are not themselves controls, their general appearance can be customized by targeting the presenter the Flyout uses to display its content. For a normal Flyout this is FlyoutPresenter and for MenuFlyout this is MenuFlyoutPresenter. Because flyout presenters are not exposed, special style classes that should pertain to specific flyouts can be passed using the FlyoutPresenterClasses property on FlyoutBase
`Flyout` `Flyout` `FlyoutPresenter` `MenuFlyout` `MenuFlyoutPresenter` `FlyoutPresenterClasses` `FlyoutBase` ```bash
<Style Selector="FlyoutPresenter.mySpecialClass">  <Setter Property="Background" Value="Red" /></Style><Flyout FlyoutPresenterClasses="mySpecialClass">  <!-- Flyout content here --></Flyout>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Flyout.cs
`Flyout.cs` - Examples
- Useful Properties
- Show Mode
- Common Methods for all Flyouts
- Sharing Flyouts
- Styling Flyouts
- More Information
# Expander | Avalonia Docs
- Reference
- Controls Reference
- Expander
## Expander
The expander control has a header area (always visible) and a collapsible content section that can contain a single child control.
### Useful Properties​
You will probably use these properties most often:
### Example​
```bash
<Expander VerticalAlignment="Top">  <Expander.Header>    Hidden Search  </Expander.Header>  <Grid RowDefinitions="*,*" ColumnDefinitions="150,*">    <TextBlock Grid.Row="0" Grid.Column="0"          VerticalAlignment="Center">Search</TextBlock>    <TextBox Grid.Row="0" Grid.Column="1"         Watermark="Search text" Width="200" />    <TextBlock Grid.Row="1" Grid.Column="0"          VerticalAlignment="Center">Case sensitive?</TextBlock>    <CheckBox Grid.Row="1" Grid.Column="1" />  </Grid></Expander>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Expander.cs
`Expander.cs` - Useful Properties
- Example
- More Information
# DrawingImage | Avalonia Docs
- Reference
- Controls Reference
- DrawingImage
## DrawingImage
### Useful Properties​
You will probably use these properties most often:
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub DrawingImage.cs
`DrawingImage.cs` - Useful Properties
- More Information
# DockPanel | Avalonia Docs
- Reference
- Controls Reference
- DockPanel
## DockPanel
The DockPanel control arranges its child controls along specified 'docking edges' (top, bottom, left, and right) with the last child filling any remaining space. The dock panel can maintain the child control's dimension that is parallel to the docking edge, so that the child fills all the available space along the docking edge.
`DockPanel` For example, if the docking edge on a child control is defined as 'top' and it has a height defined, but no width, it will draw like this:
You must define the child control dimension perpendicular to the docking edge, or it will not show.
You can optionally define the dimension that is parallel to the docking edge. In this case, the child will be drawn according to the alignment setting in the same direction. For example, a child with a defined width, docked to the top edge, will obey its horizontal alignment property (default center).
Child controls are docked in the sequence that they are defined in the XAML. When Avalonia UI is sizing a child control, the presence of any previously drawn controls is taken into account. That means there is never any overlap.
The last child control defined will fill any remaining space.
You must always define a last child control (with no dock property), or the docking calculation will not perform correctly. This means that a dock panel requires a minimum of two child controls.
### Useful Properties​
You will probably use these properties most often:
`.Left` `.Top` `.Right` `.Bottom` ### Example​
Setting the opacity of the orange rectangle to 0.5 demonstrates that there are no overlaps.
```bash
<DockPanel Width="300" Height="300">  <Rectangle Fill="Red" Height="100" DockPanel.Dock="Top"/>  <Rectangle Fill="Blue" Width="100" DockPanel.Dock="Left" />  <Rectangle Fill="Green" Height="100" DockPanel.Dock="Bottom"/>  <Rectangle Fill="Orange" Width="100" DockPanel.Dock="Right" Opacity="0.5"/>  <Rectangle Fill="Gray" /></DockPanel>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub DockPanel.cs
`DockPanel.cs` - Useful Properties
- Example
- More Information
# Decorator | Avalonia Docs
- Reference
- Controls Reference
- Decorator
## Decorator
The Decorator is the base decorator class for decorating a single child control.
`Decorator` #### Reference​
Decorator
#### Source code​
Decorator.cs
- Reference
- Source code
# DatePicker | Avalonia Docs
- Reference
- Controls Reference
- DatePicker
## DatePicker
The DatePicker has three 'spinner' controls to allow the user to pick a date value. The spinners display when the control is clicked.
`DatePicker` ### Useful Properties​
You will probably use these properties most often:
`DayVisible` `MonthVisible` `YearVisible` `DayFormat` `MonthFormat` `YearFormat` `SelectedDate` ### Example​
This example uses the date format attribute to display the name of the day as well as the number:
```bash
<StackPanel Margin="20"> <DatePicker DayFormat="ddd dd"/></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/datepicker-651624c3960bee4ed88aeff1a9e05b97.gif)
### Initializing the Date​
The date properties of this control cannot be set in XAML using an attribute. This is because there is no conversion available for converting strings to date objects like DateTime and DateTimeOffset.
`DateTime` `DateTimeOffset` You will need to write code-behind like this:
```bash
datePicker.SelectedDate = new DateTimeOffset(new DateTime(1950, 1, 1));
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub DatePicker.cs
`DatePicker.cs` - Useful Properties
- Example
- Initializing the Date
- More Information
# DataGridColumn | Avalonia Docs
- Reference
- Controls Reference
- DataGrid
- DataGridColumn
## DataGridColumn
A DataGrid can contain multiple data grid columns and Avalonia UI has two built-in column types which can be used to display a different data types, and a template type that can customise the column appearance.
`DataGrid` `DataGridTextColumn` `DataGridCheckBoxColumn` `DataGridTemplateColumn` ### Useful Properties​
Most of these properties are common to all three column types:
`Header` `HeaderTemplate` `IsReadOnly` `IsThreeState` `Width` ### Column Width​
If you do not set the width for a column, it will be resized to fit the contents, and a horizontal scrollbar will be added to the grid if necessary.
You can set the width of a column absolutely, for example:
```bash
<DataGridTextColumn Width="200" />
```
This will cause the column content that does not fit to be hidden.
Alternatively, you can specify relative automatic sizes. This uses * to represent an equal division of the available width, and then multiples like 2*. Any columns without a width specified are sized to their content.
For example to divide a data grid into 3 equal columns:
```bash
<DataGridTextColumn Width="*" /><DataGridTextColumn Width="*" /><DataGridTextColumn Width="*" />
```
Example
This example improves a data grid by expanding two columns equally across the width:
```bash
<Window ... >  <Design.DataContext>    <vm:MainWindowViewModel/> </Design.DataContext> <DataGrid Margin="20" ItemsSource="{Binding People}"     IsReadOnly="True"     GridLinesVisibility="All"     BorderThickness="1" BorderBrush="Gray">  <DataGrid.Columns>   <DataGridTextColumn Header="First Name" Width="*"        Binding="{Binding FirstName}"/>   <DataGridTextColumn Header="Last Name" Width="*"        Binding="{Binding LastName}" />  </DataGrid.Columns> </DataGrid></Window>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Person> People { get; }    public MainWindowViewModel()    {      var people = new List<Person>       {        new Person("Neil", "Armstrong"),        new Person("Buzz", "Lightyear"),        new Person("James", "Kirk")      };      People = new ObservableCollection<Person>(people);    }  }}
```
```bash
public class Person{  public string FirstName { get; set; }  public string LastName { get; set; }    public Person(string firstName , string lastName)  {    FirstName = firstName;    LastName = lastName;  }}
```
It works in the preview pane because the <Design.DataContext> element creates a view model to bind to:
`<Design.DataContext>` ### More Information​
For the complete API documentation about the data grid text column, see here.
For the complete API documentation about data grid check box column, see here.
View the source code on GitHub DataGridTextColumn.cs
`DataGridTextColumn.cs` View the source code on GitHub DataGridCheckBoxColumn.cs
`DataGridCheckBoxColumn.cs` - Useful Properties
- Column Width
- More Information
# DataGrid | Avalonia Docs
- Reference
- Controls Reference
- DataGrid
## DataGrid
The DataGrid displays repeating data in a customizable grid. The control can be styled, templated and bound.
`DataGrid` The DataGrid needs to be bound to an observable collection in a view model that can be found in a related data context.
`DataGrid` To review the concept behind the data context, see here.
The DataGrid is in an additional Avalonia UI package. To use the DataGrid in your project, you must reference the Avalonia.Controls.DataGrid NuGet package, and reference the styles that it uses, see below.
`DataGrid` `DataGrid` ### NuGet Package Reference​
You must install the NuGet package for the DataGrid, there are several ways of doing this. You can use Manage NuGet Packages from the project menu of your IDE:
`DataGrid` Alternatively, you can run this instruction from the command line:
```bash
dotnet add package Avalonia.Controls.DataGrid
```
Or add package reference directly to the project (.csproj) file:
`.csproj` ```bash
<PackageReference Include="Avalonia.Controls.DataGrid" Version="11.0.0" />
```
Note you must always install the data grid version that matches the Avalonia UI version you are using.
### Include DataGrid Styles​
You must reference the DataGrid themes to include the additional styles that the DataGrid uses. You can do this by adding a <StyleInclude> element to the application (App.axaml file).
`DataGrid` `DataGrid` `<StyleInclude>` `App.axaml` For example:
```bash
<Application.Styles>  <FluentTheme />  <StyleInclude Source="avares://Avalonia.Controls.DataGrid/Themes/Fluent.xaml"/></Application.Styles>
```
### Useful Properties​
You will probably use these properties most often:
`AutoGenerateColumns` `ItemsSource` `IsReadOnly` `CanUserReorderColumns` `CanUserResizeColumns` `CanUserSortColumns` ### Examples​
This example will generate a basic DataGrid, with column header names auto-generated from the item class. The items data source is bound to the main window view model.
`DataGrid` ```bash
<DataGrid Margin="20" ItemsSource="{Binding People}"      AutoGenerateColumns="True" IsReadOnly="True"      GridLinesVisibility="All"     BorderThickness="1" BorderBrush="Gray"></DataGrid>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Person> People { get; }    public MainWindowViewModel()    {      var people = new List<Person>       {        new Person("Neil", "Armstrong"),        new Person("Buzz", "Lightyear"),        new Person("James", "Kirk")      };      People = new ObservableCollection<Person>(people);    }  }}
```
```bash
public class Person{  public string FirstName { get; set; }  public string LastName { get; set; }    public Person(string firstName , string lastName)  {    FirstName = firstName;    LastName = lastName;  }}
```
![](https://docs.avaloniaui.net/assets/images/datagrid-sort-column-25fd40a133c877c053be95f32904e730.gif)
These examples use the MVVM pattern with data binding to an ObservableCollection. For more information on the concepts behind data binding, see here.
`ObservableCollection` Property names from the item class will generally not make good column names. This example adds custom header names to the grid. It also allows column reordering and resizing and disallows the default column sorting option:
```bash
<DataGrid Margin="20" ItemsSource="{Binding People}"     IsReadOnly="True"     CanUserReorderColumns="True"     CanUserResizeColumns="True"     CanUserSortColumns="False"     GridLinesVisibility="All"     BorderThickness="1" BorderBrush="Gray"> <DataGrid.Columns>   <DataGridTextColumn Header="First Name" Binding="{Binding FirstName}"/>   <DataGridTextColumn Header="Last Name" Binding="{Binding LastName}" /> </DataGrid.Columns></DataGrid>
```
![](https://docs.avaloniaui.net/assets/images/datagrid-reorder-column-044a6bb53f563e5469d582d5d02bc90e.gif)
This example shows how the DataGrid can accept changes and update the underlying collection, and use different column types to edit the data:
`DataGrid` ```bash
<DataGrid Margin="20" ItemsSource="{Binding People}"         GridLinesVisibility="All"     BorderThickness="1" BorderBrush="Gray"> <DataGrid.Columns>   <DataGridTextColumn Header="First Name" Binding="{Binding FirstName}"/>   <DataGridTextColumn Header="Last Name" Binding="{Binding LastName}" />   <DataGridCheckBoxColumn Header="Fictitious?" Binding="{Binding IsFictitious}" /> </DataGrid.Columns></DataGrid>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Person> People { get; }    public MainWindowViewModel()    {      var people = new List<Person>       {        new Person("Neil", "Armstrong", false),        new Person("Buzz", "Lightyear", true),        new Person("James", "Kirk", true)      };      People = new ObservableCollection<Person>(people);    }  }}
```
```bash
public class Person{  public string FirstName { get; set; }  public string LastName { get; set; }  public bool IsFictitious { get; set; }  public Person(string firstName , string lastName, bool isFictitious)  {    FirstName = firstName;    LastName = lastName;    IsFictitious = isFictitious;  }}
```
![](https://docs.avaloniaui.net/assets/images/datagrid-column-types-90f3be4eb17d5258413060ad73c8db2e.gif)
### More Information​
For more information about the different kinds of DataGridColumn, see the next page.
`DataGridColumn` For the complete API documentation about this control, see here.
View the source code on GitHub DataGrid.cs
`DataGrid.cs` - NuGet Package Reference
- Include DataGrid Styles
- Useful Properties
- Examples
- More Information
# Data Binding | Avalonia Docs
- Basics
- Data
- Data Binding
## Data Binding
Avalonia uses data binding to move data from application objects into UI controls, change the data in application objects in response to user input, and initiate actions on the application objects in response to commands from the user.
In this arrangement, the control is the binding target, and the object is the data source.
Avalonia runs a data binding system to complete much of the above activity from simple mappings declared in the XAML; that is without requiring you to add a lot of additional coding.
Data binding mappings are defined using XML between the attributes of an Avalonia control, and the properties of an application object. In general terms, the syntax is like this:
```bash
<SomeControl Attribute="{Binding PropertyName}" />
```
The mappings can be bidirectional: where changes in the properties of a bound application object are reflected in the control, and changes in the control (however caused) are applied to the underlying object. An example of bidirectional binding is a text input bound to a string property of an object. The XML might look like this:
```bash
<TextBox Text="{Binding FirstName}" />
```
If the user edits the text in the text box, then the FirstName property of the underlying object is automatically updated. In the other direction, if the FirstName property of the underlying object changes, then the text visible in the text box is updated.
`FirstName` `FirstName` Bindings can be unidirectional: where changes in the properties of a bound application object are reflected in the control, but the user cannot change the control. An example of this would be the text block control, which is read-only.
```bash
<TextBlock Text="{Binding StatusMessage}" />
```
Binding is used with the MVVM architectural pattern, and this is one of the principle ways of programming with Avalonia UI.
For more information about how to use the MVVM Pattern with Avalonia, see the concept page here.
For background information on the origins and development of the MVVM pattern at Microsoft, see the Microsoft Patterns and Practices article here.
On the next page, you will learn where the data binder gets the data object from.
# ContextMenu | Avalonia Docs
- Reference
- Controls Reference
- ContextMenu
## ContextMenu
The ContextMenu can be applied to any host control to implement a right-click 'context sensitive' menu. This uses an attached property of the host control.
`ContextMenu` To review the concept behind this use of an attached property, see here.
### Example​
This example, a context menu is attached to a multi-line text box:
```bash
<TextBox AcceptsReturn="True" TextWrapping="Wrap"> <TextBox.ContextMenu>  <ContextMenu>   <MenuItem Header="Copy"/>   <MenuItem Header="Paste"/>  </ContextMenu> </TextBox.ContextMenu>   </TextBox>
```
![](https://docs.avaloniaui.net/assets/images/contextmenu-copy-paste-59d0c930b70a3f043509b834fc0d22f3.gif)
### Context Flyout​
You can use a context flyout as an alternative to a context menu. A context flyout can provide a sharable and richer UI experience than a simple context menu.
A control cannot have a context flyout and a context menu attached at the same time.
A context flyout is invoked automatically like a context menu.
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ContextMenu.cs
`ContextMenu.cs` - Example
- Context Flyout
- More Information
# Attached Properties | Avalonia Docs
- Deep Dives
- Attached Properties
## Attached Properties
Avalonia UI controls support the attached property concept. This is a property applied to a child control that references its container control.
In XAML, attached properties are defined as attributes of the child control element using the format: ContainerClassName.AttachedPropertyName="value"
`ContainerClassName.AttachedPropertyName="value"` Here are some scenarios where an attached property is used:
### Attached Control​
An additional control is attached to a 'host control' for some purpose. This can be used where the control usually only allows a single child in its content zone. In this scenario the attached control is not counted as part of the content, but it will be used in some other way by the container. Examples include: context menus, tool tips and flyouts.
### Layout Control​
Attached layout properties are used in scenarios where the container control has to know something about the child controls it is going to arrange. Examples include: grids, dock panels and relative panels.
For a full list of the Avalonia UI built-in controls, see the reference here.
- Attached Control
- Layout Control
# Application Lifetimes | Avalonia Docs
- Deep Dives
- Application Lifetimes
## Application Lifetimes
Not all platforms are created equal! For example, the lifetime management that you may be using to developing with in Windows Forms or WPF can operate only on desktop-style platforms. Avalonia UI is a cross-platform framework; so to make your application portable, it provides several different lifetime models for your application, and also allows you to control everything manually if the target platform permits.
### How do lifetimes work?​
For a desktop application, you initialise like this:
```bash
class Program{ // This method is needed for IDE previewer infrastructure public static AppBuilder BuildAvaloniaApp()   => AppBuilder.Configure<App>().UsePlatformDetect(); // The entry point. Things aren't ready yet, so at this point // you shouldn't use any Avalonia types or anything that expects // a SynchronizationContext to be ready public static int Main(string[] args)   => BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);}
```
Then the main window is created in the Application class:
`Application` ```bash
public override void OnFrameworkInitializationCompleted(){ if (ApplicationLifetime          is IClassicDesktopStyleApplicationLifetime desktop)  desktop.MainWindow = new MainWindow(); else if (ApplicationLifetime          is ISingleViewApplicationLifetime singleView)  singleView.MainView = new MainView(); base.OnFrameworkInitializationCompleted();}
```
This method is called when the framework has initialized and the ApplicationLifetime property contains the chosen lifetime if any.
`ApplicationLifetime` If you run the application in design mode (this uses the IDE previewer process), then ApplicationLifetime is null.
`ApplicationLifetime` ### Lifetime Interfaces​
Avalonia UI provides a range of interfaces to allow you to choose a level of control that is suitable for your application. These are provided by the BuildAvaloniaApp().Start[Something] family of methods.
`BuildAvaloniaApp().Start[Something]` #### IControlledApplicationLifetime​
Provided by:
- StartWithClassicDesktopLifetime
- StartLinuxFramebuffer
`StartWithClassicDesktopLifetime` `StartLinuxFramebuffer` Allows you to subscribe to Startup and Exit events and permits explicitly shutting down of the application by calling the Shutdown method. This interface gives you control of the application's exit procedures.
`Startup` `Exit` `Shutdown` #### IClassicDesktopStyleApplicationLifetime​
Inherits: IControlledApplicationLifetime
`IControlledApplicationLifetime` Provided by:
- StartWithClassicDesktopLifetime
`StartWithClassicDesktopLifetime` Allows you to control your application lifetime in the manner of a Windows Forms or WPF application. This interface provides a way to access the list of the currently opened windows, to set a main window, and has three shutdown modes:
- OnLastWindowClose - shuts down the application when the last window is closed
- OnMainWindowClose - shuts down the application when the main window is closed (if it has been set).
- OnExplicitShutdown - disables automatic shutdown of the application, you need to call the Shutdown method in your code.
`OnLastWindowClose` `OnMainWindowClose` `OnExplicitShutdown` `Shutdown` #### ISingleViewApplicationLifetime​
Provided by:
- StartLinuxFramebuffer
- mobile platforms
- web platform (WebAssembly/WASM)
`StartLinuxFramebuffer` Some platforms do not have a concept of a desktop main window and only allow one view on the device's screen at a time. For these platforms the lifetime allows you to set and change the main view class (MainView) instead.
`MainView` To implement the navigation stack on platforms like this (with a single main view), you can use ReactiveUI routing or another routing control.
### Manual Lifetime Management​
If you need to, you can take full control of your application's lifetime management. For example on a desktop platform you can pass a delegate to AppMain to the BuildAvaloniaApp.Start method, and then manage things manually from there:
`AppMain` `BuildAvaloniaApp.Start` ```bash
class Program{ // This method is needed for IDE previewer infrastructure public static AppBuilder BuildAvaloniaApp()   => AppBuilder.Configure<App>().UsePlatformDetect(); // The entry point. Things aren't ready yet, so at this point // you shouldn't use any Avalonia types or anything that expects // a SynchronizationContext to be ready public static int Main(string[] args)   => BuildAvaloniaApp().Start(AppMain, args); // Application entry point. Avalonia is completely initialized. static void AppMain(Application app, string[] args) {   // A cancellation token source that will be   // used to stop the main loop   var cts = new CancellationTokenSource();     // Do your startup code here   new Window().Show();   // Start the main loop   app.Run(cts.Token); }}
```
- How do lifetimes work?
- Lifetime InterfacesIControlledApplicationLifetimeIClassicDesktopStyleApplicationLifetimeISingleViewApplicationLifetime
- IControlledApplicationLifetime
- IClassicDesktopStyleApplicationLifetime
- ISingleViewApplicationLifetime
- Manual Lifetime Management
- IControlledApplicationLifetime
- IClassicDesktopStyleApplicationLifetime
- ISingleViewApplicationLifetime
# Control Trees | Avalonia Docs
- Deep Dives
- Control Trees
## Control Trees
Avalonia UI creates control trees from the XAML files in an application so that it can render the UI presentation and manage the application functionality.
### Logical Tree​
The logical control tree represents the application controls (including the main window) in the hierarchy in which they are defined in the XAML. For example, a control (button) inside another control (stack panel) in a window will have the 3-layer logical tree shown here:
While your application is running, you can show the Avalonia Dev Tools window (hit F12). This displays the logical tree on its Logical Tree tab.
### Visual Tree​
The visual control tree contains everything that is actually being run by Avalonia UI. It shows all the properties set on the controls, and all the additional parts that have been added by Avalonia UI in order to present the UI and manage the application functionality.
![](https://docs.avaloniaui.net/assets/images/control-trees-visual-38c63b9b6fa6c1e23dc5adf2ab2c2146.png)
You can see the visual control tree on the Visual Tree tab of the Avalonia Dev Tools window.
### Events​
An essential part of application functionality management performed by Avalonia UI, is the generation and propagation of events. The Events tab logs the source and propagation of events as you move around, and otherwise interact with the running application.
![](https://docs.avaloniaui.net/assets/images/control-trees-events-ddf32ee97496695cc595bab3b00d6c83.png)
- Logical Tree
- Visual Tree
- Events
# Custom ItemsPanel | Avalonia Docs
- Deep Dives
- Custom ItemsPanel
## Custom ItemsPanel
All ItemsControls have an item container panel which is used to layout their items. It is possible to override the type of panel used by the control to achieve custom/alternative layouts of items in a control. This document provides some examples showcasing how and why you would do this.
`ItemsControl` - ItemsControl
- TreeView
- Carousel
- Menu
- ComboBox
- ListBox
`ItemsControl` `TreeView` `Carousel` `Menu` `ComboBox` `ListBox` ### Example​
This example binds an observable collection of Rectangles (based on the Tile VM data) to an ItemsControl. ItemsControl.ItemPanel is set to a Canvas and we use a style to position the Rectangle within the Canvas.
`Rectangle` `ItemsControl` `Canvas` `Rectangle` `Canvas` ```bash
<ItemsControl ItemsSource="{Binding TileList}"> <ItemsControl.ItemsPanel>  <ItemsPanelTemplate>   <Canvas Width="50" Height="50" Background="Yellow" Margin="3"/>  </ItemsPanelTemplate> </ItemsControl.ItemsPanel> <ItemsControl.ItemTemplate>  <DataTemplate>   <Rectangle Fill="Green" Height="{Binding Size}" Width="{Binding Size}"/>  </DataTemplate> </ItemsControl.ItemTemplate> <ItemsControl.Styles>  <Style Selector="ContentPresenter" x:DataType="vm:Tile">   <Setter Property="Canvas.Left" Value="{Binding TopX}"/>   <Setter Property="Canvas.Top" Value="{Binding TopY}"/>  </Style> </ItemsControl.Styles></ItemsControl>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel  {    public ObservableCollection<Tile> TileList { get; set; }        public MainWindowViewModel()    {      TileList = new ObservableCollection<Tile>(new List<Tile>      {        new Tile(10, 10, 10),        new Tile(10, 20, 20),        new Tile(10, 30, 30),      });      }  }}
```
```bash
public record Tile(int Size, int TopX, int TopY);
```
- Example
# ItemsControl | Avalonia Docs
- Reference
- Controls Reference
- ItemsControl
## ItemsControl
The ItemsControl is the basis for controls that display repeating data (like the list box for example). It has no built-in formatting or interactions; but you can use it with data binding, styling and data templates to create a completely custom repeating data control.
`ItemsControl` To see the full list of Avalonia UI built-in repeating data controls, see here.
### Useful Properties​
You will probably use these properties most often:
`ItemsSource` `ItemsControl.ItemTemplate` `ItemsControl.ItemsPanel` `ItemsControl.Styles` ### Example​
This example binds an observable collection of crockery items to an items control, where some custom layout and formatting is provided by a data template:
```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5">List of crockery:</TextBlock> <ItemsControl ItemsSource="{Binding CrockeryList}" >  <ItemsControl.ItemTemplate>  <DataTemplate>   <Border Margin="0,10,0,0"     CornerRadius="5"     BorderBrush="Gray" BorderThickness="1"     Padding="5">    <StackPanel Orientation="Horizontal">     <TextBlock Text="{Binding Title}"/>     <TextBlock Margin="5 0" FontWeight="Bold"            Text="{Binding Number}"/>    </StackPanel>   </Border>  </DataTemplate>  </ItemsControl.ItemTemplate>  </ItemsControl></StackPanel>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Crockery> CrockeryList { get; set; }        public MainWindowViewModel()    {      CrockeryList = new ObservableCollection<Crockery>(new List<Crockery>      {        new Crockery("dinner plate", 12),        new Crockery("side plate", 12),        new Crockery("breakfast bowl", 6),        new Crockery("cup", 10),        new Crockery("saucer", 10),        new Crockery("mug", 6),        new Crockery("milk jug", 1)      });      }  }}
```
```bash
public class Crockery{  public string Title { get; set; }  public int Number{ get; set; }  public Crockery(string title, int number)  {    Title = title;    Number = number;  }}
```
The view resizes horizontally, but content is hidden when it is too high. This control does not have a built-in scrollbar (unlike ListBox).
`ListBox` ![](https://docs.avaloniaui.net/assets/images/itemscontrol-with-custom-layout-and-formatting-8f1780eab3ce56a01e50893704fbb1ce.gif)
### More Information​
For the complete ItemsControl API documentation, see here.
View the source code on GitHub ItemsControl.cs
`ItemsControl.cs` - Useful Properties
- Example
- More Information
# Repeating Data Controls | Avalonia Docs
- Reference
- Controls Reference
- Repeating Data Controls
## Repeating Data Controls
These controls display repeating data, in either a tabular or list format:
# RelativePanel | Avalonia Docs
- Reference
- Controls Reference
- RelativePanel
## RelativePanel
The RelativePanel control allows you to arrange its child controls by specifying their position relative to other (sibling) child controls, or in relation to the panel itself. Positions are calculated using the inside of the panel control (content zone) and the outer edge of the margin zone of the child controls.
`RelativePanel` To review the concept of control layout zones, see here.
The default position for a child control, is the upper left corner of the panel.
You use attached relative position properties to specify the layout of child controls. The format is like this:
RelativePanel.PositionProperty="NameOfSibling"
`RelativePanel.PositionProperty="NameOfSibling"` Where PositionProperty property is one of the relative position properties (see table below), and NameOfSibling is the name property of one of the other child controls.
`PositionProperty` `NameOfSibling` It is an error to give the value of a relative position property as the name of the child control itself. That would be a circular reference!
You can specify up to four relative position properties per child control - for how the top, bottom, left and right edges are to be calculated.
It is an error to define the same relative position property twice for the same child control.
It is not an error to specify different, but potentially conflicting relative position properties, although you may find the result difficult to understand.
If more than one child control ends up in the same calculated position, then they are drawn in the sequence that they appear in the XAML, and may overlap or obscure another child control.
This means you must give child controls a name, and use the correct name in any relative position property values. If you get this wrong, the control will adopt the default (top-left) position, and may overlap or obscure another.
### Useful Properties​
You will probably use these properties most often:
`AlignTopWithPanel` `AlignBottomWithPanel` `AlignLeftWithPanel` `AlignRightWithPanel` `AlignHorizontalCenterWithPanel` `AlignVerticalCenterWithPanel` `AlignTopWith` `AlignBottomWith` `AlignLeftWith` `AlignRightWith` `AlignHorizontalCenterWith` `AlignVerticalCenterWith` `Above` `Below` `LeftOf` `RightOf` ### Example​
This XAML shows how to arrange some child controls in different ways:
```bash
<Border BorderBrush="DarkGray" BorderThickness="1" Width="300" Height="300"> <RelativePanel >  <Rectangle x:Name="RedRect" Fill="Red" Height="50" Width="50"/>  <Rectangle x:Name="BlueRect" Fill="Blue" Opacity="0.5" Height="50" Width="150"        RelativePanel.RightOf="RedRect" />  <Rectangle x:Name="GreenRect" Fill="Green" Height="100"        RelativePanel.Below="RedRect"        RelativePanel.AlignLeftWith="RedRect"        RelativePanel.AlignRightWith="BlueRect"/>  <Rectangle Fill="Orange"        RelativePanel.Below="GreenRect"        RelativePanel.AlignLeftWith="BlueRect"        RelativePanel.AlignRightWithPanel="True"        RelativePanel.AlignBottomWithPanel="True"/> </RelativePanel></Border>
```
The result looks like this:
Here are some notes about the above example:
- The red rectangle is given a size (50x50) but no relative position. It is therefore placed in the default (top-left) position.
- The blue rectangle has a 50% opacity to demonstrate that is is not overlapping any other.
- The green rectangle is given a height (100), but no width. Its left side is aligned with the red rectangle, and its right side is aligned with the blue rectangle, this calculates its width.
- The orange rectangle has not been given a size. Its left side is aligned with the blue rectangle. Its right and bottom edges are aligned with the edge of the panel. Therefore its size is determined by the alignments and it will resize if the panel itself is resized.
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub RelativePanel.cs
`RelativePanel.cs` - Useful Properties
- Example
- More Information
# Layout Zones | Avalonia Docs
## Layout Zones
# RefreshContainer | Avalonia Docs
- Reference
- Controls Reference
- RefreshContainer
## RefreshContainer
The RefreshContainer allows a user to pull down on content or a list of data to refresh the content or retrieve more data. The refresh progress is indicated by a RefreshVisualizer that appears from the edge by which the pull gesture was initiated. The content of a RefreshContainer must be a ScrollViewer, or a control that has one.
`RefreshContainer` `RefreshVisualizer` `RefreshContainer` `ScrollViewer` ### Example​
This example shows hows to use a RefreshContainer with a
In the axaml file.
```bash
<RefreshContainer PullDirection="TopToBottom"        RefreshRequested="RefreshContainerPage_RefreshRequested">  <ListBox ItemsSource="{Binding Items}"/></RefreshContainer>
```
In the class file.
```bash
private void RefreshContainerPage_RefreshRequested(object? sender, RefreshRequestedEventArgs e){  // Retrieve a deferral object.  var deferral = e.GetDeferral();  // Refresh List Box Items  // Notify the Refresh Container that the refresh is complete.  deferral.Complete();}
```
### Refreshing​
A refresh can be initiated by pulling in the direction specified by the PullDirection property to the full extent of the visualizer, or by calling the RequestRefresh method on the RefreshContainer. The progress of the refresh is indicated by the RefreshVisualizerState of the Visualizer, which can be in any of the following;
`PullDirection` `RequestRefresh` `RefreshVisualizerState` `Visualizer` - Idle​
##### Idle​
This is the default state of the visualizer. The user is not interacting with the container, and no refresh is in progress. The visualizer is hidden.
- Interacting​
##### Interacting​
The user is pulling in the direction specified in the PullDirection property, but has not reached the pull threshold. The visualizer gradually becomes visible until the pull threshold is reached. If the pull is releaseed before reaching the pull threshold, the Visualizer returns to the Idle state, and no refresh is initiated. If the pull threshold is reached, the Visualizer enters the Pending state.
`PullDirection` `Visualizer` `Idle` `Visualizer` `Pending` - Pending​
##### Pending​
The user has pulled past the pull threshold. In this state, the visualizer is fully visible. If the user moves the contact back to before the pull threshold, the visualizer returns to the Interacting state. If the user releases contact while in the Pending state, the visualizer enters the Refreshing state.
`Interacting` `Pending` `Refreshing` - Refreshing​
##### Refreshing​
The user has released the touch contact while the visualizer is in the Pending state. The RefreshRequested event is raised. The event args contains a Deferral object. This object is used to notify the Refresh Container that the refresh action has completed, and should be used in long refreshes without blocking the UI thread. If not retrieved, the Refreshing state ends when the RefreshRequested invocation is complete. In this state, the visualizer is fully visible, and the refresh animation begins.
`Pending` `RefreshRequested` `Deferral` `Refreshing` `RefreshRequested` - Peeking​
##### Peeking​
This occurs when the user starts a pull gesture while the content is in a position where refresh is not allowed. This typical happens when the child ScrollViewer isn't at Offset 0, with respect to the pull direction and scroll direction, when the pull is started. The visualizer is hidden and the visualizer's state can only progress to Idle when the pull is released.
`Idle` ### More Information​
View the source code on GitHub RefreshContainer.cs
`RefreshContainer.cs` - Example
- Refreshing
- More Information
# ProgressBar | Avalonia Docs
- Reference
- Controls Reference
- ProgressBar
## ProgressBar
The ProgressBar presents a value as a proportionately filled bar with the option to show a caption.
`ProgressBar` ### Useful Properties​
You will probably use these properties most often:
`Minimum` `Maximum` `Value` `Foreground` `ShowProgressText` `ProgressTextFormat` ### Example​
```bash
<StackPanel Margin="20"> <ProgressBar Margin="0 10" Height="20"         Minimum="0" Maximum="100" Value="14"        ShowProgressText="True"/> <ProgressBar Margin="0 10" Height="20"        Minimum="0" Maximum="100" Value="92"        Foreground="Red"        ShowProgressText="True"/></StackPanel>
```
### ProgressTextFormat Example​
`ProgressTextFormat` By default, ShowProgressText shows the percentage completion according to the Value, Minimum, and Maximum. The format of this text can be customised by using the ProgressTextFormat property. This expects a string which will be passed to a string.Format call with the value of ProgressTextFormat as the format string. The following format items are available at the given indices:
`ShowProgressText` `Value` `Minimum` `Maximum` `ProgressTextFormat` `string.Format` `ProgressTextFormat` - 0 = Value
- 1 = Value as a Percentage from 0 to 100 (e.g. Minimum = 0, Maximum = 50, Value = 25, then Percentage = 50)
- 2 = Minimum
- 3 = Maximum
`Minimum = 0` `Maximum = 50` `Value = 25` `Percentage = 50` `ProgressTextFormat` `{}{0}/{3} Tasks Complete ({1:0}%)` `17/20 Tasks Complete (85%)` Since {0} would appear at the start of the string in this example, it must be escaped.
`{0}` ### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ProgressBar.cs
`ProgressBar.cs` - Useful Properties
- Example
- ProgressTextFormat Example
- More Information
`ProgressTextFormat`
# Popup Controls | Avalonia Docs
- Reference
- Controls Reference
- Popup Controls
## Popup Controls
These controls can be added to other controls to provide popup content.
# PathIcon | Avalonia Docs
- Reference
- Controls Reference
- PathIcon
## PathIcon
The PathIcon control can draw an icon graphic from a stream geometry. For example, you can use the icon geometries from the Avalonia UI Fluent icons resource.
`PathIcon` To see the full list of Fluent icons available with Avalonia UI, see https://avaloniaui.github.io/icons.html
This control is most often used as part of a composition inside another control. For example, to create an icon in a menu or a button.
### Useful Properties​
You will probably use these properties most often:
`Data` `Foreground` ### Example​
```bash
<PathIcon Height="200" Width="200" Foreground="Blue"             Data="{StaticResource building_shop_regular}"/>
```
```bash
<Window.Resources> <StreamGeometry x:Key="building_shop_regular">M17.9999 2C18.1738 2 18.3411 2.06037 18.4742 2.16902L18.5497 2.23991L21.822 5.76824L21.8527 5.80714C21.9544 5.94281 22.0003 6.09665 22.0003 6.24775L21.9988 8.16674C21.9988 9.16092 21.6202 10.0667 20.9994 10.7478L20.9986 21.25C20.9986 21.6297 20.7165 21.9435 20.3504 21.9932L20.2486 22H3.75113C3.37144 22 3.05764 21.7178 3.00798 21.3518L3.00113 21.25L3.00035 10.7478C2.42729 10.1191 2.06067 9.29893 2.00765 8.39453L2.001 8.16674L2.0008 6.29097C1.99273 6.15366 2.02238 6.01238 2.09673 5.88313L2.16199 5.78767L2.20117 5.74193L5.45006 2.23991C5.56833 2.11243 5.7264 2.03081 5.89656 2.00715L5.99989 2H17.9999ZM15.0818 10.4421L15.0699 10.4598C14.371 11.3944 13.2555 11.9993 11.9987 11.9993C10.7349 11.9993 9.61393 11.3876 8.9158 10.4441C8.21835 11.3876 7.0974 11.9993 5.83357 11.9993C5.36446 11.9993 4.91504 11.915 4.49962 11.7608L4.50089 20.499H5.99951L5.99989 13.751C5.99989 13.3713 6.28204 13.0575 6.64812 13.0079L6.74989 13.001H11.2458C11.6255 13.001 11.9393 13.2832 11.989 13.6492L11.9958 13.751L11.9955 20.499H19.4979L19.4981 11.7615C19.0833 11.9153 18.6346 11.9993 18.1662 11.9993C16.9015 11.9993 15.7799 11.3867 15.0818 10.4421ZM10.4949 14.501H7.49989V20.499H10.4949V14.501ZM17.2546 13.001C17.6343 13.001 17.9481 13.2832 17.9978 13.6492L18.0046 13.751V17.253C18.0046 17.6327 17.7225 17.9465 17.3564 17.9962L17.2546 18.003H13.7532C13.3735 18.003 13.0597 17.7209 13.01 17.3548L13.0032 17.253V13.751C13.0032 13.3713 13.2853 13.0575 13.6514 13.0079L13.7532 13.001H17.2546ZM16.5039 14.501H14.5029V16.503H16.5039V14.501ZM8.16589 7.002H3.50089L3.501 8.16674L3.50717 8.33777L3.53555 8.569L3.5683 8.72528L3.61768 8.89726L3.67203 9.0451L3.71271 9.1391C3.74388 9.20697 3.77821 9.27309 3.81551 9.33727L3.91846 9.49873L3.97274 9.57344L4.10151 9.72909L4.24329 9.87318L4.33953 9.95811L4.38162 9.99243C4.69615 10.2429 5.07686 10.4138 5.49329 10.4747L5.67387 10.4939L5.83357 10.4993C7.06813 10.4993 8.07869 9.54019 8.16076 8.32644L8.16614 8.16674L8.16589 7.002ZM14.3309 7.002H9.66589L9.66614 8.16674C9.66614 9.34763 10.5437 10.3236 11.6822 10.478L11.839 10.4939L11.9987 10.4993C13.2333 10.4993 14.2438 9.54019 14.3259 8.32644L14.3313 8.16674L14.3309 7.002ZM20.4979 7.002H15.8329L15.8336 8.16674C15.8336 9.34763 16.7112 10.3236 17.8497 10.478L18.0065 10.4939L18.1662 10.4993C18.7305 10.4993 19.248 10.2989 19.6514 9.96542L19.7412 9.88731L19.857 9.7736L20.0032 9.60441C20.0572 9.53545 20.1075 9.46337 20.1536 9.38849L20.2571 9.20179L20.32 9.06383L20.3783 8.90873L20.4081 8.81314L20.4463 8.66108L20.4747 8.50352L20.4927 8.33678L20.4988 8.16674L20.4979 7.002ZM9.06151 3.499H6.32689L4.46889 5.502H8.44551L9.06151 3.499ZM13.3685 3.499H10.6305L10.0145 5.502H13.9845L13.3685 3.499ZM17.6719 3.499H14.9375L15.5535 5.502H19.5299L17.6719 3.499Z</StreamGeometry></Window.Resources>
```
It works in the preview pane as well:
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub PathIcon.cs
`PathIcon.cs` - Useful Properties
- Example
- More Information
# Panel | Avalonia Docs
- Reference
- Controls Reference
- Panel
## Panel
The panel is the most basic control that can contain multiple child controls. Child controls are drawn according to their horizontal and vertical alignment properties, and in the sequence that they appear in the XAML. Child controls will overlap if they occupy the same space.
For a discussion about using other panels, see here.
### Example​
This example uses some 50% opacities to demonstrate that child controls overlap.
```bash
<Panel Height="300" Width="300">  <Rectangle Fill="Red" Height="100" VerticalAlignment="Top"/>  <Rectangle Fill="Blue" Opacity="0.5" Width="100" HorizontalAlignment="Right" />  <Rectangle Fill="Green" Opacity="0.5" Height="100" VerticalAlignment="Bottom"/>  <Rectangle Fill="Orange" Width="100" HorizontalAlignment="Left"/></Panel>
```
### Other Panel Controls​
There are other more useful panels, that offer better control over the positioning of their child controls:
- Stack Panel
- Dock Panel
- Relative Panel
- Wrap Panel
If you have specific requirements for positioning the child controls in a panel, you can create your own custom control based on the panel.
For instructions about how to create a custom panel control, see here.
### More Information​
For the complete API documentation about this control see here.
View the source code on GitHub Panel.cs
`Panel.cs` - Example
- Other Panel Controls
- More Information
# Panels Overview | Avalonia Docs
- Basics
- User Interface
- Building Layouts
- Panels Overview
## Panels Overview
Panel elements are components that control the rendering of elements - their size and dimensions, their position, and the arrangement of their child content. Avalonia UI provides a number of predefined Panel elements as well as the ability to construct custom Panel elements.
`Panel` `Panel` `Panel` ### The Panel Class​
Panel is the base class for all elements that provide layout support in Avalonia. Derived Panel elements are used to position and arrange elements in XAML and code.
`Panel` `Panel` Avalonia includes a comprehensive suite of derived panel implementations that enable many complex layouts. These derived classes expose properties and methods that enable most standard UI scenarios. Developers who are unable to find a child arrangement behavior that meets their needs can create new layouts by overriding the ArrangeOverride and MeasureOverride methods. For more information on custom layout behaviors, see Create a Custom Panel.
`ArrangeOverride` `MeasureOverride` #### Panel Common Members​
All Panel elements support the base sizing and positioning properties defined by Control, including Height, Width, HorizontalAlignment, VerticalAlignment and Margin. For additional information on positioning properties defined by Control, see Alignment, Margins, and Padding Overview.
`Panel` `Control` `Height` `Width` `HorizontalAlignment` `VerticalAlignment` `Margin` `Control` Panel exposes additional properties that are of critical importance in understanding and using layout. The Background property is used to fill the area between the boundaries of a derived panel element with a Brush. Children represents the child collection of elements that the Panel is comprised of.
`Panel` `Background` `Brush` `Children` `Panel` Attached Properties
Derived panel elements make extensive use of attached properties. An attached property is a specialized form of dependency property that does not have the conventional common language runtime (CLR) property "wrapper". Attached properties have a specialized syntax in XAML, which can be seen in several of the examples that follow.
One purpose of an attached property is to allow child elements to store unique values of a property that is actually defined by a parent element. An application of this functionality is having child elements inform the parent how they wish to be presented in the UI, which is extremely useful for application layout.
#### User Interface Panels​
There are several panel classes available in Avalonia that are optimized to support UI scenarios: Panel, Canvas, DockPanel, Grid, StackPanel, WrapPanel and RelativePanel. These panel elements are easy to use, versatile, and extensible enough for most applications.
`Panel` `Canvas` `DockPanel` `Grid` `StackPanel` `WrapPanel` `RelativePanel` ### Canvas​
The Canvas element enables positioning of content according to absolute x- and y- coordinates. Elements can be drawn in a unique location; or, if elements occupy the same coordinates, the order in which they appear in markup determines the order in which the elements are drawn.
`Canvas` Canvas provides the most flexible layout support of any Panel. Height and Width properties are used to define the area of the canvas, and elements inside are assigned absolute coordinates relative to the area of the parent Canvas. Four attached properties, Canvas.Left, Canvas.Top, Canvas.Right and Canvas.Bottom, allow fine control of object placement within a Canvas, allowing the developer to position and arrange elements precisely on the screen.
`Canvas` `Panel` `Canvas` `Canvas.Left` `Canvas.Top` `Canvas.Right` `Canvas.Bottom` `Canvas` #### ClipToBounds Within a Canvas​
Canvas can position child elements at any position on the screen, even at coordinates that are outside of its own defined Height and Width. Furthermore, Canvas is not affected by the size of its children. As a result, it is possible for a child element to overdraw other elements outside the bounding rectangle of the parent Canvas. The default behavior of a Canvas is to allow children to be drawn outside the bounds of the parent Canvas. If this behavior is undesirable, the ClipToBounds property can be set to true. This causes Canvas to clip to its own size. Canvas is the only layout element that allows children to be drawn outside its bounds.
`Canvas` `Height` `Width` `Canvas` `Canvas` `Canvas` `Canvas` `ClipToBounds` `true` `Canvas` `Canvas` #### Defining and Using a Canvas​
A Canvas can be instantiated simply by using XAML or code. The following example demonstrates how to use Canvas to absolutely position content. This code produces three 100-pixel squares. The first square is red, and its top-left (x, y) position is specified as (0, 0). The second square is green, and its top-left position is (100, 100), just below and to the right of the first square. The third square is blue, and its top-left position is (50, 50), thus encompassing the lower-right quadrant of the first square and the upper-left quadrant of the second. Because the third square is laid out last, it appears to be on top of the other two squares—that is, the overlapping portions assume the color of the third box.
`Canvas` `Canvas` ![StackPanel Example](https://docs.avaloniaui.net/assets/images/canvas-example-df3203375b53aa0d367ef27a5429708d.png)
- XAML
- C#
```bash
<Canvas Height="400" Width="400"> <Canvas Height="100" Width="100" Top="0" Left="0" Background="Red"/> <Canvas Height="100" Width="100" Top="100" Left="100" Background="Green"/> <Canvas Height="100" Width="100" Top="50" Left="50" Background="Blue"/></Canvas>
```
```bash
// Create the CanvasmyParentCanvas = new Canvas();myParentCanvas.Width = 400;myParentCanvas.Height = 400;// Define child Canvas elementsmyCanvas1 = new Canvas();myCanvas1.Background = Brushes.Red;myCanvas1.Height = 100;myCanvas1.Width = 100;Canvas.SetTop(myCanvas1, 0);Canvas.SetLeft(myCanvas1, 0);myCanvas2 = new Canvas();myCanvas2.Background = Brushes.Green;myCanvas2.Height = 100;myCanvas2.Width = 100;Canvas.SetTop(myCanvas2, 100);Canvas.SetLeft(myCanvas2, 100);myCanvas3 = new Canvas();myCanvas3.Background = Brushes.Blue;myCanvas3.Height = 100;myCanvas3.Width = 100;Canvas.SetTop(myCanvas3, 50);Canvas.SetLeft(myCanvas3, 50);// Add child elements to the Canvas' Children collectionmyParentCanvas.Children.Add(myCanvas1);myParentCanvas.Children.Add(myCanvas2);myParentCanvas.Children.Add(myCanvas3);
```
### DockPanel​
The DockPanel element uses the DockPanel.Dock attached property as set in child content elements to position content along the edges of a container. When DockPanel.Dock is set to Top or Bottom, it positions child elements above or below each other. When DockPanel.Dock is set to Left or Right, it positions child elements to the left or right of each other. The LastChildFill property determines the position of the final element added as a child of a DockPanel.
`DockPanel` `DockPanel.Dock` `DockPanel.Dock` `Top` `Bottom` `DockPanel.Dock` `Left` `Right` `LastChildFill` `DockPanel` You can use DockPanel to position a group of related controls, such as a set of buttons. Alternately, you can use it to create a "paned" UI.
`DockPanel` #### Sizing to Content​
If its Height and Width properties are not specified, DockPanel sizes to its content. The size can increase or decrease to accommodate the size of its child elements. However, when these properties are specified and there is no longer room for the next specified child element, DockPanel does not display that child element or subsequent child elements and does not measure subsequent child elements.
`Height` `Width` `DockPanel` `DockPanel` #### LastChildFill​
By default, the last child of a DockPanel element will "fill" the remaining, unallocated space. If this behavior is not desired, set the LastChildFill property to false.
`DockPanel` `LastChildFill` `false` #### Defining and Using a DockPanel​
The following example demonstrates how to partition space using a DockPanel. Five Border elements are added as children of a parent DockPanel. Each uses a different positioning property of a DockPanel to partition space. The final element "fills" the remaining, unallocated space.
`DockPanel` `Border` `DockPanel` `DockPanel` ![StackPanel Example](https://docs.avaloniaui.net/assets/images/dockpanel-example-bf264057f90bd22b0c8dcb67f678020c.png)
- XAML
- C#
```bash
<DockPanel LastChildFill="True"> <Border Height="25" Background="SkyBlue" BorderBrush="Black" BorderThickness="1" DockPanel.Dock="Top">  <TextBlock Foreground="Black">Dock = "Top"</TextBlock> </Border> <Border Height="25" Background="SkyBlue" BorderBrush="Black" BorderThickness="1" DockPanel.Dock="Top">  <TextBlock Foreground="Black">Dock = "Top"</TextBlock> </Border> <Border Height="25" Background="LemonChiffon" BorderBrush="Black" BorderThickness="1" DockPanel.Dock="Bottom">  <TextBlock Foreground="Black">Dock = "Bottom"</TextBlock> </Border> <Border Width="200" Background="PaleGreen" BorderBrush="Black" BorderThickness="1" DockPanel.Dock="Left">  <TextBlock Foreground="Black">Dock = "Left"</TextBlock> </Border> <Border Background="White" BorderBrush="Black" BorderThickness="1">  <TextBlock Foreground="Black">This content will "Fill" the remaining space</TextBlock> </Border></DockPanel>
```
```bash
// Create the DockPanelDockPanel myDockPanel = new DockPanel();myDockPanel.LastChildFill = true;// Define the child contentBorder myBorder1 = new Border();myBorder1.Height = 25;myBorder1.Background = Brushes.SkyBlue;myBorder1.BorderBrush = Brushes.Black;myBorder1.BorderThickness = new Thickness(1);DockPanel.SetDock(myBorder1, Dock.Top);TextBlock myTextBlock1 = new TextBlock();myTextBlock1.Foreground = Brushes.Black;myTextBlock1.Text = "Dock = Top";myBorder1.Child = myTextBlock1;Border myBorder2 = new Border();myBorder2.Height = 25;myBorder2.Background = Brushes.SkyBlue;myBorder2.BorderBrush = Brushes.Black;myBorder2.BorderThickness = new Thickness(1);DockPanel.SetDock(myBorder2, Dock.Top);TextBlock myTextBlock2 = new TextBlock();myTextBlock2.Foreground = Brushes.Black;myTextBlock2.Text = "Dock = Top";myBorder2.Child = myTextBlock2;Border myBorder3 = new Border();myBorder3.Height = 25;myBorder3.Background = Brushes.LemonChiffon;myBorder3.BorderBrush = Brushes.Black;myBorder3.BorderThickness = new Thickness(1);DockPanel.SetDock(myBorder3, Dock.Bottom);TextBlock myTextBlock3 = new TextBlock();myTextBlock3.Foreground = Brushes.Black;myTextBlock3.Text = "Dock = Bottom";myBorder3.Child = myTextBlock3;Border myBorder4 = new Border();myBorder4.Width = 200;myBorder4.Background = Brushes.PaleGreen;myBorder4.BorderBrush = Brushes.Black;myBorder4.BorderThickness = new Thickness(1);DockPanel.SetDock(myBorder4, Dock.Left);TextBlock myTextBlock4 = new TextBlock();myTextBlock4.Foreground = Brushes.Black;myTextBlock4.Text = "Dock = Left";myBorder4.Child = myTextBlock4;Border myBorder5 = new Border();myBorder5.Background = Brushes.White;myBorder5.BorderBrush = Brushes.Black;myBorder5.BorderThickness = new Thickness(1);TextBlock myTextBlock5 = new TextBlock();myTextBlock5.Foreground = Brushes.Black;myTextBlock5.Text = "This content will Fill the remaining space";myBorder5.Child = myTextBlock5;// Add child elements to the DockPanel Children collectionmyDockPanel.Children.Add(myBorder1);myDockPanel.Children.Add(myBorder2);myDockPanel.Children.Add(myBorder3);myDockPanel.Children.Add(myBorder4);myDockPanel.Children.Add(myBorder5);
```
### Grid​
The Grid element merges the functionality of an absolute positioning and tabular data control. A Grid enables you to easily position and style elements. Grid allows you to define flexible row and column groupings, and even provides a mechanism to share sizing information between multiple Grid elements.
`Grid` `Grid` `Grid` `Grid` #### Sizing Behavior of Columns and Rows​
Columns and rows defined within a Grid can take advantage of Star sizing in order to distribute remaining space proportionally. When Star is selected as the Height or Width of a row or column, that column or row receives a weighted proportion of remaining available space. This is in contrast to Auto, which will distribute space evenly based on the size of the content within a column or row. This value is expressed as * or 2* when using XAML. In the first case, the row or column would receive one times the available space, in the second case, two times, and so on. By combining this technique to proportionally distribute space with a HorizontalAlignment and VerticalAlignment value of Stretch it is possible to partition layout space by percentage of screen space. Grid is the only layout panel that can distribute space in this manner.
`Grid` `Star` `Star` `Auto` `*` `2*` `HorizontalAlignment` `VerticalAlignment` `Stretch` `Grid` #### Defining and Using a Grid​
The following example demonstrates how to build a UI similar to that found on the Run dialog available on the Windows Start menu.
- XAML
- C#
```bash
<Grid Background="Gainsboro"    HorizontalAlignment="Left"    VerticalAlignment="Top"    Width="425"    Height="165"   ColumnDefinitions="Auto,*,*,*,*"   RowDefinitions="Auto,Auto,*,Auto">    <Image Grid.Row="0" Grid.Column="0" Source="{Binding runicon}" />    <TextBlock Grid.Row="0" Grid.Column="1" Grid.ColumnSpan="4"        Text="Type the name of a program, folder, document, or Internet resource, and Windows will open it for you."        TextWrapping="Wrap" />          <TextBlock Grid.Row="1" Grid.Column="0" Text="Open:" />    <TextBox Grid.Row="1" Grid.Column="1" Grid.ColumnSpan="5" />    <Button Grid.Row="3" Grid.Column="2" Content="OK" Margin="10,0,10,15" />    <Button Grid.Row="3" Grid.Column="3" Content="Cancel" Margin="10,0,10,15" />    <Button Grid.Row="3" Grid.Column="4" Content="Browse ..." Margin="10,0,10,15" /></Grid>
```
```bash
// Create the Grid.grid1 = new Grid ();grid1.Background = Brushes.Gainsboro;grid1.HorizontalAlignment = HorizontalAlignment.Left;grid1.VerticalAlignment = VerticalAlignment.Top;grid1.ShowGridLines = true;grid1.Width = 425;grid1.Height = 165;// Define the Columns.colDef1 = new ColumnDefinition();colDef1.Width = new GridLength(1, GridUnitType.Auto);colDef2 = new ColumnDefinition();colDef2.Width = new GridLength(1, GridUnitType.Star);colDef3 = new ColumnDefinition();colDef3.Width = new GridLength(1, GridUnitType.Star);colDef4 = new ColumnDefinition();colDef4.Width = new GridLength(1, GridUnitType.Star);colDef5 = new ColumnDefinition();colDef5.Width = new GridLength(1, GridUnitType.Star);grid1.ColumnDefinitions.Add(colDef1);grid1.ColumnDefinitions.Add(colDef2);grid1.ColumnDefinitions.Add(colDef3);grid1.ColumnDefinitions.Add(colDef4);grid1.ColumnDefinitions.Add(colDef5);// Define the Rows.rowDef1 = new RowDefinition();rowDef1.Height = new GridLength(1, GridUnitType.Auto);rowDef2 = new RowDefinition();rowDef2.Height = new GridLength(1, GridUnitType.Auto);rowDef3 = new RowDefinition();rowDef3.Height = new GridLength(1, GridUnitType.Star);rowDef4 = new RowDefinition();rowDef4.Height = new GridLength(1, GridUnitType.Auto);grid1.RowDefinitions.Add(rowDef1);grid1.RowDefinitions.Add(rowDef2);grid1.RowDefinitions.Add(rowDef3);grid1.RowDefinitions.Add(rowDef4);// Add the Image.img1 = new Image();img1.Source = runicon;Grid.SetRow(img1, 0);Grid.SetColumn(img1, 0);// Add the main application dialog.txt1 = new TextBlock();txt1.Text = "Type the name of a program, folder, document, or Internet resource, and Windows will open it for you.";txt1.TextWrapping = TextWrapping.Wrap;Grid.SetColumnSpan(txt1, 4);Grid.SetRow(txt1, 0);Grid.SetColumn(txt1, 1);// Add the second text cell to the Grid.txt2 = new TextBlock();txt2.Text = "Open:";Grid.SetRow(txt2, 1);Grid.SetColumn(txt2, 0);// Add the TextBox control.tb1 = new TextBox();Grid.SetRow(tb1, 1);Grid.SetColumn(tb1, 1);Grid.SetColumnSpan(tb1, 5);// Add the buttons.button1 = new Button();button2 = new Button();button3 = new Button();button1.Content = "OK";button2.Content = "Cancel";button3.Content = "Browse ...";Grid.SetRow(button1, 3);Grid.SetColumn(button1, 2);button1.Margin = new Thickness(10, 0, 10, 15);button2.Margin = new Thickness(10, 0, 10, 15);button3.Margin = new Thickness(10, 0, 10, 15);Grid.SetRow(button2, 3);Grid.SetColumn(button2, 3);Grid.SetRow(button3, 3);Grid.SetColumn(button3, 4);grid1.Children.Add(img1);grid1.Children.Add(txt1);grid1.Children.Add(txt2);grid1.Children.Add(tb1);grid1.Children.Add(button1);grid1.Children.Add(button2);grid1.Children.Add(button3);
```
### StackPanel​
A StackPanel enables you to "stack" elements in an assigned direction. The default stack direction is vertical. The Orientation property can be used to control content flow.
`StackPanel` `Orientation` #### StackPanel vs. DockPanel​
Although DockPanel can also "stack" child elements, DockPanel and StackPanel do not produce analogous results in some usage scenarios. For example, the order of child elements can affect their size in a DockPanel but not in a StackPanel. This is because StackPanel measures in the direction of stacking at PositiveInfinity, whereas DockPanel measures only the available size.
`DockPanel` `DockPanel` `StackPanel` `DockPanel` `StackPanel` `StackPanel` `PositiveInfinity` `DockPanel` #### Defining and Using a StackPanel​
The following example demonstrates how to use a StackPanel to create a set of vertically-positioned buttons. For horizontal positioning, set the Orientation property to Horizontal.
`StackPanel` `Orientation` `Horizontal` ![StackPanel Example](https://docs.avaloniaui.net/assets/images/stackpanel-example-834f32cd3a6447a93aa9a8681fb74e1e.png)
- XAML
- C#
```bash
<StackPanel HorizontalAlignment="Center"         VerticalAlignment="Top"        Spacing="25">    <Button Content="Button 1" />    <Button Content="Button 2" />    <Button Content="Button 3" />  </StackPanel>
```
```bash
// Define the StackPanelmyStackPanel = new StackPanel();myStackPanel.HorizontalAlignment = HorizontalAlignment.Center;myStackPanel.VerticalAlignment = VerticalAlignment.Top;myStackPanel.Spacing = 25;// Define child contentButton myButton1 = new Button();myButton1.Content = "Button 1";Button myButton2 = new Button();myButton2.Content = "Button 2";Button myButton3 = new Button();myButton3.Content = "Button 3";// Add child elements to the parent StackPanelmyStackPanel.Children.Add(myButton1);myStackPanel.Children.Add(myButton2);myStackPanel.Children.Add(myButton3);
```
### WrapPanel​
WrapPanel is used to position child elements in sequential position from left to right, breaking content to the next line when it reaches the edge of its parent container. Content can be oriented horizontally or vertically. WrapPanel is useful for simple flowing UI scenarios. It can also be used to apply uniform sizing to all of its child elements.
`WrapPanel` `WrapPanel` The following example demonstrates how to create a WrapPanel to display Button controls that wrap when they reach the edge of their container.
`WrapPanel` `Button` ![StackPanel Example](https://docs.avaloniaui.net/assets/images/wrappanel-example-d7e5811bf930f96b38d502d9b714221c.png)
- XAML
- C#
```bash
<Border HorizontalAlignment="Left" VerticalAlignment="Top" BorderBrush="Black" BorderThickness="2"> <WrapPanel Background="LightBlue" Width="200" Height="100">  <Button Width="200">Button 1</Button>  <Button>Button 2</Button>  <Button>Button 3</Button>  <Button>Button 4</Button> </WrapPanel></Border>
```
```bash
// Instantiate a new WrapPanel and set propertiesmyWrapPanel = new WrapPanel();myWrapPanel.Background = System.Windows.Media.Brushes.Azure;myWrapPanel.Orientation = Orientation.Horizontal;myWrapPanel.Width = 200;myWrapPanel.HorizontalAlignment = HorizontalAlignment.Left;myWrapPanel.VerticalAlignment = VerticalAlignment.Top;// Define 3 button elements. The last three buttons are sized at width // of 75, so the forth button wraps to the next line.btn1 = new Button();btn1.Content = "Button 1";btn1.Width = 200;btn2 = new Button();btn2.Content = "Button 2";btn2.Width = 75;btn3 = new Button();btn3.Content = "Button 3";btn3.Width = 75;btn4 = new Button();btn4.Content = "Button 4";btn4.Width = 75;// Add the buttons to the parent WrapPanel using the Children.Add method.myWrapPanel.Children.Add(btn1);myWrapPanel.Children.Add(btn2);myWrapPanel.Children.Add(btn3);myWrapPanel.Children.Add(btn4);
```
#### Nested Panel Elements​
Panel elements can be nested within each other in order to produce complex layouts. This can prove very useful in situations where one Panel is ideal for a portion of a UI, but may not meet the needs of a different portion of the UI.
`Panel` `Panel` There is no practical limit to the amount of nesting that your application can support, however, it is generally best to limit your application to only use those panels that are actually necessary for your desired layout. In many cases, a Grid element can be used instead of nested panels due to its flexibility as a layout container. This can increase performance in your application by keeping unnecessary elements out of the tree.
`Grid` ### UniformGrid​
The UniformGrid is a type of Panel that provides uniform grid layout. This means that it lays out its children in a grid where all cells in the grid have the same size. Unlike the standard Grid, UniformGrid doesn't support explicit rows and columns, nor does it provide the Grid.Row or Grid.Column attached properties.
`UniformGrid` `Grid` `UniformGrid` `Grid.Row` `Grid.Column` The primary use case for a UniformGrid is when you need to display a collection of items in a grid format where each item takes up an equal amount of space.
`UniformGrid` #### UniformGrid Properties​
- Rows and Columns: The UniformGrid uses the Rows and Columns properties to determine the layout of its child elements. If you only set one of these properties, the UniformGrid will automatically calculate the other to create a grid that fits the total number of child elements. If you don't set either property, the UniformGrid defaults to a 1x1 grid.
`UniformGrid` `Rows` `Columns` `UniformGrid` `UniformGrid` For example, if you have 12 items and set Rows to 3, the UniformGrid will automatically create 4 columns. If you set Columns to 4, it will automatically create 3 rows.
`Rows` `UniformGrid` `Columns` - FirstColumn: TheFirstColumn property allows you to leave a certain number of cells empty in the first row of the grid.
`FirstColumn` #### Defining and Using a UniformGrid​
The following example demonstrates how to define and use a UniformGrid. The example creates a UniformGrid with 3 rows and 4 columns and adds 12 rectangles as child elements.
`UniformGrid` `UniformGrid` ![StackPanel Example](https://docs.avaloniaui.net/assets/images/uniformgrid-example-1769081f4174f313a249ebbb45097ef9.png)
- XAML
- C#
```bash
<UniformGrid Rows="3" Columns="4"> <Rectangle Width="50" Height="50" Fill="#330000"/> <Rectangle Width="50" Height="50" Fill="#660000"/> <Rectangle Width="50" Height="50" Fill="#990000"/> <Rectangle Width="50" Height="50" Fill="#CC0000"/> <Rectangle Width="50" Height="50" Fill="#FF0000"/> <Rectangle Width="50" Height="50" Fill="#FF3300"/> <Rectangle Width="50" Height="50" Fill="#FF6600"/> <Rectangle Width="50" Height="50" Fill="#FF9900"/> <Rectangle Width="50" Height="50" Fill="#FFCC00"/> <Rectangle Width="50" Height="50" Fill="#FFFF00"/> <Rectangle Width="50" Height="50" Fill="#FFFF33"/> <Rectangle Width="50" Height="50" Fill="#FFFF66"/></UniformGrid>
```
```bash
// Create the UniformGridUniformGrid myUniformGrid = new UniformGrid();myUniformGrid.Rows = 3;myUniformGrid.Columns = 4;// Define the child contentfor (int i = 0; i < 12; i++){  Rectangle myRectangle = new Rectangle();  myRectangle.Fill = new SolidColorBrush(Color.FromRgb((byte)(i * 20), 0, 0));  myRectangle.Width = 50;  myRectangle.Height = 50;  myUniformGrid.Children.Add(myRectangle);}
```
In the above example, each Rectangle is automatically assigned to a cell in the grid in the order they were added.
`Rectangle` - The Panel ClassPanel Common MembersUser Interface Panels
- Panel Common Members
- User Interface Panels
- CanvasClipToBounds Within a CanvasDefining and Using a Canvas
- ClipToBounds Within a Canvas
- Defining and Using a Canvas
- DockPanelSizing to ContentLastChildFillDefining and Using a DockPanel
- Sizing to Content
- LastChildFill
- Defining and Using a DockPanel
- GridSizing Behavior of Columns and RowsDefining and Using a Grid
- Sizing Behavior of Columns and Rows
- Defining and Using a Grid
- StackPanelStackPanel vs. DockPanelDefining and Using a StackPanel
- StackPanel vs. DockPanel
- Defining and Using a StackPanel
- WrapPanelNested Panel Elements
- Nested Panel Elements
- UniformGridUniformGrid PropertiesDefining and Using a UniformGrid
- UniformGrid Properties
- Defining and Using a UniformGrid
- Panel Common Members
- User Interface Panels
- ClipToBounds Within a Canvas
- Defining and Using a Canvas
- Sizing to Content
- LastChildFill
- Defining and Using a DockPanel
- Sizing Behavior of Columns and Rows
- Defining and Using a Grid
- StackPanel vs. DockPanel
- Defining and Using a StackPanel
- Nested Panel Elements
- UniformGrid Properties
- Defining and Using a UniformGrid
# Layout | Avalonia Docs
- Basics
- User Interface
- Building Layouts
## Layout
### Panels​
Avalonia includes a group of elements that derive from Panel. These Panel elements enable many complex layouts. For example, stacking elements can easily be achieved by using the StackPanel element, while more complex and free flowing layouts are possible by using a Canvas.
`Panel` `Panel` `StackPanel` `Canvas` The following table summarizes the available Panel controls:
`Panel` `Panel` `Panel` `Canvas` `DockPanel` `Grid` `RelativePanel` `StackPanel` `WrapPanel` In WPF, Panel is an abstract class and laying out multiple controls to fill the available space is usually done with a Grid with no rows/columns. In Avalonia Panel is a usable control that has the same layout behavior as a Grid with no rows/columns, but with a lighter runtime footprint.
`Panel` `Grid` `Panel` `Grid` ### Element Bounding Boxes​
When thinking about layout in Avalonia, it is important to understand the bounding box that surrounds all elements. Each Control consumed by the layout system can be thought of as a rectangle that is slotted into the layout. The Bounds property returns the boundaries of an element's layout allocation. The size of the rectangle is determined by calculating the available screen space, the size of any constraints, layout-specific properties (such as margin and padding), and the individual behavior of the parent Panel element. Processing this data, the layout system is able to calculate the position of all the children of a particular Panel. It is important to remember that sizing characteristics defined on the parent element, such as a Border, affect its children.
`Control` `Bounds` `Panel` `Panel` `Border` ### The Layout System​
At its simplest, layout is a recursive system that leads to an element being sized, positioned, and drawn. More specifically, layout describes the process of measuring and arranging the members of a Panel element's Children collection. Layout is an intensive process. The larger the Children collection, the greater the number of calculations that must be made. Complexity can also be introduced based on the layout behavior defined by the Panel element that owns the collection. A relatively simple Panel, such as Canvas, can have significantly better performance than a more complex Panel, such as Grid.
`Panel` `Children` `Children` `Panel` `Panel` `Canvas` `Panel` `Grid` Each time that a child control changes its position, it has the potential to trigger a new pass by the layout system. Therefore, it is important to understand the events that can invoke the layout system, as unnecessary invocation can lead to poor application performance. The following describes the process that occurs when the layout system is invoked.
- A child UIElement begins the layout process by first having its core properties measured.
- Sizing properties defined on Control are evaluated, such as Width, Height, and Margin.
- Panel-specific logic is applied, such as Dock direction or stacking Orientation.
- Content is arranged after all children have been measured.
- The Children collection is drawn on the screen.
- The process is invoked again if additional Children are added to the collection
`Control` `Width` `Height` `Margin` `Panel` `Dock` `Orientation` `Children` `Children` This process and how it is invoked are defined in more detail in the following sections.
### Measuring and Arranging Children​
The layout system completes two passes for each member of the Children collection, a measure pass and an arrange pass. Each child Panel provides its own MeasureOverride and ArrangeOverride methods to achieve its own specific layout behavior.
`Children` `Panel` `MeasureOverride` `ArrangeOverride` During the measure pass, each member of the Children collection is evaluated. The process begins with a call to the Measure method. This method is called within the implementation of the parent Panel element, and does not have to be called explicitly for layout to occur.
`Children` `Measure` `Panel` First, native size properties of the Visual such as Clip and IsVisible are evaluated. This generates a constraint that is passed to MeasureCore.
`Visual` `Clip` `IsVisible` `MeasureCore` First, framework properties which affects the value of the constraint are processed. These properties generally describe the sizing characteristics of the underlying Control, such as its Height, Width and Margin. Each of these properties can change the space that is necessary to display the element. MeasureOverride is then called with the constraint as a parameter.
`Control` `Height` `Width` `Margin` `MeasureOverride` Because Bounds is a calculated value, you should be aware that there could be multiple or incremental reported changes to it as a result of various operations by the layout system. The layout system may be calculating required measure space for child elements, constraints by the parent element, and so on.
`Bounds` The ultimate goal of the measure pass is for the child to determine its DesiredSize, which occurs during the MeasureCore call. The DesiredSize value is stored by Measure for use during the content arrange pass.
`DesiredSize` `MeasureCore` `DesiredSize` `Measure` The arrange pass begins with a call to the Arrange method. During the arrange pass, the parent Panel element generates a rectangle that represents the bounds of the child. This value is passed to the ArrangeCore method for processing.
`Arrange` `Panel` `ArrangeCore` The ArrangeCore method evaluates the DesiredSize of the child and evaluates any additional margins that may affect the rendered size of the element. ArrangeCore generates an arrange size, which is passed to the ArrangeOverride method of the Panel as a parameter. ArrangeOverride generates the finalSize of the child. Finally, the ArrangeCore method does a final evaluation of offset properties, such as margin and alignment, and puts the child within its layout slot. The child does not have to (and frequently does not) fill the entire allocated space. Control is then returned to the parent Panel and the layout process is complete.
`ArrangeCore` `DesiredSize` `ArrangeCore` `ArrangeOverride` `Panel` `ArrangeOverride` `ArrangeCore` `Panel` ### In This Section​
- Panels Overview
- Alignment, Margins and Padding
- Create a Custom Panel
- Panels
- Element Bounding Boxes
- The Layout System
- Measuring and Arranging Children
- In This Section
# Alignment, Margins and Padding | Avalonia Docs
- Basics
- User Interface
- Building Layouts
- Alignment, Margins and Padding
## Alignment, Margins and Padding
An Avalonia control exposes several properties that are used to precisely position child elements. This topic discusses four of the most important properties: HorizontalAlignment, Margin, Padding, and VerticalAlignment. The effects of these properties are important to understand, because they provide the basis for controlling the position of elements in Avalonia applications.
`HorizontalAlignment` `Margin` `Padding` `VerticalAlignment` #### Introduction to Element Positioning​
There are numerous ways to position elements using Avalonia. However, achieving ideal layout goes beyond simply choosing the right Panel element. Fine control of positioning requires an understanding of the HorizontalAlignment, Margin, Padding, and VerticalAlignment properties.
`Panel` `HorizontalAlignment` `Margin` `Padding` `VerticalAlignment` The following illustration shows a layout scenario that utilizes several positioning properties.
At first glance, the Button elements in this illustration may appear to be placed randomly. However, their positions are actually precisely controlled by using a combination of margins, alignments, and padding.
`Button` The following example describes how to create the layout in the preceding illustration. A Border element encapsulates a parent StackPanel, with a Padding value of 15 device independent pixels. This accounts for the narrow LightBlue band that surrounds the child StackPanel. Child elements of the StackPanel are used to illustrate each of the various positioning properties that are detailed in this topic. Three Button elements are used to demonstrate both the Margin and HorizontalAlignment properties.
`Border` `StackPanel` `Padding` `LightBlue` `StackPanel` `StackPanel` `Button` `Margin` `HorizontalAlignment` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    x:Class="AvaloniaApplication2.MainWindow"    Title="AvaloniaApplication2"> <Border Background="LightBlue"     BorderBrush="Black"     BorderThickness="2"     Padding="15">  <StackPanel Background="White"        HorizontalAlignment="Center"        VerticalAlignment="Top">   <TextBlock Margin="5,0"         FontSize="18"         HorizontalAlignment="Center">    Alignment, Margin and Padding Sample   </TextBlock>   <Button HorizontalAlignment="Left" Margin="20">Button 1</Button>   <Button HorizontalAlignment="Right" Margin="10">Button 2</Button>   <Button HorizontalAlignment="Stretch">Button 3</Button>  </StackPanel> </Border></Window>
```
The following diagram provides a close-up view of the various positioning properties that are used in the preceding sample. Subsequent sections in this topic describe in greater detail how to use each positioning property.
![Positioning Properties](https://docs.avaloniaui.net/assets/images/layout-margins-padding-alignment-graphic2-015458f53372042c3a40678d75bc0a6d.png)
#### Understanding Alignment Properties​
The HorizontalAlignment and VerticalAlignment properties describe how a child element should be positioned within a parent element's allocated layout space. By using these properties together, you can position child elements precisely. For example, child elements of a DockPanel can specify four different horizontal alignments: Left, Right, Center, or to Stretch to fill available space. Similar values are available for vertical positioning.
`HorizontalAlignment` `VerticalAlignment` `DockPanel` `Left` `Right` `Center` `Stretch` Explicitly set Height and Width properties on an element take precedence over the Stretch property value. Attempting to set Height, Width, and a HorizontalAlignment value of Stretch results in the Stretch request being ignored.
`Height` `Width` `Stretch` `Height` `Width` `HorizontalAlignment` `Stretch` `Stretch` ##### HorizontalAlignment Property​
The HorizontalAlignment property declares the horizontal alignment characteristics to apply to child elements. The following table shows each of the possible values of the HorizontalAlignment property.
`HorizontalAlignment` `HorizontalAlignment` `Left` `Center` `Right` `Stretch` `Width` `Height` The following example shows how to apply the HorizontalAlignment property to Button elements. Each attribute value is shown, to better illustrate the various rendering behaviors.
`HorizontalAlignment` `Button` ```bash
<Button HorizontalAlignment="Left">Button 1 (Left)</Button><Button HorizontalAlignment="Right">Button 2 (Right)</Button><Button HorizontalAlignment="Center">Button 3 (Center)</Button><Button HorizontalAlignment="Stretch">Button 4 (Stretch)</Button>
```
The preceding code yields a layout similar to the following image. The positioning effects of each HorizontalAlignment value are visible in the illustration.
`HorizontalAlignment` ##### VerticalAlignment Property​
The VerticalAlignment property describes the vertical alignment characteristics to apply to child elements. The following table shows each of the possible values for the VerticalAlignment property.
`VerticalAlignment` `VerticalAlignment` `Top` `Center` `Bottom` `Stretch` `Width` `Height` The following example shows how to apply the VerticalAlignment property to Button elements. Each attribute value is shown, to better illustrate the various rendering behaviors. For purposes of this sample, a Grid element with visible gridlines is used as the parent, to better illustrate the layout behavior of each property value.
`VerticalAlignment` `Button` `Grid` ```bash
<Border Background="LightBlue" BorderBrush="Black" BorderThickness="2" Padding="15">  <Grid Background="White" ShowGridLines="True">   <Grid.RowDefinitions>    <RowDefinition Height="25"/>    <RowDefinition Height="50"/>    <RowDefinition Height="50"/>    <RowDefinition Height="50"/>    <RowDefinition Height="50"/>   </Grid.RowDefinitions>   <TextBlock Grid.Row="0" Grid.Column="0"         FontSize="18"         HorizontalAlignment="Center">    VerticalAlignment Sample   </TextBlock>   <Button Grid.Row="1" Grid.Column="0" VerticalAlignment="Top">Button 1 (Top)</Button>   <Button Grid.Row="2" Grid.Column="0" VerticalAlignment="Bottom">Button 2 (Bottom)</Button>   <Button Grid.Row="3" Grid.Column="0" VerticalAlignment="Center">Button 3 (Center)</Button>   <Button Grid.Row="4" Grid.Column="0" VerticalAlignment="Stretch">Button 4 (Stretch)</Button>  </Grid></Border>
```
The preceding code yields a layout similar to the following image. The positioning effects of each VerticalAlignment value are visible in the illustration.
`VerticalAlignment` #### Understanding Margin Properties​
The Margin property describes the distance between an element and its child or peers. Margin values can be uniform, by using syntax like Margin="20". With this syntax, a uniform Margin of 20 device independent pixels would be applied to the element. Margin values can also take the form of four distinct values, each value describing a distinct margin to apply to the left, top, right, and bottom (in that order), like Margin="0,10,5,25". Proper use of the Margin property enables very fine control of an element's rendering position and the rendering position of its neighbor elements and children.
`Margin` `Margin` `Margin="20"` `Margin` `Margin` `Margin="0,10,5,25"` `Margin` A non-zero margin applies space outside the element's Bounds.
`Bounds` The following example shows how to apply uniform margins around a group of Button elements. The Button elements are spaced evenly with a ten-pixel margin buffer in each direction.
`Button` `Button` ```bash
<Button Margin="10">Button 7</Button><Button Margin="10">Button 8</Button><Button Margin="10">Button 9</Button>
```
In many instances, a uniform margin is not appropriate. In these cases, non-uniform spacing can be applied. The following example shows how to apply non-uniform margin spacing to child elements. Margins are described in this order: left, top, right, bottom.
```bash
<Button Margin="0,10,0,10">Button 1</Button><Button Margin="0,10,0,10">Button 2</Button><Button Margin="0,10,0,10">Button 3</Button>
```
##### Understanding the Padding Property​
Padding is similar to Margin in most respects. The Padding property is exposed on only on a few classes, primarily as a convenience: Border, TemplatedControl, and TextBlock are samples of classes that expose a Padding property. The Padding property enlarges the effective size of a child element by the specified Thickness value.
`Margin` `Border` `TemplatedControl` `TextBlock` `Padding` `Thickness` The following example shows how to apply Padding to a parent Border element.
`Padding` `Border` ```bash
<Border Background="LightBlue"    BorderBrush="Black"    BorderThickness="2"    CornerRadius="45"    Padding="25">
```
##### Using Alignment, Margins, and Padding in an Application​
HorizontalAlignment, Margin, Padding, and VerticalAlignment provide the positioning control necessary to create a complex UI. You can use the effects of each property to change child-element positioning, enabling flexibility in creating dynamic applications and user experiences.
`HorizontalAlignment` `Margin` `Padding` `VerticalAlignment` The following example demonstrates each of the concepts that are detailed in this topic. Building on the infrastructure found in the first sample in this topic, this example adds aGrid element as a child of the Border in the first sample. Padding is applied to the parent Border element. TheGrid is used to partition space between three child StackPanel elements. Button elements are again used to show the various effects of Margin and HorizontalAlignment. TextBlock elements are added to each ColumnDefinition to better define the various properties applied to the Button elements in each column.
`Grid` `Border` `Padding` `Border` `Grid` `StackPanel` `Button` `Margin` `HorizontalAlignment` `TextBlock` `ColumnDefinition` `Button` ```bash
<Border Background="LightBlue"    BorderBrush="Black"    BorderThickness="2"    CornerRadius="45"    Padding="25">  <Grid Background="White" ShowGridLines="True">   <Grid.ColumnDefinitions>    <ColumnDefinition Width="Auto"/>    <ColumnDefinition Width="*"/>    <ColumnDefinition Width="Auto"/>   </Grid.ColumnDefinitions>  <StackPanel Grid.Column="0" Grid.Row="0"        HorizontalAlignment="Left"        Name="StackPanel1"        VerticalAlignment="Top">    <TextBlock FontSize="18" HorizontalAlignment="Center" Margin="0,0,0,15">StackPanel1</TextBlock>    <Button Margin="0,10,0,10">Button 1</Button>    <Button Margin="0,10,0,10">Button 2</Button>    <Button Margin="0,10,0,10">Button 3</Button>    <TextBlock>ColumnDefinition.Width="Auto"</TextBlock>    <TextBlock>StackPanel.HorizontalAlignment="Left"</TextBlock>    <TextBlock>StackPanel.VerticalAlignment="Top"</TextBlock>    <TextBlock>StackPanel.Orientation="Vertical"</TextBlock>    <TextBlock>Button.Margin="0,10,0,10"</TextBlock>  </StackPanel>  <StackPanel Grid.Column="1" Grid.Row="0"        HorizontalAlignment="Stretch"        Name="StackPanel2"        VerticalAlignment="Top"        Orientation="Vertical">    <TextBlock FontSize="18" HorizontalAlignment="Center" Margin="0,0,0,15">StackPanel2</TextBlock>    <Button Margin="10,0,10,0">Button 4</Button>    <Button Margin="10,0,10,0">Button 5</Button>    <Button Margin="10,0,10,0">Button 6</Button>    <TextBlock HorizontalAlignment="Center">ColumnDefinition.Width="*"</TextBlock>    <TextBlock HorizontalAlignment="Center">StackPanel.HorizontalAlignment="Stretch"</TextBlock>    <TextBlock HorizontalAlignment="Center">StackPanel.VerticalAlignment="Top"</TextBlock>    <TextBlock HorizontalAlignment="Center">StackPanel.Orientation="Horizontal"</TextBlock>    <TextBlock HorizontalAlignment="Center">Button.Margin="10,0,10,0"</TextBlock>  </StackPanel>  <StackPanel Grid.Column="2" Grid.Row="0"        HorizontalAlignment="Left"        Name="StackPanel3"        VerticalAlignment="Top">    <TextBlock FontSize="18" HorizontalAlignment="Center" Margin="0,0,0,15">StackPanel3</TextBlock>    <Button Margin="10">Button 7</Button>    <Button Margin="10">Button 8</Button>    <Button Margin="10">Button 9</Button>    <TextBlock>ColumnDefinition.Width="Auto"</TextBlock>    <TextBlock>StackPanel.HorizontalAlignment="Left"</TextBlock>    <TextBlock>StackPanel.VerticalAlignment="Top"</TextBlock>    <TextBlock>StackPanel.Orientation="Vertical"</TextBlock>    <TextBlock>Button.Margin="10"</TextBlock>  </StackPanel> </Grid></Border>
```
When compiled, the preceding application yields a UI that looks like the following illustration. The effects of the various property values are evident in the spacing between elements, and significant property values for elements in each column are shown within TextBlock elements.
`TextBlock` ![Several positioning properties in one application](https://docs.avaloniaui.net/assets/images/layout-margins-padding-alignment-graphic3-bf762c6f458fe1cfb567d945dc3f613d.png)
- Introduction to Element Positioning
- Understanding Alignment Properties
- Understanding Margin Properties
# How To Create a Custom Panel | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create a Custom Panel
## How To Create a Custom Panel
This example shows how to override the default layout behavior of the Panel element and create custom layout elements that are derived from Panel.
`Panel` `Panel` The example defines a simple custom Panel element called PlotPanel, which positions child elements according to two hard-coded x- and y-coordinates. In this example, x and y are both set to 50; therefore, all child elements are positioned at that location on the x and y axes.
`Panel` `PlotPanel` `x` `y` `50` To implement custom Panel behaviors, the example uses the MeasureOverride and ArrangeOverride methods. Each method returns the Size data that is necessary to position and render child elements.
`Panel` `MeasureOverride` `ArrangeOverride` `Size` ```bash
public class PlotPanel : Panel{  // Override the default Measure method of Panel  protected override Size MeasureOverride(Size availableSize)  {    var panelDesiredSize = new Size();    // In our example, we just have one child.     // Report that our panel requires just the size of its only child.    foreach (var child in Children)    {      child.Measure(availableSize);      panelDesiredSize = child.DesiredSize;    }    return panelDesiredSize;  }  protected override Size ArrangeOverride(Size finalSize)  {    foreach (var child in Children)    {      double x = 50;      double y = 50;      child.Arrange(new Rect(new Point(x, y), child.DesiredSize));    }        return finalSize; // Returns the final Arranged size  }}
```
# How-To Guides | Avalonia Docs
- How-To Guides
## How-To Guides
This section has practical guidance to help you implement specific tasks using Avalonia UI. Many are at the level of "how do I do that?". This section is arranged by subject area.
# Building Cross-Platform Applications | Avalonia Docs
- How-To Guides
- Building Cross Platform Applications
## Building Cross-Platform Applications
This guide introduces Avalonia and outlines how to architect a cross-platform application to maximize code re-use and deliver a high-quality UI experience across all major platforms: Windows, Linux, macOS, iOS, Android and WebAssembly.
Unlike the Xamarin.Forms and MAUI approach, which tends to yield applications with a lowest-common-denominator feature-set and a generic-looking user interface, Avalonia UI encourages leveraging its drawn UI capabilities. It allows developers to write their data storage and business logic code once, while offering a responsive and high-performing UI across all platforms. This document discusses a general architectural approach to achieve this goal.
Here is a summary of the key points for creating Avalonia cross-platform apps:
- Use .NET - Develop your apps in C#, F# or VB.NET. Existing code written with .NET can be seamlessly ported to Windows, Linux, macOS, iOS, Android and WebAssembly using Avalonia.
- Utilize the MVVM design pattern - Develop your application’s User Interface using the Model/View/ViewModel pattern. This approach promotes a clear separation between the "Model” and the "View", with the "ViewModel" acting as an intermediary. This ensures that your UI logic remains agnostic of the underlying platform, thereby promoting code reuse and maintainability.
- Leverage Avalonia's drawing capabilities - Avalonia doesn't rely on native UI controls, instead, it operates similarly to Flutter, drawing the entire UI. This not only ensures a consistent look and feel across all platforms but also offers an unparalleled level of customization, allowing you to tailor the UI to your exact needs.
- Balance between core and platform-specific code - The key to achieving high code reuse is striking the right balance between platform-agnostic core code and platform-specific code. The core code comprises everything that does not interact directly with the underlying operating system.
`Model/View/ViewModel`
# Architecture | Avalonia Docs
- How-To Guides
- Building Cross Platform Applications
- Architecture
## Architecture
A crucial aspect of building cross-platform applications with Avalonia is creating an architecture that enables maximum code sharing across different platforms. By adhering to the fundamental principles of Object-Oriented Programming, you can establish a well-structured application:
- Encapsulation – This involves ensuring that classes and architectural layers only expose a minimal API that performs their necessary functions while concealing the internal implementation details. In practical terms, this means that objects operate as 'black boxes', and the code utilizing them doesn't need to comprehend their internal workings. Architecturally, it implies implementing patterns like the Façade that promote a simplified API orchestrating more complex interactions on behalf of the code in higher abstract layers. Hence, the UI code should focus solely on displaying screens and accepting user input, never directly interacting with databases or other lower-level operations.
- Separation of Responsibilities – Every component, whether at the architectural or class level, should have a clear and defined purpose. Each component should perform its specified tasks and expose that functionality via an API accessible to other classes needing to use it.
- Polymorphism – Programming to an interface (or an abstract class) supporting multiple implementations allows core code to be written and shared across platforms while still interacting with platform-specific features offered by Avalonia.
The result of these principles is an application modelled after real-world or abstract entities with distinct logical layers.
Separating code into layers makes the application easier to understand, test, and maintain. It's advisable to keep the code in each layer physically separate (either in different directories or even separate projects for larger applications) as well as logically separate (using namespaces). With Avalonia, you can share not just the business logic, but the UI code too across platforms, reducing the need for multiple UI projects and further enhancing code reuse.
### Typical Application Layers​
In this document and the relevant case studies, we reference the following five application layers:
- Data Layer – This is where non-volatile data persistence occurs, likely through a database like SQLite or LiteDB, but could be implemented with XML files or other suitable mechanisms.
- Data Access Layer – This layer is a wrapper around the Data Layer providing Create, Read, Update, Delete (CRUD) operations on the data without revealing implementation details to the caller. For instance, the DAL might contain SQL queries to interact with the data, but the code referencing it doesn't need to be aware of this.
- Business Layer – Sometimes referred to as the Business Logic Layer or BLL, this layer houses business entity definitions (the Model) and business logic. It is a prime candidate for the Business Facade pattern.
- Service Access Layer – This layer is used to access services in the cloud, ranging from complex web services (REST, JSON) to simple retrieval of data and images from remote servers. It encapsulates networking behaviour and provides a streamlined API for consumption by the Application and UI layers.
- Application Layer – This layer contains code that is generally platform-specific or code that is specific to the application (not typically reusable). In the Avalonia framework, this layer is where you decide which platform-specific features to leverage if any. The distinction between this layer and the UI layer becomes clearer with Avalonia since the UI code can be shared across platforms.
- User Interface (UI) Layer – This user-facing layer contains views and the view-models that manage them. Avalonia makes it possible for this layer shared across every supported platform, unlike traditional architectures where the UI layer would be platform-specific.
An application might not contain all layers – for instance, the Service Access Layer would not be present in an application that doesn't access network resources. A simpler application might merge the Data Layer and Data Access Layer because the operations are extremely basic. With Avalonia, you have the flexibility to shape your application architecture to suit your specific needs, enjoying a high degree of code reusability across platforms.
### Common Architectural Patterns​
Patterns are a well-established approach to capture recurring solutions to common problems. There are several key patterns that are valuable to comprehend when building maintainable and understandable applications with Avalonia.
#### Model, View, ViewModel (MVVM)​
A popular and often misunderstood pattern, MVVM is primarily employed when constructing User Interfaces and promotes a separation between the actual definition of a UI Screen (View), the logic behind it (ViewModel), and the data that populates it (Model). The ViewModel acts as an intermediary between the View and the Model. The Model, although crucial, is a distinct and optional piece, and thus, the essence of understanding this pattern resides in the relationship between the View and ViewModel.
Learn more about MVVM.
#### Business Façade​
Also known as the Manager Pattern, this provides a simplified point of entry for intricate operations. For instance, in a Task Tracking application, you might have a TaskManager class with methods such as GetAllTasks(), GetTask(taskID), SaveTask (task), etc. The TaskManager class provides a Façade to the inner mechanisms of saving/retrieving tasks objects.
#### Singleton​
The Singleton pattern ensures that only a single instance of a particular object can ever exist. For example, when using SQLite in applications, you typically want only one instance of the database. The Singleton pattern is an efficient method to enforce this.
#### Provider​
A pattern originally coined by Microsoft to promote code re-use across Silverlight, WPF and WinForms applications. Shared code can be written against an interface or abstract class, and platform-specific concrete implementations are written and passed in when the code is utilised. In Avalonia, since we can share both UI and application logic, this pattern can help handle platform-specific exceptions or leverage platform-specific features.
#### Async​
Not to be confused with the Async keyword, the Async pattern is used when long-running tasks need to be executed without holding up the UI or current processing. In its simplest form, the Async pattern describes that long-running tasks should be kicked off in another thread (or a similar thread abstraction such as a Task) while the current thread continues to process and listens for a response from the background process, updating the UI when data and/or state is returned. This is essential in maintaining a responsive UI in Avalonia applications.
`Async` Each of the aforementioned patterns will be explored in-depth as their practical application is demonstrated in our case studies. For a more comprehensive understanding of the Facade, Singleton, and Provider patterns, as well as Design Patterns in general, you may want to delve into resources available on platforms like Wikipedia.
- Typical Application Layers
- Common Architectural PatternsModel, View, ViewModel (MVVM)Business FaçadeSingletonProviderAsync
- Model, View, ViewModel (MVVM)
- Business Façade
- Singleton
- Provider
- Async
- Model, View, ViewModel (MVVM)
- Business Façade
- Singleton
- Provider
- Async
# Setting Up A Cross Platform Solution | Avalonia Docs
- How-To Guides
- Building Cross Platform Applications
- Setting Up A Cross Platform Solution
## Setting Up A Cross Platform Solution
Despite the platform diversity, Avalonia projects all leverage the same solution file format (the Visual Studio ".SLN” file format). Solutions can be shared across development environments, providing a unified approach to multi-platform app development.
The first step to creating a new cross platform application is to create a solution. This section will elaborate on what happens next: the process of setting up the projects for building cross-platform applications with Avalonia.
### Populating the Solution​
The Avalonia Cross Platform Application template creates a solution structure that includes the following projects to allow seamless sharing and reusability of code across multiple platforms:
`Avalonia Cross Platform Application` Ensure you've installed the Avalonia Templates.
#### Core Project​
This forms the heart of your application and is designed to be platform-agnostic. It contains all the reusable components of your application, including business logic, view models, and views. All other projects reference this core project. The majority of your development efforts should reside here.
#### Desktop Project​
This project enables running the app to run on Windows, macOS, and Linux platforms, with an output type of 'WinExe'.
#### Android Project​
This is a NET-Android based project that references the Core Project. It features a MainActivity that inherits from AvaloniaMainActivity, acting as the entry point for the Android application.
`NET-Android` `AvaloniaMainActivity` #### iOS Project​
This is a NET-iOS project tailored for iOS and iPadOS platforms. The entry point for this project is the AppDelegate, which inherits from AvaloniaAppDelegate.
`NET-iOS` `AppDelegate` `AvaloniaAppDelegate` #### Browser Project​
This WebAssembly (WASM) project allows your Avalonia application to run in a web browser. Its RuntimeIdentifier is 'browser-wasm'.
`'browser-wasm'` ### Core Project​
Shared code projects should only reference assemblies that are universally available across all platforms. This generally includes common framework namespaces like System, System.Core, and System.Xml.
`System` `System.Core` `System.Xml` These shared projects aim to implement as much application functionality as possible, including UI components, thereby maximizing the reusability of code.
By separating functionalities into distinct layers, code becomes easier to manage, test, and reuse across multiple platforms. This layered architecture approach in Avalonia UI projects promotes efficiency and scalability in application development.
### Platform-Specific Application Projects​
Platform-Specific projects must reference the Core Project. The Platform Specific projects exist to enable the application to run on unique platforms including iOS, Android and WASM.
While desktop platforms can share a single project, it may be beneficial to create a separate project for macOS using the Xamarin.Mac Target Framework. This will enable easier distribution and packaging of your application.
- Populating the SolutionCore ProjectDesktop ProjectAndroid ProjectiOS ProjectBrowser Project
- Core Project
- Desktop Project
- Android Project
- iOS Project
- Browser Project
- Core Project
- Platform-Specific Application Projects
- Core Project
- Desktop Project
- Android Project
- iOS Project
- Browser Project
# Install | Avalonia Docs
- Get Started
- Install
## Install
### Preinstallation​
Please start with the supported IDE of your choice installed. Avalonia supports Visual Studio, Rider, and Visual Studio Code.
### Install Avalonia UI Templates​
The best way to get started with Avalonia is by creating an application using a project template.
To install the Avalonia templates, run the following command:
```bash
dotnet new install Avalonia.Templates
```
For .NET 6.0 and earlier, replace install with --install
`install` `--install` To list the installed templates run
```bash
dotnet new list
```
You should see the installed Avalonia templates:
```bash
Template Name                 Short Name         Language  Tags-------------------------------------------- -------------------------- ---------- ---------------------------------------------------------Avalonia App                 avalonia.app        [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia MVVM App               avalonia.mvvm        [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia Cross Platform Application      avalonia.xplat       [C#],F#   Desktop/Xaml/Avalonia/Web/MobileAvalonia Resource Dictionary         avalonia.resource            Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia Styles                avalonia.styles             Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia TemplatedControl           avalonia.templatedcontrol  [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia UserControl             avalonia.usercontrol    [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOSAvalonia Window                avalonia.window       [C#],F#   Desktop/Xaml/Avalonia/Windows/Linux/macOS
```
### Create a new Application​
Once the project templates are installed, you can create a new Avalonia UI application from CLI by running the following command:
```bash
dotnet new avalonia.app -o MyApp
```
This will create a new folder called MyApp containing your application files. To run the application, navigate to the MyApp folder and run:
`MyApp` `MyApp` ```bash
cd MyAppdotnet run
```
The project templates will also allow for project creation from your IDE.
### Installation Troubleshooting​
#### Ensure .NET SDK is installed​
```bash
dotnet --list-sdks8.0.202 [C:\Program Files\dotnet\sdk] <-- Your version may vary
```
If dotnet is not a recognized program, then ensure you've installed your IDE first. Next, ensure that dotnet is associated with the terminal. On Windows, this involves checking environment variables: echo %PATH% in the command prompt or echo $Env:PATH in PowerShell.
`dotnet` `dotnet` `echo %PATH%` `echo $Env:PATH` #### Ensure NuGet source is correct​
If while installing the project templates, you receive an error stating the Avalonia.Templates package cannot be found, then ensure NuGet is correctly setup with .NET's standard global package source.
`Avalonia.Templates` ```bash
dotnet nuget list sourceRegistered Sources: 1. nuget.org [Enabled]   https://api.nuget.org/v3/index.json
```
If this source is not listed, add it:
```bash
dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org
```
If the package install still fails despite NuGet being listed, then suspect a network connectivity or firewall issue.
- Preinstallation
- Install Avalonia UI Templates
- Create a new Application
- Installation TroubleshootingEnsure .NET SDK is installedEnsure NuGet source is correct
- Ensure .NET SDK is installed
- Ensure NuGet source is correct
- Ensure .NET SDK is installed
- Ensure NuGet source is correct
# Dealing with Multiple Platforms | Avalonia Docs
- How-To Guides
- Building Cross Platform Applications
- Dealing with Multiple Platforms
## Dealing with Multiple Platforms
### Managing Platform Differences & Capabilities​
Platform differences aren't just an issue in cross-platform development; even devices within the same platform can possess diverse capabilities.
Most notably, this includes differences in screen size, but numerous other device characteristics may also vary, requiring the application to verify certain capabilities and adapt its behavior based on their presence (or absence). This is especially important when designing for cross paradigm situations, with desktop and mobile operating systems providing very different interaction models.
Therefore, all applications must be equipped to handle a graceful scaling back of functionality, or risk presenting a minimal feature set that does not leverage the full potential of the underlying platform.
#### Examples of Platform Divergence​
There are certain fundamental characteristics inherent to applications that are universally applicable. These are high-level concepts that hold true across all devices and platforms and can thus form the core of your application's design:
- A screen, which can display your application UI.
- Some form of input devices, typically touch for mobile and mouse and keyboard for desktop.
- Display views of data.
- Editing data.
- Navigation capabilities.
#### Platform-Specific features​
Beyond the universal application characteristics, you will also have to address key platform differences in your design. You may need to consider, and possibly write or tweak code specifically to handle, these differences:
- Screen Sizes: While some platforms (like iOS) have standardized screen sizes that are relatively easy to target, others, like Desktop and WebAssembly, enable an unlimited variety of screen dimensions which would require more effort to support in your application.
- Navigation Metaphors: These can vary across platforms (e.g., hardware 'back' button) and even within platforms (e.g., differences between Android 2 and 4, iPhone vs iPad).
- Keyboards: Some devices may come with physical keyboards, while others only feature a software keyboard. Code that detects when a soft-keyboard is obscuring part of the screen needs to be sensitive to these differences.
Screen Sizes: While some platforms (like iOS) have standardized screen sizes that are relatively easy to target, others, like Desktop and WebAssembly, enable an unlimited variety of screen dimensions which would require more effort to support in your application.
Navigation Metaphors: These can vary across platforms (e.g., hardware 'back' button) and even within platforms (e.g., differences between Android 2 and 4, iPhone vs iPad).
Keyboards: Some devices may come with physical keyboards, while others only feature a software keyboard. Code that detects when a soft-keyboard is obscuring part of the screen needs to be sensitive to these differences.
These platform-specific differences should be carefully considered when designing your Avalonia application to ensure a seamless user experience across all platforms. While you should strive to maximize your code reuse, you should also avoid attempting to reuse 100% of your code across all supported platforms. Instead, tailor each platform UIs to the feel at home on the device.
#### Dealing with Platform Divergence​
Supporting multiple platforms from the same code-base can be achieved through abstracting platform features or conditional code.
- Platform Abstraction: This approach leverages the Business Façade pattern to provide uniform access across platforms. It abstracts the unique platform implementations into a single, cohesive API. The primary advantage is the ability to write platform-agnostic code, enhancing code reusability and maintainability. However, this approach may not fully exploit the unique features and capabilities of each platform.
### Platform Abstraction​
In Avalonia, you can employ class abstractions to streamline your development process across different platforms. This can be achieved using interfaces or base classes defined in the shared code, then implemented or extended in platform-specific projects.
#### Interfaces​
The utilization of interfaces empowers you to create platform-specific classes that can be incorporated into your shared libraries for code reuse.
##### How it works​
The interface is defined within the shared code and passed into the shared library as a parameter or property. The platform-specific applications can then implement the interface, allowing shared code to process it effectively.
##### Advantages​
The main advantage of this approach is that the implementation can contain platform-specific code and even reference platform-specific external libraries, offering high flexibility.
##### Disadvantages​
A potential disadvantage is the need to create and pass implementations into the shared code. If the interface is employed deep within the shared code, it may have to be passed through multiple method parameters, which might lead to a more complex call chain. If the shared code uses numerous different interfaces, they all must be created and set within the shared code.
#### Inheritance​
Your shared code can implement abstract or virtual classes that could be extended in one or more platform-specific projects. This technique resembles the use of interfaces but provides some already implemented behaviors.
##### How it works​
By using inheritance, you can create base classes in your shared code that can be optionally extended in your platform-specific projects. However, as C# allows only single inheritance, this approach may influence your future API design. Hence, use inheritance with caution.
##### Advantages and Disadvantages​
The advantages and disadvantages of using interfaces apply equally to inheritance. However, an additional advantage of inheritance is that the base class can contain some implementation code. This potentially could provide an entire platform-agnostic implementation that can be optionally extended as needed.
### Using Maui.Essentials​
Another approach would be to use any library that abstracts some features under a common higher level API. Maui.Essentials is one of these libraries, that can be used with Avalonia on .NET 8 or higher via Microsoft.Maui.Essentials nuget package. Alternatively, you can use full set of MAUI packages with Avalonia.Maui hybrid package. This package provides a deeper integration with MAUI packages.
While Maui.Essentials is a great library that abstracts platform APIs, MAUI itself has a limited set of supported platforms. It doesn't provide APIs for Linux, Browser and macOS (non macCatalyst) platforms.
`Maui.Essentials` - Managing Platform Differences & CapabilitiesExamples of Platform DivergencePlatform-Specific featuresDealing with Platform Divergence
- Examples of Platform Divergence
- Platform-Specific features
- Dealing with Platform Divergence
- Platform AbstractionInterfacesInheritance
- Interfaces
- Inheritance
- Using Maui.Essentials
- Examples of Platform Divergence
- Platform-Specific features
- Dealing with Platform Divergence
- Interfaces
- Inheritance
# Platform-specific .NET | Avalonia Docs
- How-To Guides
- Platforms
- Platform-Specific Code
- Platform-specific .NET
## Platform-specific .NET
### Overview​
Conditional compilation in .NET allows different parts of the code to be compiled or omitted based on certain conditions. This is particularly useful in .NET when dealing with code that needs to behave differently on various platforms or under different development environments.
None of these solutions are specific to Avalonia, and they can be used with any type of projects.
### Runtime Conditions​
.NET 6 and newer provide a set of APIs to get operating system in runtime - OperatingSystem.
Commonly used static methods of this class are:
These methods do not require any changes in the project structure, and can be used anywhere. The disadvantage of using them, it is not possible to separate platform specific APIs in compile time. As otherwise it would require platform specific dependencies to be referenced in a common assembly.
This approach is recommended for simpler scenarios, or when it's desired to keep simple project structure. In the last case,
It's the only possible approach to write a conditional .NET code for Linux OS. As .NET doesn't have a special Target Framework for Linux.
### Conditional compilation​
C# specifically allows to have conditional compilation with #if, #elif, #else, #endif - C# preprocessor directives.
`#if` `#elif` `#else` `#endif` DEBUG compile time constant is a well known one. But it's not really useful with writing platform specific code. Depending on the project time, C# compiler might define additional constants per each OS specific Target Framework used in the project:
`DEBUG` From this table, we can see couple of notes:
- If project doesn't use any OS specific Target Framework, none of these constants will be defined
- There is no constant for LINUX, as there is no net8.0-linux Target Framework as of now. Note, it might be changed in the future versions of .NET.
- Additionally, net8.0-browser is only available starting with .NET 8 SDK. Other Target Frameworks are supported with .NET 6 or higher.
`net8.0-linux` `net8.0-browser` Similar approach can be used to define special code compilation for .NET Framework or .NET Standard projects, if it's required. Visit Microsoft Cross-platform targeting documentation for more information.
#### Practical example​
Let's imagine, we want to use platform APIs from C# code. It can be Avalonia APIs, or Xamarin APIs, or anything else really. First of all, expected Target Frameworks needs to be defined in the project. To keep it simple, we will have three possible target framework - "net8.0" (default), "net8.0-ios" and "net8.0-android" in .csproj file:
`.csproj` ```bash
<PropertyGroup>  <TargetFrameworks>net8.0;net8.0-ios;net8.0-android</TargetFrameworks></PropertyGroup>
```
And then it's possible to create a method like this:
```bash
public enum DeviceOrientation{  Undefined,  Landscape,  Portrait}public static DeviceOrientation GetOrientation(){#if ANDROID      IWindowManager windowManager = Android.App.Application.Context.GetSystemService(Context.WindowService).JavaCast<IWindowManager>();      SurfaceOrientation orientation = windowManager.DefaultDisplay.Rotation;      bool isLandscape = orientation == SurfaceOrientation.Rotation90 || orientation == SurfaceOrientation.Rotation270;      return isLandscape ? DeviceOrientation.Landscape : DeviceOrientation.Portrait;#elif IOS      UIInterfaceOrientation orientation = UIApplication.SharedApplication.StatusBarOrientation;      bool isPortrait = orientation == UIInterfaceOrientation.Portrait || orientation == UIInterfaceOrientation.PortraitUpsideDown;      return isPortrait ? DeviceOrientation.Portrait : DeviceOrientation.Landscape;#else      return DeviceOrientation.Undefined;#endif}
```
This sample code is referenced from the Microsoft documentation: https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/invoke-platform-code?view=net-maui-8.0#conditional-compilation
### Platform specific projects​
Similarly to the previous approach, it is possible to create bootstrap projects per each platform, and keep shared project with main logic and layouts. For example, default Avalonia.Xplat template creates solution with following projects:
Desktop project combines Windows, macOS and Linux. While mobile and browser platforms have their own projects. This is default approach for Avalonia projects. If desired, developers can split Desktop project into multiple as well. Although, it should be kept in mind, that .NET SDK doesn't have any target framework for Linux yet, so it still would have to use generic net8.0 target framework.
`net8.0` Commonly, when any platform specific code is required, a new interface is created in shared project, with different implementations per each platform. Adapting previous sample would look like this:
```bash
public interface IDeviceOrientation{  DeviceOrientation GetOrientation();}
```
```bash
public class AndroidDeviceOrientation : IDeviceOrientation{  public DeviceOrientation GetOrientation()  {    IWindowManager windowManager = Android.App.Application.Context.GetSystemService(Context.WindowService).JavaCast<IWindowManager>();    SurfaceOrientation orientation = windowManager.DefaultDisplay.Rotation;    bool isLandscape = orientation == SurfaceOrientation.Rotation90 || orientation == SurfaceOrientation.Rotation270;    return isLandscape ? DeviceOrientation.Landscape : DeviceOrientation.Portrait;  }}
```
```bash
public class iOSDeviceOrientation : IDeviceOrientation{  public DeviceOrientation GetOrientation()  {    UIInterfaceOrientation orientation = UIApplication.SharedApplication.StatusBarOrientation;    bool isPortrait = orientation == UIInterfaceOrientation.Portrait || orientation == UIInterfaceOrientation.PortraitUpsideDown;    return isPortrait ? DeviceOrientation.Portrait : DeviceOrientation.Landscape;  }}
```
Each implementation then can be registered using dependency injection library of choice, or using a static registry property.
- Overview
- Runtime Conditions
- Conditional compilationPractical example
- Practical example
- Platform specific projects
- Practical example
# Improving Performance | Avalonia Docs
- How-To Guides
- Development Guides
- Improving Performance
## Improving Performance
The performance of Avalonia applications can be significantly improved by taking into account several key considerations during the development process. This document discusses the steps you can take to optimize the performance of your Avalonia applications.
### Use CompiledBindings​
One of the most effective ways to improve performance in Avalonia is to use CompiledBindings in your application. Compiled bindings enable faster data binding by compiling the binding path at compile time, thus reducing the overhead of reflection at runtime.
`CompiledBindings` ### Choose the Right Control for Data Display​
When you need to display a large amount of data in a DataGrid or a TreeView with many nodes, it is recommended to use the TreeDataGrid control. TreeDataGrid is built from scratch and provides better performance than the normal DataGrid. It supports virtualization and is particularly useful if you need a virtualized tree, as it has hierarchical data templates.
`DataGrid` `TreeView` `TreeDataGrid` `TreeDataGrid` `DataGrid` Avoid using the DataGrid control if you don't need editing features. It's generally regarded as a less optimal control for performance.
`DataGrid` ### Virtualization​
When working with large amounts of data, enabling virtualization can improve the performance of your Avalonia application. Virtualization means that only the visible items in the control are rendered, which significantly improves the performance when there are a large number of items to display.
#### TreeDataGrid​
TreeDataGrid supports virtualization and can handle thousands of rows with complex cells effectively.
`TreeDataGrid` ### Optimize Your Visual Tree Structure​
Performance can often be hindered by a deeply nested and complicated layout. Strive to maintain your XAML markup as uncomplicated and flat as possible. Rendering UI elements onscreen triggers a "layout pass" twice for every single element (a measure pass followed by an arrange pass).
This layout pass process is computation-heavy—the more child elements an item has, the more calculations are needed. Therefore, minimizing the complexity of your visual tree in Avalonia UI can significantly enhance the application's performance.
### Minimize Use of Run for Setting Text Properties​
It's advisable to minimize the use of Run within a TextBlock as it can lead to more resource-demanding operations. If you're utilizing Run to define text properties, consider setting those properties directly on the TextBlock instead. This practice can help enhance the performance of your application.
### Use StreamGeometries Over PathGeometries​
When dealing with geometries in Avalonia UI, StreamGeometry is a more efficient alternative to PathGeometry. StreamGeometry is specifically optimized to handle numerous PathGeometry objects, consuming less memory and offering superior performance. Hence, when a choice is available, it's recommended to use StreamGeometry over PathGeometry for improved application performance.
`StreamGeometry` `PathGeometry` `StreamGeometry` `PathGeometry` `StreamGeometry` `PathGeometry` ### Use Reduced Image Sizes​
When your application necessitates the display of smaller images or thumbnails, it's beneficial to generate and use reduced-size versions of your images. By default, Avalonia will load and decode your image at its original full size, which can potentially lead to performance bottlenecks if you're loading large images and scaling them down to thumbnail sizes in controls like an ItemsControl.
`ItemsControl` ### Resolve Your Binding Errors​
Binding errors are a prevalent source of performance issues in Avalonia UI applications. Each occurrence of a binding error causes a performance dip as the application attempts to resolve the binding and logs the error to the trace log. Naturally, the more binding errors present, the greater the impact on performance.
A significant contributor to binding errors is the use of RelativeSource bindings in DataTemplates, as the binding usually isn't resolved correctly until the DataTemplate has completed its initialization. It's recommended to avoid RelativeSource.FindAncestor entirely. A more efficient approach is to define an attached property and utilize property inheritance to push values down the visual tree, rather than performing a lookup of the visual tree.
`RelativeSource` `DataTemplates` `DataTemplate` `RelativeSource.FindAncestor` ### Asynchronously Load Data​
Performance issues, UI freezes, and unresponsive applications often stem from the way data is loaded. To prevent overloading the UI thread, ensure that your data is loaded asynchronously.
- Use CompiledBindings
- Choose the Right Control for Data Display
- VirtualizationTreeDataGrid
- TreeDataGrid
- Optimize Your Visual Tree Structure
- Minimize Use of Run for Setting Text Properties
- Use StreamGeometries Over PathGeometries
- Use Reduced Image Sizes
- Resolve Your Binding Errors
- Asynchronously Load Data
- TreeDataGrid
# Compiled Bindings | Avalonia Docs
- Basics
- Data
- Data Binding
- Compiled Bindings
## Compiled Bindings
Bindings defined in the XAML are using reflection in order to find and access the requested property in your ViewModel. In Avalonia you can also use compiled bindings, which has some benefits:
`ViewModel` - If you use compiled bindings and the property you bind to is not found, you will get a compile-time error. Hence you get a much better debugging experience.
- Reflection is known to be slow (see this article on codeproject.com). Using compiled bindings can therefore improve the performance of your application.
### Enable and disable compiled bindings​
Depending on the template that was used to create the Avalonia project, compiled bindings may or may not be enabled by default. You can check this in the project file.
#### Enable and disable globally​
If you want your application to use compiled bindings globally by default, you can add
```bash
<AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
```
to your project file. You will still need to provide x:DataType for the objects you want to bind but you don't need to to set x:CompileBindings="[True|False]" for each UserControl or Window.
`x:DataType` `x:CompileBindings="[True|False]"` `UserControl` `Window` #### Enable and disable per UserControl or Window​
To enable compiled bindings, you will need to define the DataType of the object you want to bind to first. In DataTemplates there is a property DataType, for all other elements you can set it via x:DataType. Most likely you will set x:DataType in your root node, for example in a Window or an UserControl. You can also specify the DataType in the Binding directly.
`DataType` `DataTemplates` `DataType` `x:DataType` `x:DataType` `Window` `UserControl` `DataType` `Binding` You can now enable or disable compiled bindings by setting x:CompileBindings="[True|False]". All child nodes will inherit this property, so you can enable it in your root node and disable it for a specific child, if needed.
`x:CompileBindings="[True|False]"` ```bash
<!-- Set DataType and enable compiled bindings --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel"       x:CompileBindings="True">  <StackPanel>    <TextBlock Text="Last name:" />    <TextBox Text="{Binding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{Binding GivenName}" />    <TextBlock Text="E-Mail:" />    <!-- Set DataType inside the Binding-markup -->    <TextBox Text="{Binding MailAddress, DataType={x:Type vm:MyViewModel}}" />    <Button Content="Send an E-Mail"        Command="{Binding SendEmailCommand}" />  </StackPanel></UserControl>
```
### CompiledBinding-Markup​
If you don't want to enable compiled bindings for all child nodes, you can also use the CompiledBinding-markup. You still need to define the DataType, but you can omit x:CompileBindings="True".
`CompiledBinding` `DataType` `x:CompileBindings="True"` ```bash
<!-- Set DataType --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel">  <StackPanel>    <TextBlock Text="Last name:" />    <!-- use CompiledBinding markup for your binding -->    <TextBox Text="{CompiledBinding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{CompiledBinding GivenName}" />    <TextBlock Text="E-Mail:" />    <TextBox Text="{CompiledBinding MailAddress}" />    <!-- This command will use ReflectionBinding, as it's default -->    <Button Content="Send an E-Mail"        Command="{Binding SendEmailCommand}" />  </StackPanel></UserControl>
```
### ReflectionBinding-Markup​
If you have compiled bindings enabled in the root node (via x:CompileBindings="True") and you either don't want to use compiled binding at a certain position, you can use the ReflectionBinding-markup.
`x:CompileBindings="True"` `ReflectionBinding` ```bash
<!-- Set DataType --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel"       x:CompileBindings="True">  <StackPanel>    <TextBlock Text="Last name:" />    <TextBox Text="{Binding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{Binding GivenName}" />    <TextBlock Text="E-Mail:" />    <TextBox Text="{Binding MailAddress}" />    <!-- We use ReflectionBinding instead -->    <Button Content="Send an E-Mail"        Command="{ReflectionBinding SendEmailCommand}" />  </StackPanel></UserControl>
```
### Type casting​
In some cases the target type of the binding expression cannot be automatically evaluated. In such cases you must provide an explicit type cast in the binding expression.
```bash
<ItemsRepeater ItemsSource="{Binding MyItems}"><ItemsRepeater.ItemTemplate>  <DataTemplate>  <StackPanel Orientation="Horizontal">    <TextBlock Text="{Binding DisplayName}"/>    <Grid>    <Button Command="{Binding $parent[ItemsRepeater].((vm:MyUserControlViewModel)DataContext).DoItCommand}"        CommandParameter="{Binding ItemId}"/>    </Grid>  </StackPanel>  </DataTemplate></ItemsRepeater.ItemTemplate></ItemsRepeater>
```
In this case, the button command shall not be bound to the item's DataContext but to a command that is defined in the DataContextof the ItemsRepeater. The single item will be identified using a CommandParameter bound to the item's DataContext. Therefore, you must specify the type of the "parent" DataContext via cast expression ((vm:MyUserControlViewModel)DataContext).
`DataContext` `DataContext` `ItemsRepeater` `CommandParameter` `DataContext` `DataContext` `((vm:MyUserControlViewModel)DataContext)` - Enable and disable compiled bindingsEnable and disable globallyEnable and disable per UserControl or Window
- Enable and disable globally
- Enable and disable per UserControl or Window
- CompiledBinding-Markup
- ReflectionBinding-Markup
- Type casting
- Enable and disable globally
- Enable and disable per UserControl or Window
# Data Templates | Avalonia Docs
- Basics
- Data
- Data Templates
## Data Templates
Data Templates in Avalonia provide a powerful way to define the visual representation of your data. They allow you to specify how your data should be presented and formatted, enabling you to create dynamic and customizable user interfaces. This document will introduce you to the concept of Data Templates in Avalonia and demonstrate how to use them effectively in your applications.
### What is a Data Template?​
At its core, a Data Template is a reusable definition that specifies how to present data of a particular type. It defines the visual structure and appearance of the data when displayed in the user interface. In Avalonia, a Data Template is often associated with a list control, such as a ListBox or ItemsControl, and is responsible for rendering individual items of data within that control.
`ListBox` `ItemsControl` ### Applying a Data Template to a ListBox​
To apply a Data Template to a ListBox, you typically use the ItemTemplate property of the control.
`ListBox` `ItemTemplate` For instance, if you have a ListBox that should display a collection of Item objects using the defined Data Template, you can set the ItemTemplate property like this:
`ListBox` `Item` `ItemTemplate` ```bash
<ListBox ItemsSource="{Binding Items}"> <ListBox.ItemTemplate>  <DataTemplate>    <StackPanel Orientation="Horizontal">      <TextBlock Text="{Binding Name}" />      <Image Source="{Binding ImageSource}" />    </StackPanel>  </DataTemplate> </ListBox.ItemTemplate></ListBox>
```
In this example, the Data Template defines a visual layout using a StackPanel container. Within the StackPanel, we have a TextBlock bound to the Name property of the item and an Image control bound to the ImageSource property.
`StackPanel` `StackPanel` `TextBlock` `Name` `Image` `ImageSource` ### Customizing Data Templates​
Data Templates can be customized and tailored to specific scenarios. You can include additional visual elements, apply styling, and even define nested templates within a Data Template. By leveraging data binding expressions and converters, you can dynamically populate and format the visual elements based on the data properties.
### Further Reading​
For more information see the Deep Dive into to data templates.
- What is a Data Template?
- Applying a Data Template to a ListBox
- Customizing Data Templates
- Further Reading
# Data Templates | Avalonia Docs
- Deep Dives
- Data Templates
## Data Templates
These pages describe the important concept of a data template in Avalonia UI.
A data template allows an Avalonia UI control to display an object in its content zone which is not itself a control. This concept is explained using a practical code example.
For some information about the concept of control layout zones in Avalonia UI, see here.
### Example Code​
To follow the example code that follows, create a new Avalonia UI project using the 'Avalonia Application' template in C#.
- Example Code
# Control Content | Avalonia Docs
- Deep Dives
- Data Templates
- Control Content
## Control Content
You have probably seen what happens if you put a button control into the content zone of an Avalonia UI window.
The concept of the zones of an Avalonia UI control is discussed here.
For example:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="MySample.MainWindow"    Title="MySample"> <Button HorizontalAlignment="Center" >Hello World!</Button></Window>
```
The window displays the button - in this case centred both horizontally (specified) and vertically (by default). It looks like this:
And if you put a string into the window content zone, for example:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="MySample.MainWindow"    Title="MySample"> Hello World!</Window>
```
The window will display the string:
But what happens if you try to display an object from a class that you have defined in the window?
For example, using the class definition Student
`Student` ```bash
namespace MySample{  public class Student  {    public string FirstName { get; set;} = String.Empty;    public string LastName { get; set;} = String.Empty;  }}
```
And the XML namespace local defined as the MySample namespace (from above), you can define a student object in the content zone of the window; as follows:
`local` `MySample` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:local="using:MySample"    x:Class="MySample.Views.MainWindow"> <local:Student FirstName="Jane" LastName="Deer"/></Window>
```
But you will see only the fully-qualified class name for the student object:
This is not very helpful! It happens because Avalonia UI has no definition of how to display an object of class Student - and it is not a control - so it falls back on the .ToString() method, and all you see is the fully-qualified class name.
`Student` `.ToString()` On the next page you will see one of the ways you can specify how to display an object created from a class that you have defined (not a control or a simple string).
# Data Templates | Avalonia Docs
- Deep Dives
- Data Templates
## Data Templates
These pages describe the important concept of a data template in Avalonia UI.
A data template allows an Avalonia UI control to display an object in its content zone which is not itself a control. This concept is explained using a practical code example.
For some information about the concept of control layout zones in Avalonia UI, see here.
### Example Code​
To follow the example code that follows, create a new Avalonia UI project using the 'Avalonia Application' template in C#.
- Example Code
# Content Template | Avalonia Docs
- Deep Dives
- Data Templates
- Content Template
## Content Template
The purpose of a data template is that it defines how Avalonia UI should display an object created from a class that you have defined, and that is not a control, or a simple string.
Using a data template is a two-stage process:
- Define the data template
- Choose the data template for the content
One way to use a data template is to set the ContentTemplate property of a control directly. This works on a window (because like any control it inherits from ContentControl).
`ContentTemplate` `ContentControl` You can define a data template (for no particular class) using the DataTemplate tag, a composition of built-in controls, and some bindings. For example:
`DataTemplate` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:local="using:MySample"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="MySample.MainWindow"    Title="MySample"> <Window.ContentTemplate>  <DataTemplate>   <StackPanel>    <Grid ColumnDefinitions="Auto,Auto" RowDefinitions="Auto,Auto">     <TextBlock Grid.Row="0" Grid.Column="0">First Name:</TextBlock>     <TextBlock Grid.Row="0" Grid.Column="1" Text="{Binding FirstName}"/>     <TextBlock Grid.Row="1" Grid.Column="0">Last Name:</TextBlock>     <TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding LastName}"/>    </Grid>   </StackPanel>  </DataTemplate> </Window.ContentTemplate>  <local:Student FirstName="Jane" LastName="Deer"/></Window>
```
In the above, the bindings refer to the properties of any class present in the content zone of the window. Here the window content is the same student object as you used before; but when you run this code, Avalonia UI now displays:
Using a data template in this way, you have both defined and chosen the data template for the content in the same place - by setting the ContentTemplate property of the window directly.
`ContentTemplate` The code works correctly because the object in the window's content zone happens to have the properties specified in the bindings. As an exercise: introduce a binding for a property that does not exist on the student class. (Your app will still work, but it ignores the property it cannot find.)
On the next page, you will see how to define multiple data templates, and choose the correct template from the class of the object in the window's content zone.
# Data Templates Collection | Avalonia Docs
- Deep Dives
- Data Templates
- Data Templates Collection
## Data Templates Collection
Every control in Avalonia UI has a DataTemplates collection where you can place any number of data template definitions. You can then choose the template to use for display by class type.
`DataTemplates` When a control does not have a data template set directly in its ContentTemplate property (as on the previous page); then it will choose a template from in its DataTemplates collection that matches the class of the object being displayed. This applies to a window.
`ContentTemplate` `DataTemplates` Data templates are matched by type: a match occurs when the class of the object being displayed is the same as the fully-qualified class name specified in the DataType property of a template.
`DataType` So you can modify the previous sample to use the DataTemplates collection, as follows:
`DataTemplates` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:local="using:MySample"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="MySample.MainWindow"    Title="MySample"> <Window.DataTemplates>  <DataTemplate DataType="{x:Type local:Student}">   <Grid ColumnDefinitions="Auto,Auto" RowDefinitions="Auto,Auto">    <TextBlock Grid.Row="0" Grid.Column="0">First Name:</TextBlock>    <TextBlock Grid.Row="0" Grid.Column="1" Text="{Binding FirstName}"/>    <TextBlock Grid.Row="1" Grid.Column="0">Last Name:</TextBlock>    <TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding LastName}"/>   </Grid>  </DataTemplate> </Window.DataTemplates>  <local:Student FirstName="Jane" LastName="Deer"/></Window>
```
This results in exactly the same display as on the previous page:
# Reusing Data Templates | Avalonia Docs
- Deep Dives
- Data Templates
- Reusing Data Templates
## Reusing Data Templates
If you define a data template in the Window.DataTemplates collection (as on the previous page), you can reuse it anywhere in the window. However, you can also extend the reuse of a data template to any window in your application.
`Window.DataTemplates` This works because Avalonia UI performs a hierarchical search of its logical tree to choose a data template. At its most extensive, the search starts in a control, extends to any parent controls (recursively), then looks in the window (as on the previous page), and finally looks at the application itself for a data templates collection.
From more information on the logical tree concept in Avalonia UI , see here.
Therefore if you want to reuse a template in any window of your application: define templates in the Application.DataTemplates collection, located in the app.axaml file.
`Application.DataTemplates` To see how this works, first add another view model as follows:
```bash
namespace MySample{  public class Teacher  {    public string Name { get; set; } = String.Empty;    public string Subject { get; set; } = String.Empty;  }}
```
And in the app.axaml file, add a data template for the type Teacher:
`Teacher` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MySample"       x:Class="MySample.App"       RequestedThemeVariant="Light">  <Application.Styles>    <FluentTheme />  </Application.Styles> <Application.DataTemplates>  <DataTemplate DataType="{x:Type vm:Teacher}">   <Grid ColumnDefinitions="Auto,Auto" RowDefinitions="Auto,Auto">    <TextBlock Grid.Row="0" Grid.Column="0">Name:</TextBlock>    <TextBlock Grid.Row="0" Grid.Column="1" Text="{Binding Name}"/>    <TextBlock Grid.Row="1" Grid.Column="0">Subject:</TextBlock>    <TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding Subject}"/>   </Grid>  </DataTemplate> </Application.DataTemplates></Application>
```
Use a local definition of a teacher in the window content zone:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:local="using:MySample"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="MySample.MainWindow"    Title="MySample"> <Window.DataTemplates>  <DataTemplate DataType="{x:Type local:Student}">   <Grid ColumnDefinitions="Auto,Auto" RowDefinitions="Auto,Auto">    <TextBlock Grid.Row="0" Grid.Column="0">First Name:</TextBlock>    <TextBlock Grid.Row="0" Grid.Column="1" Text="{Binding FirstName}"/>    <TextBlock Grid.Row="1" Grid.Column="0">Last Name:</TextBlock>    <TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding LastName}"/>   </Grid>  </DataTemplate> </Window.DataTemplates>  <local:Teacher Name="Dr Jones" Subject="Maths"/></Window>
```
Although there is no data template for a teacher in the window; Avalonia UI will find the template you defined in the application, and the display works as planned:
Remember to specify a DataType in every data template, wherever it is defined, because if Avalonia UI fails to find a data template match for your data; then nothing will be displayed!
`DataType`
# UI Composition | Avalonia Docs
- Deep Dives
- UI Composition
## UI Composition
UI composition is the process you use to create the layouts that your apps require. It allows you to build a complex view from an arrangement of components. The advantages are:
- Encapsulation - reduce the complexity of each component by restricting its XAML and code to only what it needs, making your code more understandable and maintainable.
- Reuse - maintain consistent presentation and behaviour of repeated parts of your app.
Avalonia UI makes it easy for you to use UI composition to create the layouts and functions that your apps require.
When you build an app using Avalonia UI, there are several different types of component to choose from:
- Windows
- Built-in Controls
- User Controls
- Custom Controls
- Template Controls
### Windows and Built-in Controls​
A window in Avalonia UI is a basic unit of layout (for a windowing platform).
Avalonia UI contains a large number of built-in controls that will cover most of your UI requirements.
When you first meet Avalonia UI, you might place a single built-in control in the content zone of a window (above, left). This is the simplest form of UI composition: the window has the title of the app and usually some window state controls (depending on the target platform). The built-in control allows your app to receive some user input, or to present some output with layout and styling.
A slightly more complex app may require one of the built-in layout controls to arrange more than one other built-in control in the content zone of a window (above, right).
To see the full range of Avalonia UI built-in controls, see the reference section here.
### Logical and Visual Trees​
Whatever arrangement of controls you use, Avalonia UI represents their relationships as a a tree structure, with the 'outermost' control as the root. So for example, the previous UI composition can be represented as the tree shown here:
This is the logical control tree, and it represents the application controls (including the main window) in the hierarchy in which they are defined in the XAML. There are many systems in Avalonia UI that process the logical control tree and its companion the visual control tree.
For more information on the concept of control trees, see here.
### User Controls​
User controls are the mainstay of UI composition in Avalonia UI.
You can add a user control to the content zone of a main window, to represent a 'page view' (above, left). This allows you to implement a more complex app with multiple pages; where the layout and function of each page is in its own user control (XAML and code) files.
For more information about how to implement a multi-page app using views, see the guide here.
Another use for a user control is as a component control (above, right). You might initially do this to reduce the complexity of a window or page view; but then you might also (perhaps later) reuse the resulting component on another page as well.
### Tutorial​
For tutorials about DataTemplates see Avalonia.Samples.
`DataTemplates` ### Collection Controls​
Another variation of UI composition is where you need to present a collection of items.
This scenario will use one of the built-in repeating controls, bound to a collection; together with a data template to represent the items in the collection.
For information about how to TO DO
### Custom Controls​
In the unlikely scenario that you cannot find an Avalonia UI built-in control to cover your app's UI requirements, then you can 'roll-your-own' custom control from scratch. This allows you to define your own custom properties, events and methods; but it will require you to implement the drawing of the control presentation from scratch as well.
To learn how to implement a custom control, see the guide here.
### Templated Controls​
A templated control uses the Avalonia UI styling system to substitute a tag in the UI layout with a
For more information about the concepts behind the Avalonia UI styling system, see here.
- Windows and Built-in Controls
- Logical and Visual Trees
- User Controls
- Tutorial
- Collection Controls
- Custom Controls
- Templated Controls
# How To Implement Multi-page Apps | Avalonia Docs
- How-To Guides
- Development Guides
- How To Implement Multi-page Apps
## How To Implement Multi-page Apps
Content in preparation.
This guide will show you how to employ user controls as page views, and the view locator class, to implement a multiple-page application.
that is added by the Avalonia MVVM solution template.
```bash
public class ViewLocator : IDataTemplate{  public Control? Build(object? data)  {    if (data==null) return null;    var name = data.GetType().FullName!.Replace("ViewModel", "View");    var type = Type.GetType(name);    if (type != null)    {      return (Control)Activator.CreateInstance(type)!;    }    return new TextBlock { Text = "Not Found: " + name };  }  public bool Match(object? data)  {    return data is ViewModelBase;  }}
```
# Data Validation | Avalonia Docs
- How-To Guides
- Development Guides
- Data Validation
## Data Validation
Avalonia offers different data validation options. In this section we will show you how you can validate the Properties of your ViewModel and how you can style the displayed error message.
`Properties` `ViewModel` ### Validating a property​
Avalonia uses DataValidationPlugins to validate the Properties you bound to. Out of the box Avalonia provide these three validation plugins:
`DataValidationPlugins` `Properties` - DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
#### DataAnnotations - ValidationPlugin​
You can decorate the Properties of your ViewModel with different Validation-Attributes. You can use the build-in ones, use the CustomValidationAttribute or create your own by derive from ValidationAttribute.
`Properties` `ViewModel` `Validation-Attributes` `CustomValidationAttribute` `ValidationAttribute` Sample: The property EMail is required and must be a valid e-mail-address
```bash
[Required][EmailAddress]public string? EMail{  get { return _EMail; }  set { this.RaiseAndSetIfChanged(ref _EMail, value); }}
```
#### INotifyDataErrorInfo - ValidationPlugin​
Avalonia also supports validation of classes that implement INotifyDataErrorInfo. Several MVVM-libraries are using this interface for their data validation, for example the CommunityToolkit.Mvvm-package and the ReactiveUI.Validation-package. For usage instructions please visit the documentation of the MVVM-package of your choice.
`INotifyDataErrorInfo` `MVVM` `ReactiveUI.Validation` `MVVM` Some libraries like the CommunityToolkit.Mvvm use DataAnnotations for their validation. This may result in conflicts with the DataAnnotations - ValidationPlugin. Please see Manage ValidationPlugins how to solve this issue.
`CommunityToolkit.Mvvm` `DataAnnotations` #### Exception - ValidationPlugin​
One more option to validate a property is to raise an Exception inside the setter of your property.
`Exception` Sample: Validate the property EMail using Exceptions
`Exceptions` ```bash
public string? EMail{  get { return _EMail; }  set   {    if (string.IsNullOrEmpty(value))    {      throw new ArgumentNullException(nameof(EMail), "This field is required");    }    else if (!value.Contains('@'))    {      throw new ArgumentException(nameof(EMail), "Not a valid E-Mail-Address");    }    else    {       this.RaiseAndSetIfChanged(ref _EMail, value);     }   }}
```
Exceptions inside the getter of your property are not allowed and will result in a crash of your application.
### Customize the appearance of the validation message​
To display the validation messages, Avalonia has a control called DataValidationErrors. This control is typically placed inside the ControlTemplate of all Controls that supports data validation, like TextBox, Slider and other. You can create your own Style of the DataValidationErrors-control in order to customize the representation of the error messages.
`DataValidationErrors` `ControlTemplate` `Controls` `TextBox` `Slider` `Style` `DataValidationErrors` Example Style for DataValidationErrors
```bash
<Style Selector="DataValidationErrors"> <Setter Property="Template">  <ControlTemplate>   <DockPanel LastChildFill="True">    <ContentControl DockPanel.Dock="Right"            ContentTemplate="{TemplateBinding ErrorTemplate}"            DataContext="{TemplateBinding Owner}"            Content="{Binding (DataValidationErrors.Errors)}"            IsVisible="{Binding (DataValidationErrors.HasErrors)}"/>    <ContentPresenter Name="PART_ContentPresenter"             Background="{TemplateBinding Background}"             BorderBrush="{TemplateBinding BorderBrush}"             BorderThickness="{TemplateBinding BorderThickness}"             CornerRadius="{TemplateBinding CornerRadius}"             ContentTemplate="{TemplateBinding ContentTemplate}"             Content="{TemplateBinding Content}"             Padding="{TemplateBinding Padding}"/>   </DockPanel>  </ControlTemplate> </Setter> <Setter Property="ErrorTemplate">  <DataTemplate x:DataType="{x:Type x:Object}">   <Canvas Width="14" Height="14" Margin="4 0 1 0"        Background="Transparent">    <Canvas.Styles>     <Style Selector="ToolTip">      <Setter Property="Background" Value="LightRed"/>      <Setter Property="BorderBrush" Value="Red"/>     </Style>    </Canvas.Styles>    <ToolTip.Tip>     <ItemsControl ItemsSource="{Binding}"/>    </ToolTip.Tip>    <Path Data="M14,7 A7,7 0 0,0 0,7 M0,7 A7,7 0 1,0 14,7 M7,3l0,5 M7,9l0,2"        Stroke="Red"        StrokeThickness="2"/>   </Canvas>  </DataTemplate> </Setter></Style>
```
Custom validation style
### Manage ValidationPlugins​
if needed to, you can enable or disable a specific ValidationPlugin in your App. This can be useful if for example your MVVM-framework uses DataAnnotations to validate the property via INotifyDataErrorInfo. In that case you would see the message twice. Use the BindingPlugins.DataValidators-collection to add or remove a specific ValidationPlugin.
`ValidationPlugin` `DataAnnotations` `INotifyDataErrorInfo` `BindingPlugins.DataValidators` `ValidationPlugin` Example: Remove the DataAnnotations validator
```bash
public override void OnFrameworkInitializationCompleted(){  // Get an array of plugins to remove  var dataValidationPluginsToRemove =    BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();  // remove each entry found  foreach (var plugin in dataValidationPluginsToRemove)  {    BindingPlugins.DataValidators.Remove(plugin);  }  // Continue with normal startup  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)  {    desktop.MainWindow = new MainWindow()    {      DataContext = MainWindowViewModel.Instance    };  }  base.OnFrameworkInitializationCompleted();}
```
- Validating a propertyDataAnnotations - ValidationPluginINotifyDataErrorInfo - ValidationPluginException - ValidationPlugin
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
- Customize the appearance of the validation message
- Manage ValidationPlugins
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
# Data Validation | Avalonia Docs
- How-To Guides
- Development Guides
- Data Validation
## Data Validation
Avalonia offers different data validation options. In this section we will show you how you can validate the Properties of your ViewModel and how you can style the displayed error message.
`Properties` `ViewModel` ### Validating a property​
Avalonia uses DataValidationPlugins to validate the Properties you bound to. Out of the box Avalonia provide these three validation plugins:
`DataValidationPlugins` `Properties` - DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
#### DataAnnotations - ValidationPlugin​
You can decorate the Properties of your ViewModel with different Validation-Attributes. You can use the build-in ones, use the CustomValidationAttribute or create your own by derive from ValidationAttribute.
`Properties` `ViewModel` `Validation-Attributes` `CustomValidationAttribute` `ValidationAttribute` Sample: The property EMail is required and must be a valid e-mail-address
```bash
[Required][EmailAddress]public string? EMail{  get { return _EMail; }  set { this.RaiseAndSetIfChanged(ref _EMail, value); }}
```
#### INotifyDataErrorInfo - ValidationPlugin​
Avalonia also supports validation of classes that implement INotifyDataErrorInfo. Several MVVM-libraries are using this interface for their data validation, for example the CommunityToolkit.Mvvm-package and the ReactiveUI.Validation-package. For usage instructions please visit the documentation of the MVVM-package of your choice.
`INotifyDataErrorInfo` `MVVM` `ReactiveUI.Validation` `MVVM` Some libraries like the CommunityToolkit.Mvvm use DataAnnotations for their validation. This may result in conflicts with the DataAnnotations - ValidationPlugin. Please see Manage ValidationPlugins how to solve this issue.
`CommunityToolkit.Mvvm` `DataAnnotations` #### Exception - ValidationPlugin​
One more option to validate a property is to raise an Exception inside the setter of your property.
`Exception` Sample: Validate the property EMail using Exceptions
`Exceptions` ```bash
public string? EMail{  get { return _EMail; }  set   {    if (string.IsNullOrEmpty(value))    {      throw new ArgumentNullException(nameof(EMail), "This field is required");    }    else if (!value.Contains('@'))    {      throw new ArgumentException(nameof(EMail), "Not a valid E-Mail-Address");    }    else    {       this.RaiseAndSetIfChanged(ref _EMail, value);     }   }}
```
Exceptions inside the getter of your property are not allowed and will result in a crash of your application.
### Customize the appearance of the validation message​
To display the validation messages, Avalonia has a control called DataValidationErrors. This control is typically placed inside the ControlTemplate of all Controls that supports data validation, like TextBox, Slider and other. You can create your own Style of the DataValidationErrors-control in order to customize the representation of the error messages.
`DataValidationErrors` `ControlTemplate` `Controls` `TextBox` `Slider` `Style` `DataValidationErrors` Example Style for DataValidationErrors
```bash
<Style Selector="DataValidationErrors"> <Setter Property="Template">  <ControlTemplate>   <DockPanel LastChildFill="True">    <ContentControl DockPanel.Dock="Right"            ContentTemplate="{TemplateBinding ErrorTemplate}"            DataContext="{TemplateBinding Owner}"            Content="{Binding (DataValidationErrors.Errors)}"            IsVisible="{Binding (DataValidationErrors.HasErrors)}"/>    <ContentPresenter Name="PART_ContentPresenter"             Background="{TemplateBinding Background}"             BorderBrush="{TemplateBinding BorderBrush}"             BorderThickness="{TemplateBinding BorderThickness}"             CornerRadius="{TemplateBinding CornerRadius}"             ContentTemplate="{TemplateBinding ContentTemplate}"             Content="{TemplateBinding Content}"             Padding="{TemplateBinding Padding}"/>   </DockPanel>  </ControlTemplate> </Setter> <Setter Property="ErrorTemplate">  <DataTemplate x:DataType="{x:Type x:Object}">   <Canvas Width="14" Height="14" Margin="4 0 1 0"        Background="Transparent">    <Canvas.Styles>     <Style Selector="ToolTip">      <Setter Property="Background" Value="LightRed"/>      <Setter Property="BorderBrush" Value="Red"/>     </Style>    </Canvas.Styles>    <ToolTip.Tip>     <ItemsControl ItemsSource="{Binding}"/>    </ToolTip.Tip>    <Path Data="M14,7 A7,7 0 0,0 0,7 M0,7 A7,7 0 1,0 14,7 M7,3l0,5 M7,9l0,2"        Stroke="Red"        StrokeThickness="2"/>   </Canvas>  </DataTemplate> </Setter></Style>
```
Custom validation style
### Manage ValidationPlugins​
if needed to, you can enable or disable a specific ValidationPlugin in your App. This can be useful if for example your MVVM-framework uses DataAnnotations to validate the property via INotifyDataErrorInfo. In that case you would see the message twice. Use the BindingPlugins.DataValidators-collection to add or remove a specific ValidationPlugin.
`ValidationPlugin` `DataAnnotations` `INotifyDataErrorInfo` `BindingPlugins.DataValidators` `ValidationPlugin` Example: Remove the DataAnnotations validator
```bash
public override void OnFrameworkInitializationCompleted(){  // Get an array of plugins to remove  var dataValidationPluginsToRemove =    BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();  // remove each entry found  foreach (var plugin in dataValidationPluginsToRemove)  {    BindingPlugins.DataValidators.Remove(plugin);  }  // Continue with normal startup  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)  {    desktop.MainWindow = new MainWindow()    {      DataContext = MainWindowViewModel.Instance    };  }  base.OnFrameworkInitializationCompleted();}
```
- Validating a propertyDataAnnotations - ValidationPluginINotifyDataErrorInfo - ValidationPluginException - ValidationPlugin
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
- Customize the appearance of the validation message
- Manage ValidationPlugins
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
# Data Validation | Avalonia Docs
- How-To Guides
- Development Guides
- Data Validation
## Data Validation
Avalonia offers different data validation options. In this section we will show you how you can validate the Properties of your ViewModel and how you can style the displayed error message.
`Properties` `ViewModel` ### Validating a property​
Avalonia uses DataValidationPlugins to validate the Properties you bound to. Out of the box Avalonia provide these three validation plugins:
`DataValidationPlugins` `Properties` - DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
#### DataAnnotations - ValidationPlugin​
You can decorate the Properties of your ViewModel with different Validation-Attributes. You can use the build-in ones, use the CustomValidationAttribute or create your own by derive from ValidationAttribute.
`Properties` `ViewModel` `Validation-Attributes` `CustomValidationAttribute` `ValidationAttribute` Sample: The property EMail is required and must be a valid e-mail-address
```bash
[Required][EmailAddress]public string? EMail{  get { return _EMail; }  set { this.RaiseAndSetIfChanged(ref _EMail, value); }}
```
#### INotifyDataErrorInfo - ValidationPlugin​
Avalonia also supports validation of classes that implement INotifyDataErrorInfo. Several MVVM-libraries are using this interface for their data validation, for example the CommunityToolkit.Mvvm-package and the ReactiveUI.Validation-package. For usage instructions please visit the documentation of the MVVM-package of your choice.
`INotifyDataErrorInfo` `MVVM` `ReactiveUI.Validation` `MVVM` Some libraries like the CommunityToolkit.Mvvm use DataAnnotations for their validation. This may result in conflicts with the DataAnnotations - ValidationPlugin. Please see Manage ValidationPlugins how to solve this issue.
`CommunityToolkit.Mvvm` `DataAnnotations` #### Exception - ValidationPlugin​
One more option to validate a property is to raise an Exception inside the setter of your property.
`Exception` Sample: Validate the property EMail using Exceptions
`Exceptions` ```bash
public string? EMail{  get { return _EMail; }  set   {    if (string.IsNullOrEmpty(value))    {      throw new ArgumentNullException(nameof(EMail), "This field is required");    }    else if (!value.Contains('@'))    {      throw new ArgumentException(nameof(EMail), "Not a valid E-Mail-Address");    }    else    {       this.RaiseAndSetIfChanged(ref _EMail, value);     }   }}
```
Exceptions inside the getter of your property are not allowed and will result in a crash of your application.
### Customize the appearance of the validation message​
To display the validation messages, Avalonia has a control called DataValidationErrors. This control is typically placed inside the ControlTemplate of all Controls that supports data validation, like TextBox, Slider and other. You can create your own Style of the DataValidationErrors-control in order to customize the representation of the error messages.
`DataValidationErrors` `ControlTemplate` `Controls` `TextBox` `Slider` `Style` `DataValidationErrors` Example Style for DataValidationErrors
```bash
<Style Selector="DataValidationErrors"> <Setter Property="Template">  <ControlTemplate>   <DockPanel LastChildFill="True">    <ContentControl DockPanel.Dock="Right"            ContentTemplate="{TemplateBinding ErrorTemplate}"            DataContext="{TemplateBinding Owner}"            Content="{Binding (DataValidationErrors.Errors)}"            IsVisible="{Binding (DataValidationErrors.HasErrors)}"/>    <ContentPresenter Name="PART_ContentPresenter"             Background="{TemplateBinding Background}"             BorderBrush="{TemplateBinding BorderBrush}"             BorderThickness="{TemplateBinding BorderThickness}"             CornerRadius="{TemplateBinding CornerRadius}"             ContentTemplate="{TemplateBinding ContentTemplate}"             Content="{TemplateBinding Content}"             Padding="{TemplateBinding Padding}"/>   </DockPanel>  </ControlTemplate> </Setter> <Setter Property="ErrorTemplate">  <DataTemplate x:DataType="{x:Type x:Object}">   <Canvas Width="14" Height="14" Margin="4 0 1 0"        Background="Transparent">    <Canvas.Styles>     <Style Selector="ToolTip">      <Setter Property="Background" Value="LightRed"/>      <Setter Property="BorderBrush" Value="Red"/>     </Style>    </Canvas.Styles>    <ToolTip.Tip>     <ItemsControl ItemsSource="{Binding}"/>    </ToolTip.Tip>    <Path Data="M14,7 A7,7 0 0,0 0,7 M0,7 A7,7 0 1,0 14,7 M7,3l0,5 M7,9l0,2"        Stroke="Red"        StrokeThickness="2"/>   </Canvas>  </DataTemplate> </Setter></Style>
```
Custom validation style
### Manage ValidationPlugins​
if needed to, you can enable or disable a specific ValidationPlugin in your App. This can be useful if for example your MVVM-framework uses DataAnnotations to validate the property via INotifyDataErrorInfo. In that case you would see the message twice. Use the BindingPlugins.DataValidators-collection to add or remove a specific ValidationPlugin.
`ValidationPlugin` `DataAnnotations` `INotifyDataErrorInfo` `BindingPlugins.DataValidators` `ValidationPlugin` Example: Remove the DataAnnotations validator
```bash
public override void OnFrameworkInitializationCompleted(){  // Get an array of plugins to remove  var dataValidationPluginsToRemove =    BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();  // remove each entry found  foreach (var plugin in dataValidationPluginsToRemove)  {    BindingPlugins.DataValidators.Remove(plugin);  }  // Continue with normal startup  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)  {    desktop.MainWindow = new MainWindow()    {      DataContext = MainWindowViewModel.Instance    };  }  base.OnFrameworkInitializationCompleted();}
```
- Validating a propertyDataAnnotations - ValidationPluginINotifyDataErrorInfo - ValidationPluginException - ValidationPlugin
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
- Customize the appearance of the validation message
- Manage ValidationPlugins
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
# Data Validation | Avalonia Docs
- How-To Guides
- Development Guides
- Data Validation
## Data Validation
Avalonia offers different data validation options. In this section we will show you how you can validate the Properties of your ViewModel and how you can style the displayed error message.
`Properties` `ViewModel` ### Validating a property​
Avalonia uses DataValidationPlugins to validate the Properties you bound to. Out of the box Avalonia provide these three validation plugins:
`DataValidationPlugins` `Properties` - DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
#### DataAnnotations - ValidationPlugin​
You can decorate the Properties of your ViewModel with different Validation-Attributes. You can use the build-in ones, use the CustomValidationAttribute or create your own by derive from ValidationAttribute.
`Properties` `ViewModel` `Validation-Attributes` `CustomValidationAttribute` `ValidationAttribute` Sample: The property EMail is required and must be a valid e-mail-address
```bash
[Required][EmailAddress]public string? EMail{  get { return _EMail; }  set { this.RaiseAndSetIfChanged(ref _EMail, value); }}
```
#### INotifyDataErrorInfo - ValidationPlugin​
Avalonia also supports validation of classes that implement INotifyDataErrorInfo. Several MVVM-libraries are using this interface for their data validation, for example the CommunityToolkit.Mvvm-package and the ReactiveUI.Validation-package. For usage instructions please visit the documentation of the MVVM-package of your choice.
`INotifyDataErrorInfo` `MVVM` `ReactiveUI.Validation` `MVVM` Some libraries like the CommunityToolkit.Mvvm use DataAnnotations for their validation. This may result in conflicts with the DataAnnotations - ValidationPlugin. Please see Manage ValidationPlugins how to solve this issue.
`CommunityToolkit.Mvvm` `DataAnnotations` #### Exception - ValidationPlugin​
One more option to validate a property is to raise an Exception inside the setter of your property.
`Exception` Sample: Validate the property EMail using Exceptions
`Exceptions` ```bash
public string? EMail{  get { return _EMail; }  set   {    if (string.IsNullOrEmpty(value))    {      throw new ArgumentNullException(nameof(EMail), "This field is required");    }    else if (!value.Contains('@'))    {      throw new ArgumentException(nameof(EMail), "Not a valid E-Mail-Address");    }    else    {       this.RaiseAndSetIfChanged(ref _EMail, value);     }   }}
```
Exceptions inside the getter of your property are not allowed and will result in a crash of your application.
### Customize the appearance of the validation message​
To display the validation messages, Avalonia has a control called DataValidationErrors. This control is typically placed inside the ControlTemplate of all Controls that supports data validation, like TextBox, Slider and other. You can create your own Style of the DataValidationErrors-control in order to customize the representation of the error messages.
`DataValidationErrors` `ControlTemplate` `Controls` `TextBox` `Slider` `Style` `DataValidationErrors` Example Style for DataValidationErrors
```bash
<Style Selector="DataValidationErrors"> <Setter Property="Template">  <ControlTemplate>   <DockPanel LastChildFill="True">    <ContentControl DockPanel.Dock="Right"            ContentTemplate="{TemplateBinding ErrorTemplate}"            DataContext="{TemplateBinding Owner}"            Content="{Binding (DataValidationErrors.Errors)}"            IsVisible="{Binding (DataValidationErrors.HasErrors)}"/>    <ContentPresenter Name="PART_ContentPresenter"             Background="{TemplateBinding Background}"             BorderBrush="{TemplateBinding BorderBrush}"             BorderThickness="{TemplateBinding BorderThickness}"             CornerRadius="{TemplateBinding CornerRadius}"             ContentTemplate="{TemplateBinding ContentTemplate}"             Content="{TemplateBinding Content}"             Padding="{TemplateBinding Padding}"/>   </DockPanel>  </ControlTemplate> </Setter> <Setter Property="ErrorTemplate">  <DataTemplate x:DataType="{x:Type x:Object}">   <Canvas Width="14" Height="14" Margin="4 0 1 0"        Background="Transparent">    <Canvas.Styles>     <Style Selector="ToolTip">      <Setter Property="Background" Value="LightRed"/>      <Setter Property="BorderBrush" Value="Red"/>     </Style>    </Canvas.Styles>    <ToolTip.Tip>     <ItemsControl ItemsSource="{Binding}"/>    </ToolTip.Tip>    <Path Data="M14,7 A7,7 0 0,0 0,7 M0,7 A7,7 0 1,0 14,7 M7,3l0,5 M7,9l0,2"        Stroke="Red"        StrokeThickness="2"/>   </Canvas>  </DataTemplate> </Setter></Style>
```
Custom validation style
### Manage ValidationPlugins​
if needed to, you can enable or disable a specific ValidationPlugin in your App. This can be useful if for example your MVVM-framework uses DataAnnotations to validate the property via INotifyDataErrorInfo. In that case you would see the message twice. Use the BindingPlugins.DataValidators-collection to add or remove a specific ValidationPlugin.
`ValidationPlugin` `DataAnnotations` `INotifyDataErrorInfo` `BindingPlugins.DataValidators` `ValidationPlugin` Example: Remove the DataAnnotations validator
```bash
public override void OnFrameworkInitializationCompleted(){  // Get an array of plugins to remove  var dataValidationPluginsToRemove =    BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();  // remove each entry found  foreach (var plugin in dataValidationPluginsToRemove)  {    BindingPlugins.DataValidators.Remove(plugin);  }  // Continue with normal startup  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)  {    desktop.MainWindow = new MainWindow()    {      DataContext = MainWindowViewModel.Instance    };  }  base.OnFrameworkInitializationCompleted();}
```
- Validating a propertyDataAnnotations - ValidationPluginINotifyDataErrorInfo - ValidationPluginException - ValidationPlugin
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
- Customize the appearance of the validation message
- Manage ValidationPlugins
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
# Data Validation | Avalonia Docs
- How-To Guides
- Development Guides
- Data Validation
## Data Validation
Avalonia offers different data validation options. In this section we will show you how you can validate the Properties of your ViewModel and how you can style the displayed error message.
`Properties` `ViewModel` ### Validating a property​
Avalonia uses DataValidationPlugins to validate the Properties you bound to. Out of the box Avalonia provide these three validation plugins:
`DataValidationPlugins` `Properties` - DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
#### DataAnnotations - ValidationPlugin​
You can decorate the Properties of your ViewModel with different Validation-Attributes. You can use the build-in ones, use the CustomValidationAttribute or create your own by derive from ValidationAttribute.
`Properties` `ViewModel` `Validation-Attributes` `CustomValidationAttribute` `ValidationAttribute` Sample: The property EMail is required and must be a valid e-mail-address
```bash
[Required][EmailAddress]public string? EMail{  get { return _EMail; }  set { this.RaiseAndSetIfChanged(ref _EMail, value); }}
```
#### INotifyDataErrorInfo - ValidationPlugin​
Avalonia also supports validation of classes that implement INotifyDataErrorInfo. Several MVVM-libraries are using this interface for their data validation, for example the CommunityToolkit.Mvvm-package and the ReactiveUI.Validation-package. For usage instructions please visit the documentation of the MVVM-package of your choice.
`INotifyDataErrorInfo` `MVVM` `ReactiveUI.Validation` `MVVM` Some libraries like the CommunityToolkit.Mvvm use DataAnnotations for their validation. This may result in conflicts with the DataAnnotations - ValidationPlugin. Please see Manage ValidationPlugins how to solve this issue.
`CommunityToolkit.Mvvm` `DataAnnotations` #### Exception - ValidationPlugin​
One more option to validate a property is to raise an Exception inside the setter of your property.
`Exception` Sample: Validate the property EMail using Exceptions
`Exceptions` ```bash
public string? EMail{  get { return _EMail; }  set   {    if (string.IsNullOrEmpty(value))    {      throw new ArgumentNullException(nameof(EMail), "This field is required");    }    else if (!value.Contains('@'))    {      throw new ArgumentException(nameof(EMail), "Not a valid E-Mail-Address");    }    else    {       this.RaiseAndSetIfChanged(ref _EMail, value);     }   }}
```
Exceptions inside the getter of your property are not allowed and will result in a crash of your application.
### Customize the appearance of the validation message​
To display the validation messages, Avalonia has a control called DataValidationErrors. This control is typically placed inside the ControlTemplate of all Controls that supports data validation, like TextBox, Slider and other. You can create your own Style of the DataValidationErrors-control in order to customize the representation of the error messages.
`DataValidationErrors` `ControlTemplate` `Controls` `TextBox` `Slider` `Style` `DataValidationErrors` Example Style for DataValidationErrors
```bash
<Style Selector="DataValidationErrors"> <Setter Property="Template">  <ControlTemplate>   <DockPanel LastChildFill="True">    <ContentControl DockPanel.Dock="Right"            ContentTemplate="{TemplateBinding ErrorTemplate}"            DataContext="{TemplateBinding Owner}"            Content="{Binding (DataValidationErrors.Errors)}"            IsVisible="{Binding (DataValidationErrors.HasErrors)}"/>    <ContentPresenter Name="PART_ContentPresenter"             Background="{TemplateBinding Background}"             BorderBrush="{TemplateBinding BorderBrush}"             BorderThickness="{TemplateBinding BorderThickness}"             CornerRadius="{TemplateBinding CornerRadius}"             ContentTemplate="{TemplateBinding ContentTemplate}"             Content="{TemplateBinding Content}"             Padding="{TemplateBinding Padding}"/>   </DockPanel>  </ControlTemplate> </Setter> <Setter Property="ErrorTemplate">  <DataTemplate x:DataType="{x:Type x:Object}">   <Canvas Width="14" Height="14" Margin="4 0 1 0"        Background="Transparent">    <Canvas.Styles>     <Style Selector="ToolTip">      <Setter Property="Background" Value="LightRed"/>      <Setter Property="BorderBrush" Value="Red"/>     </Style>    </Canvas.Styles>    <ToolTip.Tip>     <ItemsControl ItemsSource="{Binding}"/>    </ToolTip.Tip>    <Path Data="M14,7 A7,7 0 0,0 0,7 M0,7 A7,7 0 1,0 14,7 M7,3l0,5 M7,9l0,2"        Stroke="Red"        StrokeThickness="2"/>   </Canvas>  </DataTemplate> </Setter></Style>
```
Custom validation style
### Manage ValidationPlugins​
if needed to, you can enable or disable a specific ValidationPlugin in your App. This can be useful if for example your MVVM-framework uses DataAnnotations to validate the property via INotifyDataErrorInfo. In that case you would see the message twice. Use the BindingPlugins.DataValidators-collection to add or remove a specific ValidationPlugin.
`ValidationPlugin` `DataAnnotations` `INotifyDataErrorInfo` `BindingPlugins.DataValidators` `ValidationPlugin` Example: Remove the DataAnnotations validator
```bash
public override void OnFrameworkInitializationCompleted(){  // Get an array of plugins to remove  var dataValidationPluginsToRemove =    BindingPlugins.DataValidators.OfType<DataAnnotationsValidationPlugin>().ToArray();  // remove each entry found  foreach (var plugin in dataValidationPluginsToRemove)  {    BindingPlugins.DataValidators.Remove(plugin);  }  // Continue with normal startup  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)  {    desktop.MainWindow = new MainWindow()    {      DataContext = MainWindowViewModel.Instance    };  }  base.OnFrameworkInitializationCompleted();}
```
- Validating a propertyDataAnnotations - ValidationPluginINotifyDataErrorInfo - ValidationPluginException - ValidationPlugin
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
- Customize the appearance of the validation message
- Manage ValidationPlugins
- DataAnnotations - ValidationPlugin
- INotifyDataErrorInfo - ValidationPlugin
- Exception - ValidationPlugin
# How To Access the UI Thread | Avalonia Docs
- How-To Guides
- Development Guides
- How To Access the UI Thread
## How To Access the UI Thread
This guide will show you how to access the UI thread in your Avalonia UI application.
Avalonia UI applications have one main thread, and this handles the UI. When you have a process that is intensive, or long running, then you will usually opt to run it on a different thread. Then you may have scenarios where you want to update them main UI thread (for example with progress updates).
A dispatcher provides services for managing work items on any specific thread. In Avalonia UI you will already have the dispatcher that handles the UI thread. When you need to update the UI from a different thread, you access it through this dispatcher, as follows:
```bash
Dispatcher.UIThread
```
You can use either the Post method or the InvokeAsync method to run a process on the UI thread.
`Post` `InvokeAsync` Use Post when you just want to start a job, but you do not need to wait for the job to be finished, and you do not need the result: this is the 'fire-and-forget' dispatcher method.
`Post` Use InvokeAsync when you need to wait for the result, and potentially want to receive the result.
`InvokeAsync` ### Dispatcher Priority​
Both of the above methods have a dispatcher priority parameter. You can use this with the DispatcherPriority enumeration to specify the queue priority that the given job should be given.
`DispatcherPriority` For the possible values of the DispatcherPriority enumeration, see here.
`DispatcherPriority` ### Example​
This example shows how to access the ui thread from a worker thread to update or get the text of a TextBlock. Create a new Avalonia project and replace the content of the following two files:
MainView.axaml:
```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:d="http://schemas.microsoft.com/expression/blend/2008"       xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"       xmlns:vm="clr-namespace:AvaloniaApplication1.ViewModels"       mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"       x:Class="AvaloniaApplication1.Views.MainView"       x:DataType="vm:MainViewModel"> <Design.DataContext>  <!-- This only sets the DataContext for the previewer in an IDE,     to set the actual DataContext for runtime, set the DataContext property in code (look at App.axaml.cs) -->  <vm:MainViewModel /> </Design.DataContext>	<StackPanel Margin="20">		<TextBlock Name="TextBlock1" />	</StackPanel></UserControl>
```
MainView.axaml.cs:
```bash
using Avalonia.Controls;using Avalonia.Threading;using System;using System.Threading.Tasks;namespace AvaloniaApplication1.Views;public partial class MainView : UserControl{  public MainView()  {    InitializeComponent();    // Execute OnTextFromAnotherThread on the thread pool    // to demonstrate how to access the UI thread from    // there.    _ = Task.Run(() => OnTextFromAnotherThread("test"));  }  private void SetText(string text) => TextBlock1.Text = text;  private string GetText() => TextBlock1.Text ?? "";  private async void OnTextFromAnotherThread(string text)  {    try    {      // Start the job on the ui thread and return immediately.      Dispatcher.UIThread.Post(() => SetText(text));      // Start the job on the ui thread and wait for the result.      var result = await Dispatcher.UIThread.InvokeAsync(GetText);      // This invocation would cause an exception because we are      // running on a worker thread:      // System.InvalidOperationException: 'Call from invalid thread'      //SetText(text);    }    catch (Exception)    {      throw; // Todo: Handle exception.    }  }}
```
### More Information​
For the complete API documentation about the dispatcher, see here.
View the source code on GitHub Dispatcher.cs
`Dispatcher.cs` - Dispatcher Priority
- Example
- More Information
# Add a Custom Control Class | Avalonia Docs
- How-To Guides
- Custom Controls
- Add a Custom Control Class
## Add a Custom Control Class
You create a custom control using a class that inherits from the Avalonia UI Control class. You can place your custom control classes anywhere in you app project, or include them in another control library project.
`Control` For more information on creating a custom control library, see here.
Wherever you choose to place your custom control class, you must be able to reference it in the XAML. For example, this code shows the custom control MyControl class placed in the main window; and the custom control class defines in the /CustomControls namespace and project folder:
`MyControl` `/CustomControls` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:cc="using:AvaloniaCCExample.CustomControls"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaCCExample.MainWindow"    Title="Avalonia Custom Control"> <cc:MyCustomControl Height="200" Width="300"/></Window>
```
```bash
using Avalonia.Controls;namespace AvaloniaCCExample.CustomControls{  public class MyCustomControl : Control  {  }}
```
Notice that you can already add properties for height and width of the custom control. These are from the base class: Control.
`Control` However at present, nothing shows. On the next page you will see how to define a property and teach the custom control how to draw using it.
# How To Create a Custom Controls Library | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create a Custom Controls Library
## How To Create a Custom Controls Library
This guide shows you how to create a custom controls library and reference it for use in an Avalonia UI app.
In this example, a custom control file is added to a .NET class library. The library has the Avalonia UI NuGet package installed:
- XAML
- C#
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:cc="clr-namespace:CCLibrary;assembly=CCLibrary"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaCCLib.MainWindow"    Title="AvaloniaCCLib"> <Window.Styles>  <Style Selector="cc|MyCustomControl">   <Setter Property="Background" Value="Yellow"/>  </Style> </Window.Styles> <cc:MyCustomControl Height="200" Width="300"/></Window>
```
```bash
using Avalonia;using Avalonia.Controls;using Avalonia.Media;namespace CCLibrary{  public class MyCustomControl : Control  {    public static readonly StyledProperty<IBrush?> BackgroundProperty =      Border.BackgroundProperty.AddOwner<MyCustomControl>();    public IBrush? Background    {      get { return GetValue(BackgroundProperty); }      set { SetValue(BackgroundProperty, value); }    }    public sealed override void Render(DrawingContext context)    {      if (Background != null)      {        var renderSize = Bounds.Size;        context.FillRectangle(Background, new Rect(renderSize));      }      base.Render(context);    }  }}
```
Notice that the namespace reference for the control library includes the name of the assembly.
### XML Namespace Definitions​
When you add a reference to a controls library in an Avalonia UI XAML file, you may want to use the URL identification format. For example:
```bash
xmlns:cc="https://my.controls.url"
```
This is possible because of the presence of XML namespace definitions in a controls library. These map URLs to the code namespaces, and are in the project Properties/AssemblyInfo.cs file. For example:
`Properties/AssemblyInfo.cs` ```bash
[assembly: XmlnsDefinition("https://github.com/avaloniaui", "Avalonia")]
```
You can see this in the Avalonia UI built-in controls source code here.
#### Common Namespace Definitions​
You can also make one URL map several namespaces in your controls library. To do this simply add multiple XML namespace definitions that use the same URL, but map to different code namespaces, like this:
```bash
using Avalonia.Metadata;[assembly: XmlnsDefinition("https://my.controls.url", "My.NameSpace")][assembly: XmlnsDefinition("https://my.controls.url", "My.NameSpace.Other")]
```
- XML Namespace DefinitionsCommon Namespace Definitions
- Common Namespace Definitions
# Draw with a Property | Avalonia Docs
- How-To Guides
- Custom Controls
- Draw with a Property
## Draw with a Property
On this page you will see how to draw a custom control, using the value for a simple property that defines the background color. The code now looks like this:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:cc="using:AvaloniaCCExample.CustomControls"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaCCExample.MainWindow"    Title="Avalonia Custom Control"> <cc:MyCustomControl Height="200" Width="300" Background="Red"/></Window>
```
```bash
using Avalonia.Controls;namespace AvaloniaCCExample.CustomControls{  public class MyCustomControl : Control  {    public IBrush? Background { get; set; }    public sealed override void Render(DrawingContext context)    {      if (Background != null)      {        var renderSize = Bounds.Size;        context.FillRectangle(Background, new Rect(renderSize));      }            base.Render(context);    }  }}
```
This example defines a simple brush property on the custom control for the background color. It then overrides the Render method to draw the control.
`Render` The drawing code uses the Avalonia UI graphics context (that is passed to the render method), to draw a rectangle that is filled with the background color, and made the same size as the control (as supplied by the Bounds.Size object).
`Bounds.Size` Notice how the control now shows both at runtime (above) and in the preview pane.
On the next page, you will see how to implement the background property so that it can be changed by the Avalonia UI styling system.
You can find a more advanced tutorial in Avalonia.Samples
# Defining Properties | Avalonia Docs
- How-To Guides
- Custom Controls
- Defining Properties
## Styled Property
If you are creating a custom control, you will usually want it to have properties that can be set by the Avalonia UI styling system.
For more information about how to use styles in Avalonia UI, see the guide here.
On this page, you will see how to implement a property so that it can be changed by the Avalonia UI styling system. This is a two step process:
- Register a styled property.
- Provide the getter/setter for the property.
#### Register a Styled Property​
You register a styled property by defining a static read-only field and using the AvaloniaProperty.Register method.
`AvaloniaProperty.Register` There is a convention for the name of a property. It must follow the pattern:
```bash
[AttributeName]Property
```
This means that Avalonia UI will look for an attribute in the XAML, like this:
```bash
<MyCustomControl AttributeName="value" ... >
```
For example, with a styled property in place, you can control the background color of the custom control from the window styles collection:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:cc="using:AvaloniaCCExample.CustomControls"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaCCExample.MainWindow"    Title="Avalonia Custom Control"> <Window.Styles>  <Style Selector="cc|MyCustomControl">   <Setter Property="Background" Value="Yellow"/>  </Style> </Window.Styles> <cc:MyCustomControl Height="200" Width="300"/></Window>
```
```bash
using Avalonia;using Avalonia.Controls;using Avalonia.Media;namespace AvaloniaCCExample.CustomControls{  public class MyCustomControl : Control  {    public static readonly StyledProperty<IBrush?> BackgroundProperty =      Border.BackgroundProperty.AddOwner<MyCustomControl>();    public IBrush? Background    {      get { return GetValue(BackgroundProperty); }      set { SetValue(BackgroundProperty, value); }    }    public sealed override void Render(DrawingContext context)    {      if (Background != null)      {        var renderSize = Bounds.Size;        context.FillRectangle(Background, new Rect(renderSize));      }      base.Render(context);    }  }}
```
Note that the getter/setter of the property uses the special Avalonia UI GetValue and SetValue methods.
`GetValue` `SetValue` The styled property will work both at run-time and in the preview panel.
For more advanced information about how to create a custom control, see here.
- Register a Styled Property
# How To Create Advanced Custom Controls | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create Advanced Custom Controls
## How To Create Advanced Custom Controls
Stuff clipped from the custom control guide.
Here's how the Border control defines its Background property:
`Border` `Background` The AvaloniaProperty.Register method also accepts a number of other parameters:
`AvaloniaProperty.Register` - defaultValue: This gives the property a default value. Be sure to only pass value types and immutable types here as passing a reference type will cause the same object to be used on all instances on which the property is registered.
- inherits: Specified that the property's default value should come from the parent control.
- defaultBindingMode: The default binding mode for the property. Can be set to OneWay, TwoWay, OneTime or OneWayToSource.
- validate: A validation/coercion function of type Func<TOwner, TValue, TValue>. The function accepts the instance of the class on which the property is being set and the value and returns the coerced value or throws an exception for an invalid value.
`defaultValue` `inherits` `defaultBindingMode` `OneWay` `TwoWay` `OneTime` `OneWayToSource` `validate` `Func<TOwner, TValue, TValue>` A styled property is analogous to a DependencyProperty in other XAML frameworks.
`DependencyProperty` The naming convention of the property and its backing AvaloniaProperty field is important. The name of the field is always the name of the property, with the suffix Property appended.
#### Using a StyledProperty on Another Class​
`StyledProperty` Sometimes the property you want to add to your control already exists on another control, Background being a good example. To register a property defined on another control, you call StyledProperty.AddOwner:
`Background` `StyledProperty.AddOwner` ```bash
public static readonly StyledProperty<IBrush> BackgroundProperty =  Border.BackgroundProperty.AddOwner<Panel>();public Brush Background{  get { return GetValue(BackgroundProperty); }  set { SetValue(BackgroundProperty, value); }}
```
Note: Unlike WPF/UWP, a property must be registered on a class otherwise it cannot be set on an object of that class. This may change in future, however.
#### Readonly Properties​
To create a readonly property you use the AvaloniaProperty.RegisterDirect method. Here is how Visual registers the readonly Bounds property:
`AvaloniaProperty.RegisterDirect` `Visual` `Bounds` ```bash
public static readonly DirectProperty<Visual, Rect> BoundsProperty =  AvaloniaProperty.RegisterDirect<Visual, Rect>(    nameof(Bounds),    o => o.Bounds);private Rect _bounds;public Rect Bounds{  get { return _bounds; }  private set { SetAndRaise(BoundsProperty, ref _bounds, value); }}
```
As can be seen, readonly properties are stored as a field on the object. When registering the property, a getter is passed which is used to access the property value through GetValue and then SetAndRaise is used to notify listeners to changes to the property.
`GetValue` `SetAndRaise` #### Attached Properties​
Attached properties are defined almost identically to styled properties except that they are registered using the RegisterAttached method and their accessors are defined as static methods.
`RegisterAttached` Here's how Grid defines its Grid.Column attached property:
`Grid` `Grid.Column` ```bash
public static readonly AttachedProperty<int> ColumnProperty =  AvaloniaProperty.RegisterAttached<Grid, Control, int>("Column");public static int GetColumn(Control element){  return element.GetValue(ColumnProperty);}public static void SetColumn(Control element, int value){  element.SetValue(ColumnProperty, value);}
```
#### Direct AvaloniaProperties​
As its name suggests, RegisterDirect isn't just used for registering readonly properties. You can also pass a setter to RegisterDirect to expose a standard C# property as a Avalonia property.
`RegisterDirect` `RegisterDirect` A StyledProperty which is registered using AvaloniaProperty.Register maintains a prioritized list of values and bindings that allow styles to work. However, this is overkill for many properties, such as ItemsControl.Items - this will never be styled and the overhead involved with styled properties is unnecessary.
`StyledProperty` `AvaloniaProperty.Register` `ItemsControl.Items` Here is how ItemsControl.Items is registered:
`ItemsControl.Items` ```bash
public static readonly DirectProperty<ItemsControl, IEnumerable> ItemsProperty =  AvaloniaProperty.RegisterDirect<ItemsControl, IEnumerable>(    nameof(Items),    o => o.Items,    (o, v) => o.Items = v);private IEnumerable _items = new AvaloniaList<object>();public IEnumerable Items{  get { return _items; }  set { SetAndRaise(ItemsProperty, ref _items, value); }}
```
Direct properties are a lightweight version of styled properties that support the following:
- AvaloniaObject.GetValue
- AvaloniaObject.SetValue for non-readonly properties
- PropertyChanged
- Binding (only with LocalValue priority)
- GetObservable
- AddOwner
- Metadata
They don't support the following:
- Validation/Coercion (although this could be done in the property setter)
- Overriding default values.
- Inherited values
#### Using a DirectProperty on Another Class​
In the same way that you can call AddOwner on a styled property, you can also add an owner to a direct property. Because direct properties reference fields on the control, you must also add a field for the property:
`AddOwner` ```bash
public static readonly DirectProperty<MyControl, IEnumerable> ItemsProperty =  ItemsControl.ItemsProperty.AddOwner<MyControl>(    o => o.Items,    (o, v) => o.Items = v);private IEnumerable _items = new AvaloniaList<object>();public IEnumerable Items{  get { return _items; }  set { SetAndRaise(ItemsProperty, ref _items, value); }}
```
#### When to use a Direct vs a Styled Property​
In general you should declare your properties as styled properties. However, direct properties have advantages and disadvantages:
Pros:
- No additional object is allocated per-instance for the property
- Property getter is a standard C# property getter
- Property setter is a standard C# property setter that raises an event.
- You can add data validation support
Cons:
- Cannot inherit value from parent control
- Cannot take advantage of Avalonia's styling system
- Property value is a field and as such is allocated whether the property is set on the object or not
So use direct properties when you have the following requirements:
- Property will not need to be styled
- Property will usually or always have a value
#### DataValidation support​
If you want to allow a property to validate the data and show validation error messages, the property must be implemented as a DirectProperty and validation support must be enabled (enableDataValidation: true).
`DirectProperty` `enableDataValidation: true` Example of a property with DataValidation enabled
```bash
public static readonly DirectProperty<MyControl, int> ValueProperty =  AvaloniaProperty.RegisterDirect<MyControl, int>(    nameof(Value),    o => o.Value,    (o, v) => o.Value = v,     enableDataValidation: true);
```
If you want to re-use a direct property of another class you can also enable data validation. In this case use AddOwnerWithDataValidation.
`AddOwnerWithDataValidation` Example: TextBox.TextProperty property re-uses TextBlock.TextProperty but adds validation support
```bash
public static readonly DirectProperty<TextBox, string?> TextProperty =  TextBlock.TextProperty.AddOwnerWithDataValidation<TextBox>(    o => o.Text,    (o, v) => o.Text = v,    defaultBindingMode: BindingMode.TwoWay,    enableDataValidation: true);
```
- Using a StyledProperty on Another Class
- Readonly Properties
- Attached Properties
- Direct AvaloniaProperties
- Using a DirectProperty on Another Class
- When to use a Direct vs a Styled Property
- DataValidation support
`StyledProperty`
# How To Create Advanced Custom Controls | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create Advanced Custom Controls
## How To Create Advanced Custom Controls
Stuff clipped from the custom control guide.
Here's how the Border control defines its Background property:
`Border` `Background` The AvaloniaProperty.Register method also accepts a number of other parameters:
`AvaloniaProperty.Register` - defaultValue: This gives the property a default value. Be sure to only pass value types and immutable types here as passing a reference type will cause the same object to be used on all instances on which the property is registered.
- inherits: Specified that the property's default value should come from the parent control.
- defaultBindingMode: The default binding mode for the property. Can be set to OneWay, TwoWay, OneTime or OneWayToSource.
- validate: A validation/coercion function of type Func<TOwner, TValue, TValue>. The function accepts the instance of the class on which the property is being set and the value and returns the coerced value or throws an exception for an invalid value.
`defaultValue` `inherits` `defaultBindingMode` `OneWay` `TwoWay` `OneTime` `OneWayToSource` `validate` `Func<TOwner, TValue, TValue>` A styled property is analogous to a DependencyProperty in other XAML frameworks.
`DependencyProperty` The naming convention of the property and its backing AvaloniaProperty field is important. The name of the field is always the name of the property, with the suffix Property appended.
#### Using a StyledProperty on Another Class​
`StyledProperty` Sometimes the property you want to add to your control already exists on another control, Background being a good example. To register a property defined on another control, you call StyledProperty.AddOwner:
`Background` `StyledProperty.AddOwner` ```bash
public static readonly StyledProperty<IBrush> BackgroundProperty =  Border.BackgroundProperty.AddOwner<Panel>();public Brush Background{  get { return GetValue(BackgroundProperty); }  set { SetValue(BackgroundProperty, value); }}
```
Note: Unlike WPF/UWP, a property must be registered on a class otherwise it cannot be set on an object of that class. This may change in future, however.
#### Readonly Properties​
To create a readonly property you use the AvaloniaProperty.RegisterDirect method. Here is how Visual registers the readonly Bounds property:
`AvaloniaProperty.RegisterDirect` `Visual` `Bounds` ```bash
public static readonly DirectProperty<Visual, Rect> BoundsProperty =  AvaloniaProperty.RegisterDirect<Visual, Rect>(    nameof(Bounds),    o => o.Bounds);private Rect _bounds;public Rect Bounds{  get { return _bounds; }  private set { SetAndRaise(BoundsProperty, ref _bounds, value); }}
```
As can be seen, readonly properties are stored as a field on the object. When registering the property, a getter is passed which is used to access the property value through GetValue and then SetAndRaise is used to notify listeners to changes to the property.
`GetValue` `SetAndRaise` #### Attached Properties​
Attached properties are defined almost identically to styled properties except that they are registered using the RegisterAttached method and their accessors are defined as static methods.
`RegisterAttached` Here's how Grid defines its Grid.Column attached property:
`Grid` `Grid.Column` ```bash
public static readonly AttachedProperty<int> ColumnProperty =  AvaloniaProperty.RegisterAttached<Grid, Control, int>("Column");public static int GetColumn(Control element){  return element.GetValue(ColumnProperty);}public static void SetColumn(Control element, int value){  element.SetValue(ColumnProperty, value);}
```
#### Direct AvaloniaProperties​
As its name suggests, RegisterDirect isn't just used for registering readonly properties. You can also pass a setter to RegisterDirect to expose a standard C# property as a Avalonia property.
`RegisterDirect` `RegisterDirect` A StyledProperty which is registered using AvaloniaProperty.Register maintains a prioritized list of values and bindings that allow styles to work. However, this is overkill for many properties, such as ItemsControl.Items - this will never be styled and the overhead involved with styled properties is unnecessary.
`StyledProperty` `AvaloniaProperty.Register` `ItemsControl.Items` Here is how ItemsControl.Items is registered:
`ItemsControl.Items` ```bash
public static readonly DirectProperty<ItemsControl, IEnumerable> ItemsProperty =  AvaloniaProperty.RegisterDirect<ItemsControl, IEnumerable>(    nameof(Items),    o => o.Items,    (o, v) => o.Items = v);private IEnumerable _items = new AvaloniaList<object>();public IEnumerable Items{  get { return _items; }  set { SetAndRaise(ItemsProperty, ref _items, value); }}
```
Direct properties are a lightweight version of styled properties that support the following:
- AvaloniaObject.GetValue
- AvaloniaObject.SetValue for non-readonly properties
- PropertyChanged
- Binding (only with LocalValue priority)
- GetObservable
- AddOwner
- Metadata
They don't support the following:
- Validation/Coercion (although this could be done in the property setter)
- Overriding default values.
- Inherited values
#### Using a DirectProperty on Another Class​
In the same way that you can call AddOwner on a styled property, you can also add an owner to a direct property. Because direct properties reference fields on the control, you must also add a field for the property:
`AddOwner` ```bash
public static readonly DirectProperty<MyControl, IEnumerable> ItemsProperty =  ItemsControl.ItemsProperty.AddOwner<MyControl>(    o => o.Items,    (o, v) => o.Items = v);private IEnumerable _items = new AvaloniaList<object>();public IEnumerable Items{  get { return _items; }  set { SetAndRaise(ItemsProperty, ref _items, value); }}
```
#### When to use a Direct vs a Styled Property​
In general you should declare your properties as styled properties. However, direct properties have advantages and disadvantages:
Pros:
- No additional object is allocated per-instance for the property
- Property getter is a standard C# property getter
- Property setter is a standard C# property setter that raises an event.
- You can add data validation support
Cons:
- Cannot inherit value from parent control
- Cannot take advantage of Avalonia's styling system
- Property value is a field and as such is allocated whether the property is set on the object or not
So use direct properties when you have the following requirements:
- Property will not need to be styled
- Property will usually or always have a value
#### DataValidation support​
If you want to allow a property to validate the data and show validation error messages, the property must be implemented as a DirectProperty and validation support must be enabled (enableDataValidation: true).
`DirectProperty` `enableDataValidation: true` Example of a property with DataValidation enabled
```bash
public static readonly DirectProperty<MyControl, int> ValueProperty =  AvaloniaProperty.RegisterDirect<MyControl, int>(    nameof(Value),    o => o.Value,    (o, v) => o.Value = v,     enableDataValidation: true);
```
If you want to re-use a direct property of another class you can also enable data validation. In this case use AddOwnerWithDataValidation.
`AddOwnerWithDataValidation` Example: TextBox.TextProperty property re-uses TextBlock.TextProperty but adds validation support
```bash
public static readonly DirectProperty<TextBox, string?> TextProperty =  TextBlock.TextProperty.AddOwnerWithDataValidation<TextBox>(    o => o.Text,    (o, v) => o.Text = v,    defaultBindingMode: BindingMode.TwoWay,    enableDataValidation: true);
```
- Using a StyledProperty on Another Class
- Readonly Properties
- Attached Properties
- Direct AvaloniaProperties
- Using a DirectProperty on Another Class
- When to use a Direct vs a Styled Property
- DataValidation support
`StyledProperty`
# How To Create a Custom Flyout | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create a Custom Flyout
## How To Create a Custom Flyout
### Creating Custom Flyouts​
To create a custom flyout type, derive from FlyoutBase. You'll have to override the abstract method CreatePresenter() to specify the presenter the Flyout should use to display its content. This can be any type of control, but note that this is the root content for the inner popup and should be styled with background, border, corner radius, etc. to match other popups. You can still use a normal FlyoutPresenter if you wish
`CreatePresenter()` `Flyout` `FlyoutPresenter` The following example creates a simple Flyout that hosts an image
`Flyout` ```bash
public class MyImageFlyout : FlyoutBase{  public static readonly StyledProperty<IImage> ImageProperty = AvaloniaProperty.Register<MyImageFlyout, IImage>(nameof(Image));  [Content]  public IImage Image { get; set; }  protected override Control CreatePresenter()  {    // In this example, we'll use the default FlyoutPresenter as the root content, and add an Image control to show our content    return new FlyoutPresenter    {      Content = new Image      {        // Use binding here so the image automatically updates when the property updates        [!Image.SourceProperty] = this[!ImageProperty]      }    };  }}
```
- Creating Custom Flyouts
# How To Create Attached Properties | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create Attached Properties
## How To Create Attached Properties
When you need more or let's say foreign properties on avalonia elements, then attached properties are the right thing to use. They can also be used to create so called behaviors to generally modify the hosted gui components. This can be utilized to bind a command to an event for instance.
Here we present an example of how to use a command in an MVVM compatible way and bind it to an event.
It may not be the ideal solution as there are projects such as Avalonia Behaviors where this is properly done. But it illustrates the following two learnings:
- How to create attached properties in Avalonia UI
- How to use them in a MVVM way.
First we have to create our attached property. The method AvaloniaProperty.RegisterAttached is used for that purpose. Note that by convention the public static CLR-property for the attached property is named XxxxProperty. Also note that by convention the name (the parameter) of the attached property is Xxxx without the Property. And finally note that by convention one must provide two public static methods called SetXxxx(element,value) and GetXxxx(element).
`AvaloniaProperty.RegisterAttached` This call ensures that the property has a type, an owner type and one where it may be used.
The verify method can be used to clean up a value that is being set. Either by returning the corrected value or discard the process by returning AvaloniaProperty.UnsetValue. Or one can perform special tasks with the element that the property is hosted by. The getter and setter methods should always just set the value and never do anything beyond. In fact they will usually never be called as the Binding system will recognize the convention and set the properties directly where they are stored.
`AvaloniaProperty.UnsetValue` In this example file we create two attached properties that interact with each other: A Command property and a CommandParameter that is used by when invoking the command.
```bash
/// <summary>/// Container class for attached properties. Must inherit from <see cref="AvaloniaObject"/>./// </summary>public class DoubleTappedBehav : AvaloniaObject{  static DoubleTappedBehav()  {    CommandProperty.Changed.AddClassHandler<Interactive>(HandleCommandChanged);  }  /// <summary>  /// Identifies the <seealso cref="CommandProperty"/> avalonia attached property.  /// </summary>  /// <value>Provide an <see cref="ICommand"/> derived object or binding.</value>  public static readonly AttachedProperty<ICommand> CommandProperty = AvaloniaProperty.RegisterAttached<DoubleTappedBehav, Interactive, ICommand>(    "Command", default(ICommand), false, BindingMode.OneTime);  /// <summary>  /// Identifies the <seealso cref="CommandParameterProperty"/> avalonia attached property.  /// Use this as the parameter for the <see cref="CommandProperty"/>.  /// </summary>  /// <value>Any value of type <see cref="object"/>.</value>  public static readonly AttachedProperty<object> CommandParameterProperty = AvaloniaProperty.RegisterAttached<DoubleTappedBehav, Interactive, object>(    "CommandParameter", default(object), false, BindingMode.OneWay, null);  /// <summary>  /// <see cref="CommandProperty"/> changed event handler.  /// </summary>  private static void HandleCommandChanged(Interactive interactElem, AvaloniaPropertyChangedEventArgs args)  {    if (args.NewValue is ICommand commandValue)    {       // Add non-null value       interactElem.AddHandler(InputElement.DoubleTappedEvent, Handler);    }    else    {       // remove prev value       interactElem.RemoveHandler(InputElement.DoubleTappedEvent, Handler);    }    // local handler fcn    static void Handler(object s, RoutedEventArgs e)    {      if (s is Interactive interactElem)      {        // This is how we get the parameter off of the gui element.        object commandParameter = interactElem.GetValue(CommandParameterProperty);        ICommand commandValue = interactElem.GetValue(CommandProperty);        if (commandValue?.CanExecute(commandParameter) == true)        {          commandValue.Execute(commandParameter);        }      }    }  }  /// <summary>  /// Accessor for Attached property <see cref="CommandProperty"/>.  /// </summary>  public static void SetCommand(AvaloniaObject element, ICommand commandValue)  {    element.SetValue(CommandProperty, commandValue);  }  /// <summary>  /// Accessor for Attached property <see cref="CommandProperty"/>.  /// </summary>  public static ICommand GetCommand(AvaloniaObject element)  {    return element.GetValue(CommandProperty);  }  /// <summary>  /// Accessor for Attached property <see cref="CommandParameterProperty"/>.  /// </summary>  public static void SetCommandParameter(AvaloniaObject element, object parameter)  {    element.SetValue(CommandParameterProperty, parameter);  }  /// <summary>  /// Accessor for Attached property <see cref="CommandParameterProperty"/>.  /// </summary>  public static object GetCommandParameter(AvaloniaObject element)  {    return element.GetValue(CommandParameterProperty);  }}
```
In the verify method we utilize the routed event system to attach a new handler. Note that the handler should be detached, again. The value of the property is requested by the normal program mechanisms using GetValue() method.
`GetValue()` This example UI shows how to use the attached property. After making the namespace known to the XAML compiler it can be used by qualifying it with a dot. Then bindings can be used.
```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:loc="clr-namespace:MyApp.Behaviors"       x:Class="MyApp.Views.TestView">  <ListBox ItemsSource="{Binding Accounts}"       SelectedIndex="{Binding SelectedAccountIdx, Mode=TwoWay}"       loc:DoubleTappedBehav.Command="{Binding EditCommand}"       loc:DoubleTappedBehav.CommandParameter="test77"       >   <ListBox.ItemTemplate>    <DataTemplate>     <TextBlock Text="{Binding }" />         </DataTemplate>   </ListBox.ItemTemplate>  </ListBox></UserControl>
```
Although the CommandParameter only uses a static value, it can be used with binding, too. When used with this view model, the EditCommandExecuted will run once a double click happens.
`CommandParameter` `EditCommandExecuted` ```bash
public class TestViewModel : ReactiveObject{  public ObservableCollection<Profile> Accounts { get; } = new ObservableCollection<Profile>();  public ReactiveCommand<object, Unit> EditCommand { get; set; }  public TestViewModel()  {    EditCommand = ReactiveCommand.CreateFromTask<object, Unit>(EditCommandExecuted);  }  private async Task<Unit> EditCommandExecuted(object p)  {    // p contains "test77"    return Unit.Default;  }}
```
# How To Create Templated Controls | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create Templated Controls
## How To Create Templated Controls
### Data Binding​
When you're creating a control template and you want to bind to the templated parent you can use:
```bash
<TextBlock Name="tb" Text="{TemplateBinding Caption}"/><!-- Which is the same as --><TextBlock Name="tb" Text="{Binding Caption, RelativeSource={RelativeSource TemplatedParent}}"/>
```
Although the two syntaxes shown here are equivalent in most cases, there are some differences:
- TemplateBinding accepts only a single property rather than a property path, so if you want to bind using a property path you must use the second syntax: <!-- This WON'T work as TemplateBinding only accepts single properties --><TextBlock Name="tb" Text="{TemplateBinding Caption.Length}"/><!-- Instead this syntax must be used in this case --><TextBlock Name="tb" Text="{Binding Caption.Length, RelativeSource={RelativeSource TemplatedParent}}"/>
- A TemplateBinding only supports OneWay mode for performance reasons (this is the same as WPF). This means a TemplateBinding is actually equivalent to {Binding RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}. If TwoWay binding is required in a control template, the full syntax is needed as shown below. Note that Binding will also use the default binding mode unlike TemplateBinding. {Binding RelativeSource={RelativeSource TemplatedParent}, Mode=TwoWay}
- TemplateBinding can only be used on IStyledElement.
TemplateBinding accepts only a single property rather than a property path, so if you want to bind using a property path you must use the second syntax:
`TemplateBinding` ```bash
<!-- This WON'T work as TemplateBinding only accepts single properties --><TextBlock Name="tb" Text="{TemplateBinding Caption.Length}"/><!-- Instead this syntax must be used in this case --><TextBlock Name="tb" Text="{Binding Caption.Length, RelativeSource={RelativeSource TemplatedParent}}"/>
```
A TemplateBinding only supports OneWay mode for performance reasons (this is the same as WPF). This means a TemplateBinding is actually equivalent to {Binding RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}. If TwoWay binding is required in a control template, the full syntax is needed as shown below. Note that Binding will also use the default binding mode unlike TemplateBinding.
`TemplateBinding` `OneWay` `TemplateBinding` `{Binding RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}` `TwoWay` `Binding` `TemplateBinding` ```bash
{Binding RelativeSource={RelativeSource TemplatedParent}, Mode=TwoWay}
```
TemplateBinding can only be used on IStyledElement.
`TemplateBinding` `IStyledElement` ```bash
<!-- This WON'T work as GeometryDrawing is not a IStyledElement. --><GeometryDrawing Brush="{TemplateBinding Foreground}"/><!-- Instead this syntax must be used in this case. --><GeometryDrawing Brush="{Binding Foreground, RelativeSource={RelativeSource TemplatedParent}}"/>
```
- Data Binding
# How To Create a Custom Control | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create a Custom Control
## How To Create a Custom Control
This guide will show you how to create a simple custom control with Avalonia UI.
Before you start to create your own control, you must decide which type of custom control you want to implement, the choices are:
- Custom Control
- Templated Custom Control
#### Custom Control​
A custom control draws itself using the Avalonia UI graphics system, using basic methods for shapes, lines, fills, text, and many others. You can define your own properties, events and pseudo classes.
Some of the Avalonia UI built-in controls are like this. For example, the text block control (TextBlock class) and the image control (Image class).
`TextBlock` `Image` #### Templated Custom Controls​
A templated custom control creates a 'look-less' control that can be styled by themes or style dictionaries included in your project. The control has code for properties and events, and processing, but no properties or instructions about how to draw. A templated control defers to a theme or styles to select properties like brush colors, line thickness, corner radius etc. The drawing instructions are in the theme.
The majority of the Avalonia UI built-in controls are templated.
For guidance on how to create templated controls, see here.
The following pages show you how to create a simple custom control (inherited from Control).
`Control` - Custom Control
- Templated Custom Controls
# Creating Controls | Avalonia Docs
- Basics
- User Interface
- Controls
- Creating Controls
## Creating Controls
# Defining Properties | Avalonia Docs
- Basics
- User Interface
- Controls
- Creating Controls
- Defining Properties
## Defining Properties
Control properties in Avalonia UI allow you to expose configurable aspects of your custom controls, enabling users of your controls to customize their behavior and appearance. This document will introduce the process of defining properties for your custom controls.
### Styled Properties​
Styled properties in Avalonia offer a powerful and flexible way to define properties for controls. These properties are specifically designed to support the Avalonia styling system and data binding. Styled properties in Avalonia are registered using the AvaloniaProperty class.
`AvaloniaProperty` Styled Avalonia properties have the following key characteristics:
- Styling Support: They can be easily targeted and modified using styles, and setters defined in XAML or programmatically. Inheritance: They support inheritance, meaning that a property value defined on a parent control can be automatically inherited by its child controls unless explicitly overridden.
- Default Values: They can have default values specified at the control level or within control templates, ensuring consistent behavior across multiple instances of the control.
- Property Value Precedence: They follow a well-defined precedence order, allowing values to be resolved based on factors such as local values, style setters, triggers, and default values. Styled Avalonia properties are commonly used for control properties that are intended to be easily customizable through styling, allowing for dynamic changes in appearance and behavior based on various conditions.
- Validation and Coercion: Styled properties allow a control to validate and coerce the values passed to it, ensuring that the control is never in an invalid state.
Styling Support: They can be easily targeted and modified using styles, and setters defined in XAML or programmatically. Inheritance: They support inheritance, meaning that a property value defined on a parent control can be automatically inherited by its child controls unless explicitly overridden.
Default Values: They can have default values specified at the control level or within control templates, ensuring consistent behavior across multiple instances of the control.
Property Value Precedence: They follow a well-defined precedence order, allowing values to be resolved based on factors such as local values, style setters, triggers, and default values. Styled Avalonia properties are commonly used for control properties that are intended to be easily customizable through styling, allowing for dynamic changes in appearance and behavior based on various conditions.
Validation and Coercion: Styled properties allow a control to validate and coerce the values passed to it, ensuring that the control is never in an invalid state.
### Example​
Here's an example of how to define a custom styled property for a hypothetical custom button control:
```bash
public class MyCustomButton : Button{  public static readonly StyledProperty<int> RepeatCountProperty =    AvaloniaProperty.Register<MyCustomButton, int>(nameof(RepeatCount), defaultValue: 1);  public int RepeatCount  {    get => GetValue(RepeatCountProperty);    set => SetValue(RepeatCountProperty, value);  }}
```
In this example, a custom property called RepeatCount is defined as an integer property for the MyCustomButton control. The property is registered using the AvaloniaProperty system, allowing it to be accessed, modified, styled, and data-bound by users of the control. A CLR property is also defined for convenience, allowing the property to be consumed in manner consistent with standard .NET APIs.
`RepeatCount` `MyCustomButton` `AvaloniaProperty` ### Further Reading​
For more information see the Defining Properties How-To
- Styled Properties
- Example
- Further Reading
# Creating Controls | Avalonia Docs
- Basics
- User Interface
- Controls
- Creating Controls
## Creating Controls
# Defining Events | Avalonia Docs
- Basics
- User Interface
- Controls
- Creating Controls
- Defining Events
## Defining Events
Events in Avalonia allow your custom controls to communicate and notify users of specific actions or occurrences. By defining events, you provide a way for users of your controls to respond and react to these events within their applications. This document will guide you through the process of defining events for your custom controls.
### Routed Event​
Routed events in Avalonia offer a mechanism for handling events that can travel (or "route") through the control tree, allowing multiple controls to respond to the same event. Routed events provide the following key features:
- Event Routing: Routed events can propagate up the tree (bubbling) or down the tree (tunneling), enabling controls at different levels to handle the same event. This allows for more flexible and centralized event handling.
- Event Handlers: Routed events use event handlers to respond to events. Event handlers are associated with specific controls or can be attached at higher levels in the visual tree to handle events from multiple controls.
- Handled State: Routed events have a Handled property that can be used to mark an event as handled, preventing further propagation. This allows fine-grained control over event handling.
- Event Routing Strategies: Avalonia supports different routing strategies for routed events, such as bubbling, tunneling, and direct routing. These strategies determine the order in which controls receive and handle events. Avalonia routed events are particularly useful when you need to handle events that may occur within nested controls or when you want to centralize event handling logic higher up in the visual tree.
Event Routing: Routed events can propagate up the tree (bubbling) or down the tree (tunneling), enabling controls at different levels to handle the same event. This allows for more flexible and centralized event handling.
Event Handlers: Routed events use event handlers to respond to events. Event handlers are associated with specific controls or can be attached at higher levels in the visual tree to handle events from multiple controls.
Handled State: Routed events have a Handled property that can be used to mark an event as handled, preventing further propagation. This allows fine-grained control over event handling.
`Handled` Event Routing Strategies: Avalonia supports different routing strategies for routed events, such as bubbling, tunneling, and direct routing. These strategies determine the order in which controls receive and handle events. Avalonia routed events are particularly useful when you need to handle events that may occur within nested controls or when you want to centralize event handling logic higher up in the visual tree.
### Example​
Here's an example of how to define a routed event for a hypothetical custom slider control:
```bash
public class MyCustomSlider : Control{  public static readonly RoutedEvent<RoutedEventArgs> ValueChangedEvent =    RoutedEvent.Register<MyCustomSlider, RoutedEventArgs>(nameof(ValueChanged), RoutingStrategies.Direct);  public event EventHandler<RoutedEventArgs> ValueChanged  {    add => AddHandler(ValueChangedEvent, value);    remove => RemoveHandler(ValueChangedEvent, value);  }  protected virtual void OnValueChanged()  {    RoutedEventArgs args = new RoutedEventArgs(ValueChangedEvent);    RaiseEvent(args);  }}
```
In this example, a custom routed event called ValueChangedEvent is defined for the MyCustomSlider control. The event is registered using the RoutedEvent system, allowing it to be subscribed by users of the control. A CLR event is also defined for convenience, allowing the event to be consumed in manner consistent with standard .NET APIs.
`ValueChangedEvent` `MyCustomSlider` `RoutedEvent` ### Further Reading​
For more information see the Routed Events Deep Dive
- Routed Event
- Example
- Further Reading
# Defining a ControlTheme | Avalonia Docs
- Basics
- User Interface
- Controls
- Creating Controls
- Defining a ControlTheme
## Defining a ControlTheme
Avalonia allows you to define custom control themes to customize the appearance and style of your controls. In particular, a lookless control will have no visual representation without a control theme; however you can define control themes for all types of control.
See the introduction to control themes for more information.
# Built-in Controls | Avalonia Docs
- Basics
- User Interface
- Controls
- Built-in Controls
## Built-in Controls
Here are some of the more commonly-used Avalonia controls, organized by category:
### Layout controls​
### Buttons​
### Repeating Data Controls​
These controls display repeating data, in either a tabular or list format:
### Text display and editing​
### Value selection​
### Displaying images​
`Foreground` ### Menus and Popups​
- Layout controls
- Buttons
- Repeating Data Controls
- Text display and editing
- Value selection
- Displaying images
- Menus and Popups
# Canvas | Avalonia Docs
- Reference
- Controls Reference
- Canvas
## Canvas
The canvas control displays its child controls at specified positions (given as coordinates).
The position of each child control is defined as two distances between the edge of the canvas content zone, and the outer edge of the child margin zone. For example, this might be the top-left corner of the child to the top-left of canvas, as shown here:
To review the concept of layout zones, see here.
### Useful Properties​
You will probably use these properties most often:
`Canvas.Left` `Canvas.Top` `Canvas.Right` `Canvas.Bottom` `Canvas.ZIndex` Child controls in a canvas are drawn in the sequence that they are defined. This can cause them to overlap.
The canvas does not size any of its child controls. You must set width and height properties on a child control, or it will not appear!
### Z-index​
By default each child has a z-index of zero. However, the canvas supports the Canvas.ZIndex attached property that you can set any of the child controls. This will override the drawing sequence (highest number is drawn last) and may therefore change how the child controls overlap.
`Canvas.ZIndex` ### Opacity​
However you define the drawing sequence, the opacity of child controls is respected. This means that where child controls elements overlap, the contents shown in overlap areas might be blended where the top control has an opacity value less than one.
### Example​
```bash
<Canvas Background="AliceBlue" Margin="20"> <Rectangle Fill="Red" Height="100" Width="100" Margin="10"/> <Rectangle Fill="Blue" Height="100" Width="100" Opacity="0.5"       Canvas.Left="50" Canvas.Top="20"/> <Rectangle Fill="Green" Height="100" Width="100"       Canvas.Left="60" Margin="40" Canvas.Top="40"/> <Rectangle Fill="Orange" Height="100" Width="100"       Canvas.Right="70" Canvas.Bottom="60"/></Canvas>
```
The result looks like this:
Use the canvas panel with discretion. While it may be convenient to position child controls like this, your UI will no longer be adaptive to changes in the app window size.
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Canvas.cs
`Canvas.cs` - Useful Properties
- Z-index
- Opacity
- Example
- More Information
# CalendarDatePicker | Avalonia Docs
- Reference
- Controls Reference
- Calendar
- CalendarDatePicker
## CalendarDatePicker
This is an extension of the calendar control that includes a text box and button. The calendar shows when the user clicks the button (and hides on a subsequent click). The selected date shows in the text box when a date on the calendar is clicked.
The user can also enter a date by typing in the text box. The date picker is able to process multiple date formats into the format that is displayed as a watermark when there is no selected date.
For details on the calendar part of this control, see the previous reference here.
### Example​
This example shows a basic single date selection calendar when the button is clicked:
```bash
<StackPanel Margin="20"> <CalendarDatePicker /></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/calendardatepicker-6bb6161d360af2136db4afe749ca7dab.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub CalendarDatePicker.cs
`CalendarDatePicker.cs` - Example
- More Information
# Carousel | Avalonia Docs
- Reference
- Controls Reference
- Carousel
## Carousel
The carousel has an items collection, and displays each item as a page, in sequence, so that it fills the control.
You can use the carousel control to create a slide show.
### Useful Properties​
You will probably use these properties most often:
`ItemsSource` `ItemsControl.ItemTemplate` `ItemsControl.ItemPanel` `ItemsControl.Styles` ### Example​
This example has three images in the items collection, with buttons to move the display forwards and back. The buttons have click event handlers in the C# code-behind.
```bash
<Panel>  <Carousel Name="slides" >   <Carousel.PageTransition >    <CompositePageTransition>     <PageSlide Duration="0:00:01.500" Orientation="Horizontal" />    </CompositePageTransition>   </Carousel.PageTransition>   <Carousel.Items>    <Image Source="avares://AvaloniaControls/Assets/pipes.jpg" />    <Image Source="avares://AvaloniaControls/Assets/controls.jpg" />    <Image Source="avares://AvaloniaControls/Assets/vault.jpg" />   </Carousel.Items>  </Carousel>  <Panel Margin="20">   <Button Background="White" Click="Previous">&lt;</Button>   <Button Background="White" Click="Next"        HorizontalAlignment="Right">&gt;</Button>  </Panel> </Panel>
```
```bash
using Avalonia.Controls;using Avalonia.Interactivity;namespace AvaloniaControls.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();    }    public void Next(object source, RoutedEventArgs args)    {      slides.Next();    }    public void Previous(object source, RoutedEventArgs args)     {      slides.Previous();    }  }}
```
![](https://docs.avaloniaui.net/assets/images/carousel-aed768a7b8926ff3ca171b7fd0e7a603.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Carousel.cs
`Carousel.cs` - Useful Properties
- Example
- More Information
# CheckBox | Avalonia Docs
- Reference
- Controls Reference
- CheckBox
## CheckBox
The CheckBox control presents a Boolean value where the true value is represented using a check mark, and the false value is an empty box. The check box has an option to present a nullable Boolean, where the null value represents 'unknown' and is drawn as a shaded box.
`CheckBox` Click interaction toggles the value in the sequence: checked, unchecked, unknown (if three-state).
### Useful Properties​
You will probably use these properties most often:
`IsChecked` `IsThreeState` ### Examples​
This is an example of two-state check boxes:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaAppTemplate.MainWindow"    Title="CheckBox sample">  <StackPanel Margin="20">    <CheckBox>Not checked by default</CheckBox>    <CheckBox IsChecked="True">Checked by default</CheckBox>  </StackPanel></Window>
```
Looks like this when running on Windows:
![](https://docs.avaloniaui.net/assets/images/checkbox-two-state-8911331ad2605df323fb7cc980420827.gif)
This is an example of a three-state checkbox:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaAppTemplate.MainWindow"    Title="CheckBox sample">  <StackPanel Margin="20">    <CheckBox IsThreeState="True" IsChecked="False">Not checked by default</CheckBox>    <CheckBox IsThreeState="True" IsChecked="True">Checked by default</CheckBox>    <CheckBox IsThreeState="True" IsChecked="{x:Null}">Unknown by default</CheckBox>  </StackPanel></Window>
```
Looks like this when running on Windows:
![](https://docs.avaloniaui.net/assets/images/checkbox-three-state-1400f7da8fc07db99fe236cc1c078ed4.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub CheckBox.cs
`CheckBox.cs` - Useful Properties
- Examples
- More Information
# ColorPicker | Avalonia Docs
- Reference
- Controls Reference
- ColorPicker
## ColorPicker
The ColorPicker provides a highly customizable, general-purpose control that users can use to select colors in RGB or HSV color space. This implementation is just as much about providing primitive controls that developers can use to build their own color pickers as it is about providing a ready-to-use picker.
`ColorPicker` The ColorPicker includes a family of controls (components):
`ColorPicker` - ColorSpectrum (primitive) : A two dimensional spectrum for color selection.
- ColorSlider (primitive) : A slider with a background that represents a single color component.
- ColorPreviewer (primitive) : Shows a preview color with optional accent colors.
- ColorView : Presents a color for user editing using a spectrum, palette and component sliders.
- ColorPicker : Presents a color for user editing using a spectrum, palette and component sliders within a drop down. Editing is available when the drop down flyout is opened; otherwise, only the preview color is shown.
`ColorSpectrum` `ColorSlider` `ColorPreviewer` `ColorView` `ColorPicker` Each primitive component can be used on its own and mixed/matched with others. This allows significant composability that isn't possible with other color picker implementations. For example, you can quickly bind together the ColorSpectrum, ColorSlider and ColorPreviewer primitives to create your own color picker with a brand-new design.
`ColorSpectrum` `ColorSlider` `ColorPreviewer` Note on terminology: "color picker" usually refers to the family of controls while ColorPicker refers to the specific control.
`ColorPicker` ### Is this the right control?​
This control is intended to be used directly to select colors in a user-friendly, developer customizable way. This can be done using either a canvas-type ColorView control or a compact ColorPicker drop down.
`ColorView` `ColorPicker` For apps with even more special-purpose needs, each control and primitive component can be independently customized to create a new color picker without having to re-implement all the advanced rendering and color logic. This is very useful to match a specific app's design and usability requirements.
Developers using this control may:
- Use ColorView or ColorPicker as-is directly in their apps
- Customize ColorView or ColorPicker using the included properties. These properties allow significant changes to the control such as disabling components sliders, showing different palettes or hiding all but the spectrum tab.
- Create a new color picker to meet a specific app's design and usability requirements using the existing primitive components.
- Re-template the existing components to create a brand-new fully customized color picker.
`ColorView` `ColorPicker` `ColorView` `ColorPicker` ### Using in Your App​
Avalonia is used in several resource-constrained environments such as embedded devices. For this and other reasons, certain larger controls such as the ColorPicker are not included with the main Avalonia UI NuGet packages. This means a bit of extra work is required to add the ColorPicker to your app:
`ColorPicker` `ColorPicker` - Add the Avalonia.Controls.ColorPicker nuget to your project. This MUST match your version of Avalonia's other packages.
- Add control themes and styles for all color picker controls in App.axaml by adding: <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Fluent/Fluent.xaml" /> for Fluent themes OR <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Simple/Simple.xaml" /> for Simple themes
- <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Fluent/Fluent.xaml" /> for Fluent themes OR
- <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Simple/Simple.xaml" /> for Simple themes
`Avalonia.Controls.ColorPicker` `App.axaml` - <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Fluent/Fluent.xaml" /> for Fluent themes OR
- <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Simple/Simple.xaml" /> for Simple themes
`<StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Fluent/Fluent.xaml" />` `<StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Simple/Simple.xaml" />` This step is not required for some theme packages such as FluentAvalonia which include all controls by default.
### Background​
This control originated as a re-styling of the one in UWP (later WinUI) using the basic designs implemented for the Windows Community Toolkit. The WinUI ColorPicker isn't conducive to smaller screen sizes and the overall design/usability of the control left something to be desired for both users and developers.
`ColorPicker` With all its features, the WinUI control still wasn't as good as it should be. It couldn't be re-templated and customized without a lot of effort (partially because individual components were highly inter-dependent on each other). It also used a lot of template parts and code-behind. The Avalonia UI version of the control (a complete rewrite) attempts to fix all of these issues and become the predominant XAML color picker design.
Main improvements learning from WinUI were:
- The ColorPicker is implemented as a drop-down (matching all other "pickers"). There is also a ColorView control for those that want the canvas-type control (similar to WinUI).
- The Avalonia controls attempt to do everything possible in XAML control themes keeping code-behind to an absolute minimum. This significantly increases composability and enables app developers to customize every part of these controls (and even the primitives in most cases).
- Primitives such as the ColorSlider and ColorSpectrum are fully self-contained and can be used separately enabling app developers to create custom color picker implementations.
- A new HsvColor struct was added to base Avalonia itself (alongside Color and HslColor) and is now used in all color picker controls. This simplified code-behind and also made binding of color properties between primitives and controls possible. Color picker controls internally work in HSV color space.
- HsvColor along with ColorSlider together unlock a lot of power compared to WinUI (and enable easy re-templating).
- Many new properties (more than in WinUI) were added to control all aspects of the ColorView visibility. Each tab can be separately hidden along with most individual subsections. This allows a lot of design customization without having to re-template or use complex style selectors.
- Color palettes were added using the IColorPalette interface (same as the Windows Community Toolkit). No color palettes are supported in the WinUI version of this control.
- New properties such as SelectedIndex and ColorModel allow customizing the color picker and putting it into a pre-defined state. For example, the WinUI ColorPicker always defaults to RGB and this cannot be changed in code or XAML. This implementation does not have such limitations.
`ColorPicker` `ColorView` `ColorSlider` `ColorSpectrum` `HsvColor` `Color` `HslColor` `HsvColor` `ColorSlider` `ColorView` `IColorPalette` `SelectedIndex` `ColorModel` ### Controls & Primitives​
`ColorPicker` `ColorView` `ColorView` `ColorSpectrum` `ColorSlider` `ColorPreviewer` ### Color Palettes​
Several pre-defined color palettes implementing the IColorPalette interface are provided. Instances of these palettes may be set to the Palette property of a ColorView or ColorPicker.
`IColorPalette` `Palette` `ColorView` `ColorPicker` - Is this the right control?
- Using in Your App
- Background
- Controls & Primitives
- Color Palettes
# ColorView | Avalonia Docs
- Reference
- Controls Reference
- ColorPicker
- ColorView
## ColorView
Presents a color for user editing using a spectrum, palette and component sliders.
### Common Properties​
`Color` `HsvColor` `ColorModel` `ColorSpectrumComponents` `ColorSpectrumShape` `HexInputAlphaPosition` `HsvColor` `Color` `ColorSpectrum` `IsAccentColorsVisible` `IsAlphaEnabled` `IsAlphaVisible` `IsComponentTextInputVisible` `IsColorComponentsVisible` `IsColorModelVisible` `IsColorPaletteVisible` `IsColorPreviewVisible` `IsAccentColorsVisible` `IsColorSpectrumVisible` `IsColorSpectrumSliderVisible` `IsComponentSliderVisible` `IsAlphaVisible` `IsComponentTextInputVisible` `IsAlphaVisible` `IsHexInputVisible` `MaxHue` `MinHue` `MaxSaturation` `MinSaturation` `MaxValue` `MinValue` `MinHue` `MaxHue` `MinSaturation` `MaxSaturation` `MinValue` `MaxValue` `PaletteColors` `IColorPalette` `Palette` `PaletteColumnCount` `IColorPalette` `Palette` `Palette` `PaletteColors` `PaletteColumnCount` `SelectedIndex` `ColorViewTab` `ColorViewTab` `SelectedIndex = (int)ColorViewTab.Palette` The properties for visibility use the naming pattern "IsThingVisible" rather than "ShowThing" because some elements of the UI have the ability to control both enabled and visible status separately. Naming also matches Control in this case.
`Control` ### Pseudoclasses​
None
### Template Parts​
`PART_HexTextBox` `PART_TabControl` `SelectedIndex` - Common Properties
- Pseudoclasses
- Template Parts
# ComboBox | Avalonia Docs
- Reference
- Controls Reference
- ComboBox
## ComboBox
The ComboBox presents a selected item and a drop-down button that displays a list of options. The length and height of the combo box are determined by the selected item, unless otherwise defined.
`ComboBox` The items in the list can be composed, bound and templated.
To review the concept behind data templates, see here.
### Useful Properties​
You will probably use these properties most often:
`Items` `SelectedIndex` `SelectedItem` `AutoScrollToSelectedItem` `IsDropDownOpen` `MaxDropDownHeight` `ItemPanel` `Styles` ### Examples​
This is basic example with text items has a limit set on the drop-down list height.
```bash
<StackPanel Margin="20"> <ComboBox SelectedIndex="0" MaxDropDownHeight="100">  <ComboBoxItem>Text Item 1</ComboBoxItem>  <ComboBoxItem>Text Item 2</ComboBoxItem>  <ComboBoxItem>Text Item 3</ComboBoxItem>  <ComboBoxItem>Text Item 4</ComboBoxItem>  <ComboBoxItem>Text Item 5</ComboBoxItem>  <ComboBoxItem>Text Item 6</ComboBoxItem>  <ComboBoxItem>Text Item 7</ComboBoxItem>  <ComboBoxItem>Text Item 8</ComboBoxItem>  <ComboBoxItem>Text Item 9</ComboBoxItem> </ComboBox></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/combobox-maxdropdownheight-0027737a1a3271415b44ef1f9537437a.gif)
This example uses a composed view for each item:
```bash
<StackPanel Margin="20"> <ComboBox SelectedIndex="0">  <ComboBoxItem>   <Panel>    <Ellipse Width="50" Height="50" Fill="Red"/>    <TextBlock VerticalAlignment="Center"          HorizontalAlignment="Center">Red</TextBlock>   </Panel>  </ComboBoxItem>  <ComboBoxItem>    <Panel>     <Ellipse Width="50" Height="50" Fill="Orange"/>     <TextBlock VerticalAlignment="Center"            HorizontalAlignment="Center">Amber</TextBlock>    </Panel>  </ComboBoxItem>  <ComboBoxItem>   <Panel>    <Ellipse Width="50" Height="50" Fill="Green"/>    <TextBlock VerticalAlignment="Center"          HorizontalAlignment="Center">Green</TextBlock>   </Panel>  </ComboBoxItem> </ComboBox></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/combobox-complex-content-fc9b0eed1d0ed016e6ef839ccac0b601.gif)
This example binds the items in a combo box using a data template. The C# code-behind loads the installed font family names and binds them to the items property.
```bash
<StackPanel Margin="20"> <ComboBox x:Name="fontComboBox" SelectedIndex="0"      Width="200" MaxDropDownHeight="300">  <ComboBox.ItemTemplate>   <DataTemplate>    <TextBlock Text="{Binding Name}" FontFamily="{Binding}" />   </DataTemplate>  </ComboBox.ItemTemplate> </ComboBox></StackPanel>
```
```bash
using Avalonia.Controls;using Avalonia.Media;using System.Linq;namespace AvaloniaControls.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();            fontComboBox.Items = FontManager.Current        .GetInstalledFontFamilyNames()        .Select(x => new FontFamily(x))        .OrderBy(x=>x.Name);      fontComboBox.SelectedIndex = 0;    }  }}
```
![](https://docs.avaloniaui.net/assets/images/combobox-data-template-6dedb479ee272f17b8174e59e897485c.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ComboBox.cs
`ComboBox.cs` - Useful Properties
- Examples
- More Information
# ContentControl | Avalonia Docs
- Reference
- Controls Reference
- ContentControl
## ContentControl
### Common Properties​
`Content` ### Reference​
ContentControl
### Source code​
ContentControl.cs
### Display content​
At its simplest, a ContentControl displays the data assigned to its Content property.
`ContentControl` `Content` For example:
```bash
<ContentControl Content="Hello World!"/>
```
Will display the string "Hello World!". The Content property is the control's default property and so the above example can also be written as:
`Content` ```bash
<ContentControl>Hello World!</ContentControl>
```
If you assign a control to a ContentControl then it will display the control, for example:
`ContentControl` ```bash
<ContentControl> <Button>Click Me!</Button></ContentControl>
```
#### Display content with templates​
So far so uninteresting. Where ContentControl becomes useful is in tandem with data binding and data templates. By setting the ContentTemplate property one can specify how the data in the Content property is displayed. For example given the following view models:
`ContentControl` `ContentTemplate` `Content` ```bash
namespace Example{  public class MainWindowViewModel : ViewModelBase  {    object content = new Student("Jane", "Deer");    public object Content    {      get => content;      set => this.RaiseAndSetIfChanged(ref content, value);    }  }  public class Student  {    public Student(string firstName, string lastName)    {      FirstName = firstName;      LastName = lastName;    }    public string FirstName { get; }    public string LastName { get; }  }}
```
Note: The following examples assume an instance of MainWindowViewModel is assigned to the Window's DataContext. See the section on DataContext for more information.
`MainWindowViewModel` `DataContext` `DataContext` We can display the student's first and last name in a ContentControl using the ContentTemplate property:
`ContentControl` `ContentTemplate` ```bash
<Window xmlns="https://github.com/avaloniaui"> <ContentControl Content="{Binding Content}">  <ContentControl.ContentTemplate>   <DataTemplate>    <Grid ColumnDefinitions="Auto,Auto" RowDefinitions="Auto,Auto">     <TextBlock Grid.Row="0" Grid.Column="0">First Name:</TextBlock>     <TextBlock Grid.Row="0" Grid.Column="1" Text="{Binding FirstName}"/>     <TextBlock Grid.Row="1" Grid.Column="0">Last Name:</TextBlock>     <TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding LastName}"/>    </Grid>   </DataTemplate>  </ContentControl.ContentTemplate> </ContentControl></Window>
```
For more information see the data templates section.
- Common Properties
- Reference
- Source code
- Display contentDisplay content with templates
- Display content with templates
# Grid | Avalonia Docs
- Reference
- Controls Reference
- Grid
## Grid
The Grid control is useful for arranging child controls in columns and rows. You can define absolute, proportional, and autosized row and column geometries for the Grid.
`Grid` `Grid` Each child control in the Grid can be positioned in a Grid cell using column and row coordinates. These are zero-based, and both have a zero default.
`Grid` `Grid` If you position multiple child controls in the same cell, they will be drawn in that cell in the sequence they appear in the XAML. This is another strategy to implement layer stacking besides Panel.
`Panel` If you omit column and row coordinates for the child controls of a Grid, they will all be drawn in the top left corner (column=0, row=0).
`Grid` It is also possible to make a child control span more than one cell in either rows or columns, or both.
### Useful Properties​
You will probably use these properties most often:
`Grid` `Grid` `SharedSizeGroup` ### Size Definitions​
You can define the size of rows and columns as:
- Absolute - sized in device-independent pixels (integer)
- Proportional - sized in proportion to remaining Grid size
- Automatic - sized to fit the contained child control
`Grid` Size definitions can be written either as a list of short codes, or fully expanded using XAML elements.
Full definitions support additional constraints such as SharedSizeGroup and specifying minimum and maximum lengths in absolute sizes.
`SharedSizeGroup` #### Absolute Size Definitions​
Absolute size definitions are written as integers in the list format. For example:
ColumnDefinitions="200, 200, 300"
`ColumnDefinitions="200, 200, 300"` Using full expanded XAML, this is the same as:
```bash
<Grid>  <Grid.ColumnDefinitions>    <ColumnDefinition Width="200"></ColumnDefinition>    <ColumnDefinition Width="200"></ColumnDefinition>    <ColumnDefinition Width="300"></ColumnDefinition>  </Grid.ColumnDefinitions></Grid>
```
#### Proportional Size Definitions​
Proportional size definitions are written as proportions of available Grid space using an asterisk. For example, to create two columns with the same width and then one with twice the width:
`Grid` ColumnDefinitions="*, *, 2*"
`ColumnDefinitions="*, *, 2*"` Using full expanded XAML, this is the same as:
```bash
<Grid>  <Grid.ColumnDefinitions>    <ColumnDefinition Width="*"></ColumnDefinition>    <ColumnDefinition Width="*"></ColumnDefinition>    <ColumnDefinition Width="2*"></ColumnDefinition>  </Grid.ColumnDefinitions></Grid>
```
Size definitions do not support percentages. One trick to overcome this is to create a definition where all proportional values sum to 100 such as <Grid ColumnDefinitions="25*, 25*, 50*"> for 3 columns with 25%, 25%, and 50% of the remaining available width.
`<Grid ColumnDefinitions="25*, 25*, 50*">` #### Automatic Size Definitions​
To size a row or column automatically to the largest child control in it, use the code 'Auto'. For example:
RowDefinitions="Auto, Auto, Auto"
`RowDefinitions="Auto, Auto, Auto"` Using full expanded XAML, this is the same as:
```bash
<Grid>  <Grid.RowDefinitions>    <RowDefinition Height="Auto"></RowDefinition>    <RowDefinition Height="Auto"></RowDefinition>    <RowDefinition Height="Auto"></RowDefinition>  </Grid.RowDefinitions></Grid>
```
If a child control has its own explicitly set dimensions, these will be obeyed when it is drawn. This means that if it is larger than its grid cell, it will overlap adjacent cells.
#### Mixing Size Definitions​
You can mix any of the above in the same size definition sequence. For example:
ColumnDefinitions="200, *, 2*"
`ColumnDefinitions="200, *, 2*"` Using full expanded XAML, this is the same as:
```bash
<Grid>  <Grid.ColumnDefinitions>    <ColumnDefinition Width="200"></ColumnDefinition>    <ColumnDefinition Width="*"></ColumnDefinition>    <ColumnDefinition Width="2*"></ColumnDefinition>  </Grid.ColumnDefinitions></Grid>
```
### Drawing Rules​
When calculating sizes, any proportional columns are made to fit in the space left after the absolute and automatic values have been calculated.
The calculation for automatic sizing is made using the outside of the margin layout zone of a child control.
To review the concept of control layout zones, see here.
Child controls are drawn in their assigned grid cells in the sequence they appear in the XAML. This rule governs both what happens when two child controls are assigned the same cell, and how child controls overlap when they are larger than their allotted cell.
When a child control has its own dimensions, and is smaller than its assigned cell, it will be drawn aligned in the cell according to its horizontal and vertical alignment properties (both are centered by default).
### Example​
This example shows:
- How to use the shortened syntax for column and row definitions.
- How to mix absolute and proportional column widths.
- How to assign the cell for child controls.
- How to span rows and columns.
An example of a Grid with 3 equal Rows and 3 Columns with (1 fixed width), (2 grabbing the rest proportionally) would be:
`Grid` ```bash
<Grid ColumnDefinitions="100,1.5*,4*" RowDefinitions="Auto,Auto,Auto" Margin="4"> <TextBlock Text="Col0Row0:" Grid.Row="0" Grid.Column="0"/> <TextBlock Text="Col0Row1:" Grid.Row="1" Grid.Column="0"/> <TextBlock Text="Col0Row2:" Grid.Row="2" Grid.Column="0"/> <CheckBox Content="Col2Row0" Grid.Row="0" Grid.Column="2"/> <Button Content="SpansCol1-2Row1-2" Grid.Row="1" Grid.Column="1" Grid.RowSpan="2" Grid.ColumnSpan="2"/></Grid>
```
Here, after the absolute width of 100 has been subtracted (for column 0), column 1 will get 1.5 parts and column 2 will get 4 parts of the remaining width.
The button is drawn to fill the span from the cell (column 1, row 1) plus one column (to the right) and one row down. The result looks like this:
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Grid.cs
`Grid.cs` - Useful Properties
- Size DefinitionsAbsolute Size DefinitionsProportional Size DefinitionsAutomatic Size DefinitionsMixing Size Definitions
- Absolute Size Definitions
- Proportional Size Definitions
- Automatic Size Definitions
- Mixing Size Definitions
- Drawing Rules
- Example
- More Information
- Absolute Size Definitions
- Proportional Size Definitions
- Automatic Size Definitions
- Mixing Size Definitions
# SharedSizeGroup | Avalonia Docs
- Reference
- Controls Reference
- Grid
- SharedSizeGroup
## SharedSizeGroup
SharedSizeGroup allows sharing size information for autosized row and column definitions across multiple Grid controls.
`SharedSizeGroup` `Grid` ### Example​
The following example demonstrates how SharedSizeGroup can be used to consistently size columns within a ListBox and outside.
`SharedSizeGroup` `ListBox` - XML
- C#
```bash
<StackPanel Grid.IsSharedSizeScope="True"> <StackPanel.Styles>  <Style Selector="ListBoxItem">   <Setter Property="Padding" Value="0" />  </Style> </StackPanel.Styles> <ListBox ItemsSource="{Binding People}">  <ListBox.ItemTemplate>   <DataTemplate>    <Grid Name="myGrid" RowDefinitions="auto, auto" ShowGridLines="True">     <Grid.ColumnDefinitions>      <ColumnDefinition SharedSizeGroup="A" />      <ColumnDefinition SharedSizeGroup="B" />      <ColumnDefinition Width="*" />      <ColumnDefinition SharedSizeGroup="C" />     </Grid.ColumnDefinitions>     <TextBlock Grid.Column="0" Margin="6,0" Text="{Binding FirstName}" />     <TextBlock Grid.Column="1" Margin="6,0" Text="{Binding LastName}" />     <TextBlock Grid.Column="2" Margin="6,0" Text="{Binding Age}" />     <TextBlock Grid.Column="3" Margin="6,0" Text="{Binding Occupation}" />    </Grid>   </DataTemplate>  </ListBox.ItemTemplate> </ListBox>   <!-- Controls may appear in-between Grids with SharedSizeGroups --> <Separator /> <Grid>  <Grid.ColumnDefinitions>   <ColumnDefinition SharedSizeGroup="A" />   <ColumnDefinition SharedSizeGroup="B" />   <ColumnDefinition Width="*" />   <ColumnDefinition SharedSizeGroup="C" />  </Grid.ColumnDefinitions>  <Button Content="This is the First Name" HorizontalAlignment="Stretch" Grid.Column="0" />  <Button Content="Last" HorizontalAlignment="Stretch" Grid.Column="1" />  <Button Content="Age" HorizontalAlignment="Stretch" Grid.Column="2" />  <Button Content="Occupation" HorizontalAlignment="Stretch" Grid.Column="3" /> </Grid></StackPanel>
```
```bash
public record Person(string FirstName, string LastName, int Age, string Occupation);public partial class MainWindowViewModel : ViewModelBase{  public ObservableCollection<Person> People { get; } = new()  {    new("Jim", "Smith", 35, "Printed Circuit Board Drafter"),    new("Charlotte", "O'Shaughnessy-Alejandro", 30, "Librarian"),    new("Ryan", "Cullen", 40, "Ceramics Instructor"),    new("Valentina", "Levine", 38, "Oceanologist")  };}
```
Notice how each column is sized: the first column is sized by the Button, the second and fourth are sized by the ListBox content, and the third takes the remaining space.
`Button` `ListBox` - Example
# GridSplitter | Avalonia Docs
- Reference
- Controls Reference
- GridSplitter
## GridSplitter
The GridSplitter control allows a user to resize the columns or rows in a grid at runtime. The splitter is drawn as a column or row (size can be specified), and has a grip that the user can manipulate at runtime.
`GridSplitter` ### Useful Properties​
You will probably use these properties most often:
`Background` `Grid.Column` `Grid.Row` `ResizeDirection` To provide any meaningful movement, the direction of travel of the splitter must be the same as its position definition. That is: for a column splitter specify ResizeDirection="Columns" and for a row splitter specify ResizeDirection="Rows".
`ResizeDirection="Columns"` `ResizeDirection="Rows"` ### Examples​
This is a column splitter:
```bash
<Grid ColumnDefinitions="*, 4, *">  <Rectangle Grid.Column="0" Fill="Blue"/>  <GridSplitter Grid.Column="1" Background="Black" ResizeDirection="Columns"/>  <Rectangle Grid.Column="2" Fill="Red"/></Grid>
```
![](https://docs.avaloniaui.net/assets/images/gridsplitter-columns-6c594012f72fc6391128f45d0cb89007.gif)
This is a row splitter:
```bash
<Grid RowDefinitions="*, 4, *">  <Rectangle Grid.Row="0" Fill="Blue"/>  <GridSplitter Grid.Row="1" Background="Black" ResizeDirection="Rows"/>  <Rectangle Grid.Row="2" Fill="Red"/></Grid>
```
![](https://docs.avaloniaui.net/assets/images/gridsplitter-rows-3d1ffabe38bf54af2f44fb93cbd5c086.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub GridSplitter.cs
`GridSplitter.cs` - Useful Properties
- Examples
- More Information
# Image Controls | Avalonia Docs
- Reference
- Controls Reference
- Image Controls
## Image Controls
These Avalonia UI controls allow you to images to your app.
If you plan to bind an image source, you will need to use an image converter. To learn how to do this, see here.
# Image | Avalonia Docs
- Reference
- Controls Reference
- Image
## Image
The image can display raster images from a specified image source. The source can be:
- a string constant naming an application asset,
- loaded as a bitmap from the bound name of an asset (by using a binding converter),
- or can be loaded directly as a bitmap from a memory stream.
Images can be used to compose the content of another control. For example, you can create a graphical button using image controls.
The image can be rendered in a few different blend modes, which changes the way the image interacts with what's behind it. see the Bitmap Blend Modes page for a list of all supported blend modes and an example gallery.
The image displayed can be resized and scaled. The default settings for scaling (uniform stretch in both directions) will result in the image being fitted to the size (width and/or height) given.
The scaling settings for an image are the same as for the view box, see the reference here.
### Examples​
#### Basic​
This example shows a bitmap asset loaded into an image control where the height and width have been restricted, but the scaling settings remain defaulted. The image itself is not square, but the image width and height are set to the same value. The rectangle is included to give an idea of how the image has been scaled:
```bash
<Panel> <Rectangle Height="300" Width="300" Fill="LightGray"/> <Image Margin="20" Height="200" Width="200"     Source="avares://AvaloniaControls/Assets/pipes.jpg"/></Panel>
```
![](https://docs.avaloniaui.net/assets/images/image-unscaled-5cdfbf730d7789faeb1ac4962492bf3b.png)
#### Stretch​
In this next example, introducing the stretch setting UniformToFill fits in all the height of the image, but crops the width because it would otherwise be wider than specified. The image is not distorted by this treatment.
`UniformToFill` ```bash
<Panel> <Rectangle Height="300" Width="300" Fill="LightGray"></Rectangle> <Image Margin="20" Height="200" Width="200"     Stretch="UniformToFill"     Source="avares://AvaloniaControls/Assets/pipes.jpg"/></Panel>
```
![](https://docs.avaloniaui.net/assets/images/image-uniform-to-fill-6c9642de6cdb68cd151d1347dabe04be.png)
#### BlendMode​
This example is using two images, where the second image is using the Multiply Blend mode. For more information, read the Bitmap Blend Modes page.
`Multiply` ```bash
<Panel>  <Image Source="./Cat.jpg"/>  <Image Source="./Overlay-Color.png" BlendMode="Multiply"/></Panel>
```
![](https://docs.avaloniaui.net/assets/images/Multiply-967632c7e6504c50d2a36ad753911449.png)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Image.cs
`Image.cs` - ExamplesBasicStretchBlendMode
- Basic
- Stretch
- BlendMode
- More Information
- Basic
- Stretch
- BlendMode
# Viewbox | Avalonia Docs
- Reference
- Controls Reference
- Viewbox
## Viewbox
The Viewbox is a container control which can scale its contents. The way in which the contents are stretched can be defined, as well as when the stretch will occur (stretch direction).
`Viewbox` ### Useful Properties​
You will probably use these properties most often:
`Stretch` `StretchDirection` The values for the Stretch property are as follows:
`Stretch` `Uniform` `Fill` `UniformToFill` The values for the StretchDirection property are as follows:
`StretchDirection` `UpOnly` `DownOnly` `Both` #### Example​
This simple example shows a Viewbox scaling up a circle uniformly (both stretch and direction are default).
`Viewbox` ```bash
<Viewbox Stretch="Uniform" Width="300" Height="300">  <Ellipse Width="50" Height="50" Fill="CornflowerBlue" /> </Viewbox>
```
#### Demonstrations​
The following demonstrations show the different combinations of stretch and stretch direction property settings. This first set shows the effect of the stretch property:
`Uniform` ![](https://docs.avaloniaui.net/assets/images/viewbox-scale-uniform-both-c1f520bb5cf7149ba9ea8b7337cacd7d.gif)
`UniformToFill` ![](https://docs.avaloniaui.net/assets/images/viewbox-scale-uniformtofill-both-04c50c76c30f50de10048164245ca3b7.gif)
`Fill` ![](https://docs.avaloniaui.net/assets/images/viewbox-scale-fill-both-623c913d4ef2ad83ca33413baffe240a.gif)
`None` ![](https://docs.avaloniaui.net/assets/images/viewbox-scale-none-both-3614b534e6b3dee855a3ce51e7e856b1.gif)
This set of demonstrations shows the effect of the stretch direction property:
`UpOnly` ![](https://docs.avaloniaui.net/assets/images/viewbox-uniform-uponly-6d5bada65810ad3dd6468e82a21806c6.gif)
`DownOnly` ![](https://docs.avaloniaui.net/assets/images/viewbox-uniform-downonly-02e2c906172c31e96650bd1780051a44.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Viewbox.cs
`Viewbox.cs` - Useful PropertiesExampleDemonstrations
- Example
- Demonstrations
- More Information
- Example
- Demonstrations
# Value Selector Controls | Avalonia Docs
- Reference
- Controls Reference
- Value Selector Controls
## Value Selector Controls
These controls provide a graphical presentation to represent a value of a specific type. They also provide some kind of graphical interaction to change the value.
# UserControl | Avalonia Docs
- Reference
- Controls Reference
- UserControl
## UserControl
UserControl control is a ContentControl that represents a reusable collection of controls in a predefined layout.
`UserControl` UserControl actually provides very little functionality on top of ContentControl. The difference is that you will not usually create instances of the UserControl class directly; instead a new subclass of the UserControl class is usually created for each "view" to be shown by an application.
`UserControl` `ContentControl` `UserControl` `UserControl` #### Common Properties​
`Content` #### Reference​
UserControl
#### Source code​
UserControl.cs
- Common Properties
- Reference
- Source code
# UniformGrid | Avalonia Docs
- Reference
- Controls Reference
- UniformGrid
## UniformGrid
The UniformGrid divides the available space evenly in both directions, into cells. You can specify how many divisions to use, and these can be different in either direction.
`UniformGrid` You can then allocate child controls to the cells created, using attached row and column index properties (zero-based).
### Useful Properties​
You will probably use these properties most often:
`Rows` `Columns` `Grid.Column` `Grid.Row` ### Example​
```bash
<UniformGrid Rows="1" Columns="3" Width="300" Height="200">  <Rectangle Fill="navy" Grid.Column="0" Grid.Row="0"/>  <Rectangle Fill="white" Grid.Column="1" Grid.Row="0"/>  <Rectangle Fill="red" Grid.Column="2" Grid.Row="0"/></UniformGrid>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub UniformGrid.cs
`UniformGrid.cs` - Useful Properties
- Example
- More Information
# TreeView | Avalonia Docs
- Reference
- Controls Reference
- TreeView
## TreeView
The TreeView control can present hierarchical data and allows item selection. The items are templated so you can customise how they are displayed.
`TreeView` There are two data sources: the main items source for the control, this gives the root of the hierarchical data. Then there is the items source in the item template which allows the control to list the next level in the hierarchical data.
### Useful Properties​
You will probably use these properties most often:
`ItemsSource` `ItemsControl.ItemTemplate` `ItemsControl.ItemPanel` `ItemsControl.Styles` ### Example​
This example uses a MVVM pattern view model to hold some hierarchical data based on a C# node class. In this example, there is a single root node in the Nodes collection of the view model:
`Nodes` ```bash
<TreeView ItemsSource="{Binding Nodes}"> <TreeView.ItemTemplate>  <TreeDataTemplate ItemsSource="{Binding SubNodes}">   <TextBlock Text="{Binding Title}"/>  </TreeDataTemplate> </TreeView.ItemTemplate></TreeView>
```
```bash
using AvaloniaControls.Models;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Node> Nodes{ get; }    public MainWindowViewModel()    {      Nodes = new ObservableCollection<Node>      {                new Node("Animals", new ObservableCollection<Node>        {          new Node("Mammals", new ObservableCollection<Node>          {            new Node("Lion"), new Node("Cat"), new Node("Zebra")          })        })      };    }  }}
```
```bash
using System.Collections.ObjectModel;namespace AvaloniaControls.Models{  public class Node  {    public ObservableCollection<Node>? SubNodes { get; }    public string Title { get; }     public Node(string title)    {      Title = title;    }    public Node(string title, ObservableCollection<Node> subNodes)    {      Title = title;      SubNodes = subNodes;    }  }}
```
By default the root node (or nodes) is shown. The user can expand or contract each node by clicking on the adjacent arrow. Clicking on the node title selects the item.
![](https://docs.avaloniaui.net/assets/images/treeview-animal-hierarchy-338675d6a37ca5eee3084f636fda20af.gif)
This is a development of the previous example with multiple root nodes, a revised item template, and an initial selection made in the view model code:
```bash
<TreeView Margin="10"     ItemsSource="{Binding Nodes}"      SelectedItems="{Binding SelectedNodes}"     SelectionMode="Multiple"> <TreeView.ItemTemplate>  <TreeDataTemplate ItemsSource="{Binding SubNodes}">   <Border HorizontalAlignment="Left"       BorderBrush="Gray" BorderThickness="1"       CornerRadius="5" Padding="15 3">    <TextBlock Text="{Binding Title}" />   </Border>  </TreeDataTemplate> </TreeView.ItemTemplate></TreeView>
```
```bash
using AvaloniaControls.Models;using System.Collections.ObjectModel;using System.Linq;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Node> Nodes { get; }    public ObservableCollection<Node> SelectedNodes { get; }    public MainWindowViewModel()    {      SelectedNodes = new ObservableCollection<Node>();      Nodes = new ObservableCollection<Node>      {                new Node("Animals", new ObservableCollection<Node>        {          new Node("Mammals", new ObservableCollection<Node>          {            new Node("Lion"), new Node("Cat"), new Node("Zebra")          })        }),        new Node("Birds", new ObservableCollection<Node>        {          new Node("Robin"), new Node("Condor"),           new Node("Parrot"), new Node("Eagle")        }),        new Node("Insects", new ObservableCollection<Node>        {          new Node("Locust"), new Node("House Fly"),           new Node("Butterfly"), new Node("Moth")        }),      };      var moth = Nodes.Last().SubNodes?.Last();      if (moth!=null) SelectedNodes.Add(moth);      }  }}
```
```bash
using System.Collections.ObjectModel;namespace AvaloniaControls.Models{  public class Node  {    public ObservableCollection<Node>? SubNodes { get; }    public string Title { get; }     public Node(string title)    {      Title = title;    }    public Node(string title, ObservableCollection<Node> subNodes)    {      Title = title;      SubNodes = subNodes;    }  }}
```
The tree view adds a scroll bar when it is needed. The selection can be extended by holding down the Ctrl key.
![](https://docs.avaloniaui.net/assets/images/treeview-enhanced-animal-hierarchy-594fe092a4f0fc1c737e88f2e0eab4fa.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TreeView.cs
`TreeView.cs` - Useful Properties
- Example
- More Information
# Tree Data Grid Column Types | Avalonia Docs
- Reference
- Controls Reference
- TreeDataGrid
- Tree Data Grid Column Types
## Tree Data Grid Column Types
The tree data grid supports three different column types:
- Text Column
- Hierarchical Expander Column
- Template Column
#### Text Column​
A text column (class TextColumn) is useful when you want the cells in a column to have text values. A text column is created like this:
`TextColumn` ```bash
new TextColumn<ItemClass, string>("Column Header", x => x.Property)
```
The first generic parameter here is the class of the items that make up the grid rows. The second generic parameter here is the type of the property.
![](https://user-images.githubusercontent.com/53405089/157456551-dd394781-903a-4c7b-8874-e631e21534a1.png)
The above is the signature of the TextColumn constructor. The first two parameters are required: the first is the column header, and the second is an expression to get the value of the property.
`TextColumn` The TextColumn class implements the column interface IColumn.
`TextColumn` `IColumn` #### Hierarchical Expander Column​
A hierarchical expander column (class: HierarchicalExpanderColumn) can only be used with the hierarchical data mode of operation, and it must be used with the data source class HierarchicalTreeDataGridSource. This column type must contain an inner column (interface IColumn) to define its header and value property. A hierarchical expander column displays the expand and contract chevron buttons in a hierarchical tree data grid.
`HierarchicalExpanderColumn` `HierarchicalTreeDataGridSource` `IColumn` This column type is created like this:
```bash
new HierarchicalExpanderColumn<ItemClass>(  new TextColumn<ItemClass, string>("Column Header", x => x.Property),   x => x.Children)
```
The generic parameter is the class of the items that make up the grid rows. This is the same as the item class for the inner column.
![](https://user-images.githubusercontent.com/53405089/157536079-fd14f1ed-0a7d-438a-abba-fd56766709a9.png)
The above is the signature of the HierarchicalExpanderColumn constructor. The first parameter in the constructor is the inner column, and the second parameter is a (nullable) selector for any child elements.
`HierarchicalExpanderColumn` #### Template Column​
The template column (class TemplateColumn) is a fully customizable way for you to create a column. It essentially forms a data template for the column.
`TemplateColumn` You create a template column like this:
```bash
new TemplateColumn<ItemClass>("Column Header",    new FuncDataTemplate<T>((a,e) => new SomeControl()))
```
![](https://user-images.githubusercontent.com/53405089/157664231-8653bce9-f8d6-4fbc-8e78-e3ff93f1ace2.png)
The above is the signature of the TemplateColumnconstructor. It has two required parameters: the first is the column header, and the second is a function that returns IDataTemplate.
`TemplateColumn` `IDataTemplate` For more information about the concept of creating a data template in code, see here.
- Text Column
- Hierarchical Expander Column
- Template Column
# TreeDataGrid | Avalonia Docs
- Reference
- Controls Reference
- TreeDataGrid
## TreeDataGrid
The TreeDataGrid displays hierarchical and tabular data together in a single view. It is a combination of a tree view and data grid.
`TreeDataGrid` For full information on the tree view control, see the reference here.
For full information on the data grid control, see the reference here.
The control has two modes of operation:
- Hierarchical - data is displayed in a tree with optional columns
- Flat - data is displayed in a two dimensional table, similar to the data grid control
### Hierarchical Data​
This is an illustration of a tree data grid displaying hierarchical data:
![](https://docs.avaloniaui.net/assets/images/treedataggrid-files-8df73b5da457bf970003904e57741a07.png)
### Flat Data​
This is an illustration An example of a tree data grid displaying flat data:
![](https://docs.avaloniaui.net/assets/images/treedataggrid-countries-d55804cef305a8f879575f87eae9ef0a.png)
### NuGet Package Reference​
You must install the NuGet package for the data grid, there are several ways of doing this. You can use Manage NuGet Packages from the project menu of your IDE:
Alternatively, you can run this instruction from the command line:
```bash
dotnet add package Avalonia.Controls.TreeDataGrid
```
Or add package reference directly to the project (.csproj) file:
`.csproj` ```bash
<PackageReference Include="Avalonia.Controls.TreeDataGrid" Version="11.0.0" />
```
Note you must always install the data grid version that matches the Avalonia UI version you are using.
### Include Data Grid Styles​
You must reference the data grid themes to include the additional styles that the tree data grid uses. You can do this by adding a <StyleInclude> element to the application (App.axaml file).
`<StyleInclude>` `App.axaml` For example:
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"> <Application.Styles>  <FluentTheme/>  <StyleInclude     Source="avares://Avalonia.Controls.TreeDataGrid/Themes/Fluent.axaml"/> </Application.Styles></Application>
```
### Useful Properties​
You will probably use these properties most often:
`Source` `CanUserResizeColumns` `CanUserSortColumns` ### Source​
You will use the Source property to bind to a view model that is defined in code. The view model includes the definition of how the columns map to the properties of the class that holds the grid items.
`Source` ### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TreeDataGrid.cs
The next page shows an example of creating a hierarchical tree data grid with columns.
- Hierarchical Data
- Flat Data
- NuGet Package Reference
- Include Data Grid Styles
- Useful Properties
- Source
- More Information
# TrayIcon | Avalonia Docs
- Reference
- Controls Reference
- TrayIcon
## TrayIcon
### Overview​
The TrayIcon allows an Avalonia UI application to display an icon and a native menu in the system tray. It is supported on Windows, macOS and some Linux distributions (it is confirmed to work on Ubuntu).
`TrayIcon` You must define a tray menu in the application XAML file.
### Useful Properties​
You will probably use these properties most often:
`Icon` `ToolTipText` You must use a native menu with the tray icon, and not the Avalonia UI menu control. For full details about the native menu, see the reference here.
### Example​
This example defines a simple tray icon menu in the App.xaml file :
`App.xaml` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApplication.App"> <TrayIcon.Icons>  <TrayIcons>   <TrayIcon Icon="/Assets/avalonia-logo.ico"         ToolTipText="Avalonia Tray Icon ToolTip">    <TrayIcon.Menu>     <NativeMenu>      <NativeMenuItem Header="Settings">       <NativeMenu>        <NativeMenuItem Header="Option 1"  />        <NativeMenuItem Header="Option 2"  />        <NativeMenuItemSeparator />        <NativeMenuItem Header="Option 3" />       </NativeMenu>      </NativeMenuItem>     </NativeMenu>    </TrayIcon.Menu>   </TrayIcon>  </TrayIcons> </TrayIcon.Icons></Application>
```
Include the .ico file in the .csproj file using an AvaloniaResource item:
`.ico` `.csproj` `AvaloniaResource` ```bash
<Project Sdk="Microsoft.NET.Sdk"> <ItemGroup>  <AvaloniaResource Include="Assets/avalonia-logo.ico" /> </ItemGroup></Project>
```
![](https://docs.avaloniaui.net/assets/images/trayicon-d8a8cc33e65cfcc0df262be2a196793a.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TrayIcon.cs
`TrayIcon.cs` - Overview
- Useful Properties
- Example
- More Information
# NativeMenu | Avalonia Docs
- Reference
- Controls Reference
- NativeMenu
## NativeMenu
The NativeMenu can display a menu on macOS and some Linux distributions.
`NativeMenu` This control can only be used attached to a tray icon. For full details about the tray icon, see the reference here.
You can create sub-menus by nesting <MenuItem> elements.
`<MenuItem>` You can add menu separator lines by including a <NativeMenuItemSeparator> element or by adding a menu item with its header set to the minus sign, like this:
`<NativeMenuItemSeparator>` ```bash
<NativeMenuItemSeparator Header="-" />
```
### Useful Properties​
You will probably use these properties most often:
`Header` `Command` ### Example​
This example defines a native menu that can be attached to a tray icon:
```bash
<NativeMenu> <NativeMenuItem Header="Settings">  <NativeMenu>   <NativeMenuItem Header="Option 1"  />   <NativeMenuItem Header="Option 2"  />   <NativeMenuItemSeparator />   <NativeMenuItem Header="Option 3" />  </NativeMenu> </NativeMenuItem></NativeMenu>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub NativeMenu.cs
- Useful Properties
- Example
- More Information
# Menu | Avalonia Docs
- Reference
- Controls Reference
- Menu
## Menu
The menu control can add menu structure to an application. You will usually place a menu at the top edge of a dock panel control, so that it is drawn at the top of a window.
For reference information about the dock panel, see here.
### Menu Items​
A menu element will usually contain a set of nested <MenuItem> elements. The first level of menu items defines the horizontal part of the menu. Subsequent levels of menu items are drop-downs.
`<MenuItem>` The caption of a menu item is set by the Header property. The content zone of a menu item can contain sub-items if required.
`Header` You can add menu separator lines by including a <Separator> element or by adding a menu item with its header set to the minus sign, like this:
`<Separator>` ```bash
<MenuItem Header="-" />
```
### Useful Properties​
You will probably use these properties most often:
`Menu` `DockPanel.Dock` `MenuItem` `Header` `MenuItem` `InputGesture` `MenuItem` `Command` `MenuItem` `MenuItem.Icon` `Separator` `ItemPanel` `Styles` ### Example​
This example creates a menu docked at the top edge of a window.
```bash
<Window ...>  <DockPanel>  <Menu DockPanel.Dock="Top">   <MenuItem Header="_File">    <MenuItem Header="_Open..."/>    <Separator/>    <MenuItem Header="_Exit"/>   </MenuItem>   <MenuItem Header="_Edit">    <MenuItem Header="Copy"/>    <MenuItem Header="Paste"/>   </MenuItem>  </Menu>  <TextBlock/> </DockPanel></Window>
```
![](https://docs.avaloniaui.net/assets/images/menu-top-dock-c6b982c10167ee1354d492572ccb7846.gif)
### Accelerator Keys​
An accelerator key is identified by a single letter in the header preceded by an underscore. For example:
```bash
<MenuItem Header="_File">
```
It allows the user to access a menu item quickly. It is also sometimes called a hot key, access key or mnemonic.
The user can access this feature by first pressing the Alt key, and then the accelerator key (or they can be pressed together). This is demonstrated in the second of the menu sequences in the example above.
You will see that accelerator keys, where defined, are underlined on the menu as soon as the Alt key is pressed. Then any sub-menus are dropped down as soon as the accelerator key above is pressed.
Once keyboard interaction has been initiated with the Alt key, the user can also navigate the menus using the keyboard arrow keys. Menu items may be selected using the Enter key on the keyboard.
### Menu Commands​
To initiate an action, the command property of a menu item can be bound to an ICommand object. The command will be executed when the menu item is clicked or selected with the keyboard. For example:
`ICommand` ```bash
<Menu>  <MenuItem Header="_File">    <MenuItem Header="_Open..." Command="{Binding OpenCommand}"/>  </MenuItem></Menu>
```
For guidance on how to bind to commands, see here.
### Menu Icons​
A menu icon can be displayed by placing an image or a path icon in the <MenuItem.Icon> attached property. For example:
`<MenuItem.Icon>` ```bash
<MenuItem Header="_Edit"> <MenuItem Header="Copy">   <MenuItem.Icon>    <PathIcon Data="{StaticResource copy_regular}"/>   </MenuItem.Icon> </MenuItem> <MenuItem Header="Paste">   <MenuItem.Icon>    <PathIcon Data="{StaticResource clipboard_paste_regular}"/>   </MenuItem.Icon> </MenuItem></MenuItem>
```
![](https://docs.avaloniaui.net/assets/images/menu-icon-244918248d821afd50065da126860518.gif)
For more detailed guidance on how to add icons to your menus, see here.
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Menu.cs
`Menu.cs` - Menu Items
- Useful Properties
- Example
- Accelerator Keys
- Menu Commands
- Menu Icons
- More Information
# How To Add Menu Icons | Avalonia Docs
- How-To Guides
- Graphics and Animation
- How To Add Menu Icons
## How To Add Menu Icons
In Avalonia, you can enhance the appearance and user experience of your application by adding icons to menu items. Icons can provide a visual clue for the action performed by the menu item, making it easier for users to navigate through your application. This guide will walk you through how to add icons to menu items in Avalonia.
### Adding Icons to Menu Items​
The MenuItem.Icon property is used to set an icon for a menu item. You can use various kinds of image sources for the icon, including resource URIs, file paths, or web URLs. Here's an example of how to add an icon to a menu item:
`MenuItem.Icon` ```bash
<Menu> <MenuItem Header="File">  <MenuItem Header="Open" Command="{Binding OpenCommand}">   <MenuItem.Icon>    <Image Width="16" Height="16" Source="avares://MyApp/Assets/open_icon.png" />   </MenuItem.Icon>  </MenuItem> </MenuItem></Menu>
```
In this example, the MenuItem.Icon property is set to an Image control that displays an image from the application resources. The Source property of the Image control is set to a resource URI that represents the image source. The Width and Height properties are set to control the size of the image.
`MenuItem.Icon` `Image` `Source` `Image` `Width` `Height` - Adding Icons to Menu Items
# How To Draw Graphics | Avalonia Docs
- How-To Guides
- Graphics and Animation
- How To Draw Graphics
## How To Draw Graphics
Content in preparation.
### Graphics​
Avalonia introduces an extensive, scalable, and flexible set of graphics features that have the following benefits:
- Resolution-independent and device-independent graphics. The basic unit of measurement in the Avalonia graphics system is the device-independent pixel, which is 1/96th of an inch, regardless of actual screen resolution, and provides the foundation for resolution-independent and device-independent rendering. Each device-independent pixel automatically scales to match the dots-per-inch (dpi) setting of the system it renders on.
- Improved precision. The Avalonia coordinate system is measured with double-precision floating-point numbers rather than single-precision. Transformations and opacity values are also expressed as double-precision.
- Advanced graphics and animation support. Avalonia simplifies graphics programming by managing animation scenes for you; there is no need to worry about scene processing, rendering loops, and bilinear interpolation. Additionally, Avalonia provides hit-testing support and full alpha-compositing support.
- Skia. By default Avalonia uses the Skia rendering engine, the same rendering engine that powers Google Chrome and Chrome OS, Android, Mozilla Firefox and Firefox OS, and many other products.
### 2D Shapes and Geometries​
Avalonia provides a library of common vector-drawn 2D shapes such as Ellipse, Line, Path, Polygon and Rectangle.
`Ellipse` `Line` `Path` `Polygon` `Rectangle` ```bash
<Canvas Background="Yellow" Width="300" Height="400">  <Rectangle Fill="Blue" Width="63" Height="41" Canvas.Left="40" Canvas.Top="31">    <Rectangle.OpacityMask>      <LinearGradientBrush StartPoint="0%,0%" EndPoint="100%,100%">        <LinearGradientBrush.GradientStops>          <GradientStop Offset="0" Color="Black"/>          <GradientStop Offset="1" Color="Transparent"/>        </LinearGradientBrush.GradientStops>      </LinearGradientBrush>    </Rectangle.OpacityMask>     </Rectangle>  <Ellipse Fill="Green" Width="58" Height="58" Canvas.Left="88" Canvas.Top="100"/>  <Path Fill="Orange" Data="M 0,0 c 0,0 50,0 50,-50 c 0,0 50,0 50,50 h -50 v 50 l -50,-50 Z" Canvas.Left="30" Canvas.Top="250"/>  <Path Fill="OrangeRed" Canvas.Left="180" Canvas.Top="250">    <Path.Data>      <PathGeometry>        <PathFigure StartPoint="0,0" IsClosed="True">          <QuadraticBezierSegment Point1="50,0" Point2="50,-50" />          <QuadraticBezierSegment Point1="100,-50" Point2="100,0" />          <LineSegment Point="50,0" />          <LineSegment Point="50,50" />        </PathFigure>      </PathGeometry>    </Path.Data>  </Path>  <Line StartPoint="120,185" EndPoint="30,115" Stroke="Red" StrokeThickness="2"/>  <Polygon Points="75,0 120,120 0,45 150,45 30,120" Stroke="DarkBlue" StrokeThickness="1" Fill="Violet" Canvas.Left="150" Canvas.Top="31"/>  <Polyline Points="0,0 65,0 78,-26 91,39 104,-39 117,13 130,0 195,0" Stroke="Brown" Canvas.Left="30" Canvas.Top="350"/></Canvas>
```
### Add Animations​
Avalonia UI has animation support lets you make controls grow, shake, spin, and fade, to create interesting page transitions, and more. Avalonia uses a CSS-like animation system which supports property transitions and keyframe animations.
- Graphics
- 2D Shapes and Geometries
- Add Animations
# How To Use Transitions | Avalonia Docs
- How-To Guides
- Graphics and Animation
- How To Use Transitions
## How To Use Transitions
Transitions in Avalonia are also heavily inspired by CSS Animations. They listen to any changes in target property's value and subsequently animates the change according to its parameters. They can be defined on any Control via Transitions property:
`Control` `Transitions` ```bash
<Window xmlns="https://github.com/avaloniaui">  <Window.Styles>    <Style Selector="Rectangle.red">      <Setter Property="Height" Value="100"/>      <Setter Property="Width" Value="100"/>      <Setter Property="Fill" Value="Red"/>      <Setter Property="Opacity" Value="0.5"/>    </Style>    <Style Selector="Rectangle.red:pointerover">      <Setter Property="Opacity" Value="1"/>    </Style>  </Window.Styles>  <Rectangle Classes="red">    <Rectangle.Transitions>      <Transitions>        <DoubleTransition Property="Opacity" Duration="0:0:0.2"/>      </Transitions>    </Rectangle.Transitions>  </Rectangle></Window>
```
The above example will listen to changes in the Rectangle's Opacity property, and when the value changes, apply a smooth transition from the old value to the new value over 2 seconds.
`Rectangle` `Opacity` Transitions can also be defined in any style by using a Setter with Transitions as the target property and encapsulating them in a Transitions object, like so:
`Setter` `Transitions` `Transitions` ```bash
<Window xmlns="https://github.com/avaloniaui">  <Window.Styles>    <Style Selector="Rectangle.red">      <Setter Property="Height" Value="100"/>      <Setter Property="Width" Value="100"/>      <Setter Property="Fill" Value="Red"/>      <Setter Property="Opacity" Value="0.5"/>      <Setter Property="Transitions">        <Transitions>          <DoubleTransition Property="Opacity" Duration="0:0:0.2"/>        </Transitions>      </Setter>    </Style>    <Style Selector="Rectangle.red:pointerover">      <Setter Property="Opacity" Value="1"/>    </Style>  </Window.Styles>  <Rectangle Classes="red"/></Window>
```
Every transition has a Property, Delay, Duration and an optional Easing property.
`Property` `Delay` `Duration` `Easing` Property refers to a transition's target for listening and animating values upon.
`Property` Delay refers to the amount of time before the transition is applied to the target.
`Delay` Duration refers to the amount of time that the transition plays.
`Duration` The easing functions are the same as those described in Keyframe Animations.
The following transition types are available. The correct type must be used depending on the type of the property being animated.
- BoxShadowsTransition: For BoxShadows target properties
- BrushTransition: For IBrush target properties
- ColorTransition: For Color target properties
- CornerRadiusTransition: For CornerRadius target properties
- DoubleTransitions: For double target properties
- FloatTransitions: For float target properties
- IntegerTransitions: For int target properties
- PointTransition: For Point target properties
- SizeTransition: For Size target properties
- ThicknessTransition: For Thickness target properties
- TransformOperationsTransition: For ITransform target properties
- VectorTransition: For Vector target properties
`BoxShadowsTransition` `BoxShadows` `BrushTransition` `IBrush` `ColorTransition` `Color` `CornerRadiusTransition` `CornerRadius` `DoubleTransitions` `double` `FloatTransitions` `float` `IntegerTransitions` `int` `PointTransition` `Point` `SizeTransition` `Size` `ThicknessTransition` `Thickness` `TransformOperationsTransition` `ITransform` `VectorTransition` `Vector` ### Transitioning Render Transforms​
Render transforms applied to controls using CSS-like syntax can be transitioned. The following example shows a Border which rotates 45 degrees when the pointer is hovered over it:
```bash
<Border Width="100" Height="100" Background="Red">  <Border.Styles>    <Style Selector="Border">      <Setter Property="RenderTransform" Value="rotate(0)"/>    </Style>    <Style Selector="Border:pointerover">      <Setter Property="RenderTransform" Value="rotate(45deg)"/>    </Style>  </Border.Styles>  <Border.Transitions>    <Transitions>      <TransformOperationsTransition Property="RenderTransform" Duration="0:0:1"/>    </Transitions>  </Border.Transitions></Border>
```
```bash
new Border{  Width = 100,  Height = 100,  Background = Brushes.Red,  Styles =  {    new Style(x => x.OfType<Border>())    {      Setters =      {        new Setter(          Border.RenderTransformProperty,          TransformOperations.Parse("rotate(0)"))      },    },    new Style(x => x.OfType<Border>().Class(":pointerover"))    {      Setters =      {        new Setter(          Border.RenderTransformProperty,          TransformOperations.Parse("rotate(45deg)"))      },    },  },  Transitions = new Transitions  {    new TransformOperationsTransition    {      Property = Border.RenderTransformProperty,      Duration = TimeSpan.FromSeconds(1),    }  }};
```
The available transitions are:
`translate` `translate(10px)` `translate(0px, 10px)` `px` `translateX` `translateX(10px)` `px` `translateY` `translateY(10px)` `px` `scale` `scale(10)` `scale(0, 10)` `scaleX` `scaleX(10)` `scaleY` `scaleY(10)` `skew` `skew(90deg)` `skew(0, 90deg)` `deg` `grad` `rad` `turn` `skewX` `skewX(90deg)` `deg` `grad` `rad` `turn` `skewY` `skewY(90deg)` `deg` `grad` `rad` `turn` `rotate` `rotate(90deg)` `deg` `grad` `rad` `turn` `matrix` `matrix(1,2,3,4,5,6)` Avalonia also supports WPF-style render transforms such as RotateTransform, ScaleTransform, etc. These transforms cannot be transitioned: always use the CSS-like format if you want to apply a transition to a render transform.
`RotateTransform` `ScaleTransform` - Transitioning Render Transforms
# How To Use Keyframe Animations | Avalonia Docs
- How-To Guides
- Graphics and Animation
- How To Use Keyframe Animations
## How To Use Keyframe Animations
You can use a keyframe animation to change one or more control properties following a timeline. The keyframes are defined in Avalonia UI styles with cue points along the duration of the animation, and set the intermediate values of the properties at a point in time.
The property values between keyframes are set following the profile of an easing function. The default easing function is a straight-line interpolation.
The animation is triggered to start, and then can run any number of times, in either direction. There are also options to delay the start of the animation, and to repeat it.
If you are familiar with keyframe animations keyframe work in CSS, you will recognise the similarity with how they are done in in Avalonia UI.
### Example​
You define a keyframe animation using styles.
To revise how Avalonia UI uses styles, see the concept here.
Follow this procedure to define a simple color fade animation using XAML:
- Create a styles collection at your chosen level.
- Add a style to the collection with a selector that can target the control you want to animate.
- Add a Setter element to define the property that you wan the animation to change. In this example <Setter Property="Fill" Value="Red"/>
- Add a Style.Animations element to contain your animation.
- Add an Animation element and set its Duration attribute. This is in the format "Hours:Minutes:Seconds".
- Now define the keyframes for the animation. This example uses cues at 0% and 100%.
- Add Setter elements to each keyframe for value of the fill opacity. This example animates between opacity values of 0.0 and 1.0.
`Setter` `<Setter Property="Fill" Value="Red"/>` `Style.Animations` `Animation` `Duration` `"Hours:Minutes:Seconds"` `Setter` The finished code will look like this:
```bash
<Window xmlns="https://github.com/avaloniaui">  <Window.Styles>    <Style Selector="Rectangle.red">      <Setter Property="Fill" Value="Red"/>      <Style.Animations>        <Animation Duration="0:0:3">           <KeyFrame Cue="0%">            <Setter Property="Opacity" Value="0.0"/>          </KeyFrame>          <KeyFrame Cue="100%">            <Setter Property="Opacity" Value="1.0"/>          </KeyFrame>        </Animation>      </Style.Animations>    </Style>  </Window.Styles>  <Rectangle Classes="red" Width="100" Height="100"/></Window>
```
The resulting animation looks like this:
The animation runs as soon as the rectangle control is loaded and can be selected by the style. In fact it runs in the preview pane as well!
### Animate Two Properties​
This example shows you how to animate two properties on the same timeline.
```bash
<Window.Styles>  <Style Selector="Rectangle.red">   <Setter Property="Fill" Value="Red"/>   <Style.Animations>    <Animation Duration="0:0:3" IterationCount="4">     <KeyFrame Cue="0%">      <Setter Property="Opacity" Value="0.0"/>      <Setter Property="RotateTransform.Angle" Value="0.0"/>     </KeyFrame>     <KeyFrame Cue="100%">       <Setter Property="Opacity" Value="1.0"/>      <Setter Property="RotateTransform.Angle" Value="90.0"/>     </KeyFrame>    </Animation>   </Style.Animations>  </Style> </Window.Styles>
```
The red rectangle is faded-in and rotated at the same time.
![](https://docs.avaloniaui.net/assets/images/keyframe-composite-animation-a844b40965bbeae42b283e2b33b86aec.gif)
### Configuring animation​
#### Delay​
You can add a delay to the start of an animation by setting the delay attribute of the animation element. For example:
```bash
<Animation Duration="0:0:1"      Delay="0:0:1">   ...</Animation>
```
#### Repeat​
You can make an animation repeat for a set number of times, or indefinitely. To repeat for a finite number of iterations set the IterationCount attribute on the animation element like this:
`IterationCount` ```bash
<Animation IterationCount="5">  ...</Animation>
```
To repeat an animation indefinitely, use the special "INFINITE" value. For example:
`"INFINITE"` ```bash
<Animation IterationCount="INFINITE">  ...</Animation>
```
#### Playback Direction​
By default an animation plays forward. That is it follows the profile of the easing function from left to right. You can alter this behavior by setting the PlaybackDirection attribute on the animation element. For example:
`PlaybackDirection` ```bash
<Animation IterationCount="9" PlaybackDirection="AlternateReverse">  ...</Animation>
```
The following table describes the options:
`Normal` `Reverse` `Alternate` `AlternateReverse` #### Fill Mode​
The fill mode attribute of an animation defines how the properties being set will persist after it runs, or during any gaps between runs. For example:
```bash
<Animation IterationCount="9" FillMode="Backward">  ...</Animation>
```
The following table describes the options:
`None` `Forward` `Backward` `Both` `Forward` `Backward` #### Easing Function​
An easing function defines how a property is varied over time during an animation.
The default easing function is linear (above left), but you use another pattern by setting the name of the desired function in the easing attribute. For example to use the 'bounce ease in' function (above right):
```bash
<Animation Duration="0:0:1"      Delay="0:0:1"      Easing="BounceEaseIn">   ...</Animation>
```
For a full list of the Avalonia UI easing functions, see the reference here.
You can also add your own custom easing function class like this:
```bash
<Animation Duration="0:0:1"      Delay="0:0:1">  <Animation.Easing>    <local:YourCustomEasingClassHere/>  </Animation.Easing>   ...</Animation>
```
### Running animation from the code behind​
In some situations, developers need more flexibility with animation lifetime, comparing to the XAML style selectors. Easiest would be to define animation in the Resources dictionary.
`Resources` While defining Animation this way, it's important to specify both x:Key and x:SetterTargetType. First one will be used to access animation by the key, and second helps compiler to create strongly typed setters.
`Animation` `x:Key` `x:SetterTargetType` ```bash
<Window xmlns="https://github.com/avaloniaui">  <Window.Resources>    <Animation x:Key="ResourceAnimation"          x:SetterTargetType="Rectangle"          Duration="0:0:3">       <KeyFrame Cue="0%">        <Setter Property="Opacity" Value="0.0"/>      </KeyFrame>      <KeyFrame Cue="100%">        <Setter Property="Opacity" Value="1.0"/>      </KeyFrame>    </Animation>  </Window.Resources>  <Rectangle x:Name="Rect" /></Window>
```
Now, this animation can be accessed and executed in a custom code behind handler.
```bash
var animation = (Animation)this.Resources["ResourceAnimation"];// Running XAML animation on the Rect control. await animation.RunAsync(Rect);
```
RunAsync returns a task which is completed with the animation. If animation is infinite/repeating, task will never end, unless cancelled externally by passing CancellationToken to the RunAsync method.
`RunAsync` `CancellationToken` While it's easier to define animations in XAML, it's also possible to do completely in C# code. It's possible to create an instance of Animation type, and populate key frames collection.
`Animation` - Example
- Animate Two Properties
- Configuring animationDelayRepeatPlayback DirectionFill ModeEasing Function
- Delay
- Repeat
- Playback Direction
- Fill Mode
- Easing Function
- Running animation from the code behind
- Delay
- Repeat
- Playback Direction
- Fill Mode
- Easing Function
# How To Use Icons | Avalonia Docs
- How-To Guides
- Graphics and Animation
- How To Use Icons
## How To Use Icons
In Avalonia, using icons in your user interface can help to improve the look of your application and can make it more user-friendly. Icons can provide a visual representation of actions or content, making it easier for users to understand the functionality of your application. This guide will show you how to add and use icons in your Avalonia application.
### Using Icons in Avalonia​
Icons can be added to your Avalonia application in various ways. This guide will cover two common methods: using image files and using icon fonts.
#### Using Image Files​
One way to use icons in Avalonia is by using image files. You can use various formats like PNG, JPG, or BMP. Here's an example of how to use an image file as an icon:
```bash
<Image Width="16" Height="16" Source="avares://MyApp/Assets/icon.png" />
```
In this example, an Image control is used to display an image from the application's resources as an icon. The Source property of the Image control is set to a resource URI that points to the image file.
`Image` `Source` `Image` #### Using Icon Fonts​
Another way to use icons in Avalonia is by using icon fonts. Icon fonts allow you to use scalable vector icons that can be customized with CSS in terms of size, color, drop shadow, etc. Here's an example of how to use an icon font in Avalonia:
```bash
<TextBlock FontFamily="avares://MyApp/Assets/#FontAwesome" Text="&#xf030;" />
```
In this example, a TextBlock control is used to display an icon from the FontAwesome icon font. The FontFamily property of the TextBlock control is set to a resource URI that points to the font file, and the Text property is set to the Unicode value of the desired icon.
`TextBlock` `FontAwesome` `FontFamily` `TextBlock` ### Best Practices​
While using icons can enhance the usability of your application, it is important to use them wisely. Keep the following tips in mind when using icons:
- Ensure that the icons are of a suitable size and clearly visible against the background.
- Use universally recognized icons for common actions to make your application more intuitive.
- Using Icons in AvaloniaUsing Image FilesUsing Icon Fonts
- Using Image Files
- Using Icon Fonts
- Best Practices
- Using Image Files
- Using Icon Fonts
# How To Use Keyframe Animations | Avalonia Docs
- How-To Guides
- Graphics and Animation
- How To Use Keyframe Animations
## How To Use Keyframe Animations
You can use a keyframe animation to change one or more control properties following a timeline. The keyframes are defined in Avalonia UI styles with cue points along the duration of the animation, and set the intermediate values of the properties at a point in time.
The property values between keyframes are set following the profile of an easing function. The default easing function is a straight-line interpolation.
The animation is triggered to start, and then can run any number of times, in either direction. There are also options to delay the start of the animation, and to repeat it.
If you are familiar with keyframe animations keyframe work in CSS, you will recognise the similarity with how they are done in in Avalonia UI.
### Example​
You define a keyframe animation using styles.
To revise how Avalonia UI uses styles, see the concept here.
Follow this procedure to define a simple color fade animation using XAML:
- Create a styles collection at your chosen level.
- Add a style to the collection with a selector that can target the control you want to animate.
- Add a Setter element to define the property that you wan the animation to change. In this example <Setter Property="Fill" Value="Red"/>
- Add a Style.Animations element to contain your animation.
- Add an Animation element and set its Duration attribute. This is in the format "Hours:Minutes:Seconds".
- Now define the keyframes for the animation. This example uses cues at 0% and 100%.
- Add Setter elements to each keyframe for value of the fill opacity. This example animates between opacity values of 0.0 and 1.0.
`Setter` `<Setter Property="Fill" Value="Red"/>` `Style.Animations` `Animation` `Duration` `"Hours:Minutes:Seconds"` `Setter` The finished code will look like this:
```bash
<Window xmlns="https://github.com/avaloniaui">  <Window.Styles>    <Style Selector="Rectangle.red">      <Setter Property="Fill" Value="Red"/>      <Style.Animations>        <Animation Duration="0:0:3">           <KeyFrame Cue="0%">            <Setter Property="Opacity" Value="0.0"/>          </KeyFrame>          <KeyFrame Cue="100%">            <Setter Property="Opacity" Value="1.0"/>          </KeyFrame>        </Animation>      </Style.Animations>    </Style>  </Window.Styles>  <Rectangle Classes="red" Width="100" Height="100"/></Window>
```
The resulting animation looks like this:
The animation runs as soon as the rectangle control is loaded and can be selected by the style. In fact it runs in the preview pane as well!
### Animate Two Properties​
This example shows you how to animate two properties on the same timeline.
```bash
<Window.Styles>  <Style Selector="Rectangle.red">   <Setter Property="Fill" Value="Red"/>   <Style.Animations>    <Animation Duration="0:0:3" IterationCount="4">     <KeyFrame Cue="0%">      <Setter Property="Opacity" Value="0.0"/>      <Setter Property="RotateTransform.Angle" Value="0.0"/>     </KeyFrame>     <KeyFrame Cue="100%">       <Setter Property="Opacity" Value="1.0"/>      <Setter Property="RotateTransform.Angle" Value="90.0"/>     </KeyFrame>    </Animation>   </Style.Animations>  </Style> </Window.Styles>
```
The red rectangle is faded-in and rotated at the same time.
![](https://docs.avaloniaui.net/assets/images/keyframe-composite-animation-a844b40965bbeae42b283e2b33b86aec.gif)
### Configuring animation​
#### Delay​
You can add a delay to the start of an animation by setting the delay attribute of the animation element. For example:
```bash
<Animation Duration="0:0:1"      Delay="0:0:1">   ...</Animation>
```
#### Repeat​
You can make an animation repeat for a set number of times, or indefinitely. To repeat for a finite number of iterations set the IterationCount attribute on the animation element like this:
`IterationCount` ```bash
<Animation IterationCount="5">  ...</Animation>
```
To repeat an animation indefinitely, use the special "INFINITE" value. For example:
`"INFINITE"` ```bash
<Animation IterationCount="INFINITE">  ...</Animation>
```
#### Playback Direction​
By default an animation plays forward. That is it follows the profile of the easing function from left to right. You can alter this behavior by setting the PlaybackDirection attribute on the animation element. For example:
`PlaybackDirection` ```bash
<Animation IterationCount="9" PlaybackDirection="AlternateReverse">  ...</Animation>
```
The following table describes the options:
`Normal` `Reverse` `Alternate` `AlternateReverse` #### Fill Mode​
The fill mode attribute of an animation defines how the properties being set will persist after it runs, or during any gaps between runs. For example:
```bash
<Animation IterationCount="9" FillMode="Backward">  ...</Animation>
```
The following table describes the options:
`None` `Forward` `Backward` `Both` `Forward` `Backward` #### Easing Function​
An easing function defines how a property is varied over time during an animation.
The default easing function is linear (above left), but you use another pattern by setting the name of the desired function in the easing attribute. For example to use the 'bounce ease in' function (above right):
```bash
<Animation Duration="0:0:1"      Delay="0:0:1"      Easing="BounceEaseIn">   ...</Animation>
```
For a full list of the Avalonia UI easing functions, see the reference here.
You can also add your own custom easing function class like this:
```bash
<Animation Duration="0:0:1"      Delay="0:0:1">  <Animation.Easing>    <local:YourCustomEasingClassHere/>  </Animation.Easing>   ...</Animation>
```
### Running animation from the code behind​
In some situations, developers need more flexibility with animation lifetime, comparing to the XAML style selectors. Easiest would be to define animation in the Resources dictionary.
`Resources` While defining Animation this way, it's important to specify both x:Key and x:SetterTargetType. First one will be used to access animation by the key, and second helps compiler to create strongly typed setters.
`Animation` `x:Key` `x:SetterTargetType` ```bash
<Window xmlns="https://github.com/avaloniaui">  <Window.Resources>    <Animation x:Key="ResourceAnimation"          x:SetterTargetType="Rectangle"          Duration="0:0:3">       <KeyFrame Cue="0%">        <Setter Property="Opacity" Value="0.0"/>      </KeyFrame>      <KeyFrame Cue="100%">        <Setter Property="Opacity" Value="1.0"/>      </KeyFrame>    </Animation>  </Window.Resources>  <Rectangle x:Name="Rect" /></Window>
```
Now, this animation can be accessed and executed in a custom code behind handler.
```bash
var animation = (Animation)this.Resources["ResourceAnimation"];// Running XAML animation on the Rect control. await animation.RunAsync(Rect);
```
RunAsync returns a task which is completed with the animation. If animation is infinite/repeating, task will never end, unless cancelled externally by passing CancellationToken to the RunAsync method.
`RunAsync` `CancellationToken` While it's easier to define animations in XAML, it's also possible to do completely in C# code. It's possible to create an instance of Animation type, and populate key frames collection.
`Animation` - Example
- Animate Two Properties
- Configuring animationDelayRepeatPlayback DirectionFill ModeEasing Function
- Delay
- Repeat
- Playback Direction
- Fill Mode
- Easing Function
- Running animation from the code behind
- Delay
- Repeat
- Playback Direction
- Fill Mode
- Easing Function
# How To Use Gradients | Avalonia Docs
- How-To Guides
- Graphics and Animation
- How To Use Gradients
## How To Use Gradients
This guide explains how to effectively use LinearGradientBrush in Avalonia to create beautiful gradient effects.
### Basic Syntax​
A LinearGradientBrush is defined using the following basic structure:
```bash
<LinearGradientBrush StartPoint="0%,0%" EndPoint="100%,0%">  <GradientStop Color="#COLOR1" Offset="0.0"/>  <GradientStop Color="#COLOR2" Offset="1.0"/></LinearGradientBrush>
```
### Key Properties​
#### StartPoint and EndPoint​
- Defines the direction of the gradient
- Uses percentage values (e.g., "0%,0%") or decimal values (0,0)
- Common patterns: Horizontal: StartPoint="0%,50%" EndPoint="100%,50%" Vertical: StartPoint="50%,0%" EndPoint="50%,100%" Diagonal: StartPoint="0%,0%" EndPoint="100%,100%"
- Horizontal: StartPoint="0%,50%" EndPoint="100%,50%"
- Vertical: StartPoint="50%,0%" EndPoint="50%,100%"
- Diagonal: StartPoint="0%,0%" EndPoint="100%,100%"
- Horizontal: StartPoint="0%,50%" EndPoint="100%,50%"
- Vertical: StartPoint="50%,0%" EndPoint="50%,100%"
- Diagonal: StartPoint="0%,0%" EndPoint="100%,100%"
#### GradientStop Elements​
- Define colors and their positions in the gradient
- Properties: Color: The color value (Hex code or named color) Offset: Position in the gradient (0.0 to 1.0)
- Color: The color value (Hex code or named color)
- Offset: Position in the gradient (0.0 to 1.0)
- Color: The color value (Hex code or named color)
- Offset: Position in the gradient (0.0 to 1.0)
`Color` `Offset` ### Common Gradient Patterns​
#### 1. Simple Horizontal Gradient​
```bash
<LinearGradientBrush StartPoint="0%,50%" EndPoint="100%,50%">  <GradientStop Color="#FF6B6B" Offset="0.0"/>  <GradientStop Color="#4ECDC4" Offset="1.0"/></LinearGradientBrush>
```
#### 2. Multi-Color Gradient​
```bash
<LinearGradientBrush StartPoint="0%,50%" EndPoint="100%,50%">  <GradientStop Color="#FF6B6B" Offset="0.0"/>  <GradientStop Color="#FF8E53" Offset="0.3"/>  <GradientStop Color="#FF5E3A" Offset="0.6"/>  <GradientStop Color="#4ECDC4" Offset="1.0"/></LinearGradientBrush>
```
#### 3. Vertical Gradient​
```bash
<LinearGradientBrush StartPoint="50%,0%" EndPoint="50%,100%">  <GradientStop Color="#A8E6CF" Offset="0.0"/>  <GradientStop Color="#3D84A8" Offset="1.0"/></LinearGradientBrush>
```
### Common Use Cases​
#### Button Backgrounds​
```bash
<Button>  <Button.Background>    <LinearGradientBrush StartPoint="0%,0%" EndPoint="0%,100%">      <GradientStop Color="#4CAF50" Offset="0.0"/>      <GradientStop Color="#45A049" Offset="1.0"/>    </LinearGradientBrush>  </Button.Background></Button>
```
#### Panel Backgrounds​
```bash
<Border CornerRadius="8">  <Border.Background>    <LinearGradientBrush StartPoint="0%,0%" EndPoint="100%,100%">      <GradientStop Color="#FF9A9E" Offset="0.0"/>      <GradientStop Color="#FAD0C4" Offset="0.5"/>      <GradientStop Color="#FFD1FF" Offset="1.0"/>    </LinearGradientBrush>  </Border.Background></Border>
```
### Example​
Below is the code to replicate the following sample.
![Gradient Sample](https://docs.avaloniaui.net/assets/images/gradients-2c43b6b99000837e068054575b33d238.png)
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="SampleApp.MainWindow"    Title="Gradient Example">      <StackPanel Spacing="20" Margin="20">    <!-- Horizontal gradient with multiple color stops -->    <Border Height="100" CornerRadius="8">      <Border.Background>        <LinearGradientBrush StartPoint="0%,50%" EndPoint="100%,50%">          <GradientStop Color="#FF6B6B" Offset="0.0"/>          <GradientStop Color="#FF8E53" Offset="0.3"/>          <GradientStop Color="#FF5E3A" Offset="0.6"/>          <GradientStop Color="#4ECDC4" Offset="1.0"/>        </LinearGradientBrush>      </Border.Background>      <TextBlock Text="Horizontal Gradient"           HorizontalAlignment="Center"           VerticalAlignment="Center"           Foreground="White"/>    </Border>    <!-- Vertical gradient with smooth transitions -->    <Border Height="100" CornerRadius="8">      <Border.Background>        <LinearGradientBrush StartPoint="50%,0%" EndPoint="50%,100%">          <GradientStop Color="#A8E6CF" Offset="0.0"/>          <GradientStop Color="#3D84A8" Offset="0.5"/>          <GradientStop Color="#46CDCF" Offset="1.0"/>        </LinearGradientBrush>      </Border.Background>      <TextBlock Text="Vertical Gradient"           HorizontalAlignment="Center"           VerticalAlignment="Center"           Foreground="White"/>    </Border>    <!-- Diagonal gradient with multiple stops -->    <Border Height="100" CornerRadius="8">      <Border.Background>        <LinearGradientBrush StartPoint="0%,0%" EndPoint="100%,100%">          <GradientStop Color="#FF9A9E" Offset="0.0"/>          <GradientStop Color="#FAD0C4" Offset="0.25"/>          <GradientStop Color="#FFB6C1" Offset="0.5"/>          <GradientStop Color="#FFD1FF" Offset="1.0"/>        </LinearGradientBrush>      </Border.Background>      <TextBlock Text="Diagonal Gradient"           HorizontalAlignment="Center"           VerticalAlignment="Center"           Foreground="Black"/>    </Border>    <!-- Custom angle gradient with cycling effect -->    <Border Height="100" CornerRadius="8">      <Border.Background>        <LinearGradientBrush StartPoint="0%,0%" EndPoint="100%,50%">          <GradientStop Color="#08AEEA" Offset="0.0"/>          <GradientStop Color="#2AF598" Offset="0.3"/>          <GradientStop Color="#08AEEA" Offset="0.6"/>          <GradientStop Color="#2AF598" Offset="1.0"/>        </LinearGradientBrush>      </Border.Background>      <TextBlock Text="Custom Angle Gradient"           HorizontalAlignment="Center"           VerticalAlignment="Center"           Foreground="White"/>    </Border>  </StackPanel></Window>
```
- Basic Syntax
- Key PropertiesStartPoint and EndPointGradientStop Elements
- StartPoint and EndPoint
- GradientStop Elements
- Common Gradient Patterns1. Simple Horizontal Gradient2. Multi-Color Gradient3. Vertical Gradient
- 1. Simple Horizontal Gradient
- 2. Multi-Color Gradient
- 3. Vertical Gradient
- Common Use CasesButton BackgroundsPanel Backgrounds
- Button Backgrounds
- Panel Backgrounds
- Example
- StartPoint and EndPoint
- GradientStop Elements
- 1. Simple Horizontal Gradient
- 2. Multi-Color Gradient
- 3. Vertical Gradient
- Button Backgrounds
- Panel Backgrounds
# Cross Fade Page Transition | Avalonia Docs
- How-To Guides
- Graphics and Animation
- Page Transitions
- Cross Fade Page Transition
## Cross Fade Page Transition
The cross fade page transition fades out the current page and fades in the new page by animating the opacity.
- XAML
- C#
```bash
<CrossFade Duration="0:00:00.500" />
```
```bash
var transition = new CrossFade(TimeSpan.FromMilliseconds(500));
```
### More Information​
For the complete API documentation about this transition, see here.
View the source code on GitHub CrossFade.cs
`CrossFade.cs` - More Information
# Page Slide Transition | Avalonia Docs
- How-To Guides
- Graphics and Animation
- Page Transitions
- Page Slide Transition
## Page Slide Transition
The page slide transition moves the old page out of view, and the new page into view, for the given duration. You can specify the slide direction using the orientation property (default horizontal).
```bash
<PageSlide Duration="0:00:00.500" Orientation="Vertical" />
```
```bash
var transition = new PageSlide(TimeSpan.FromMilliseconds(500),                 PageSlide.SlideAxis.Vertical);
```
### More Information​
For the complete API documentation about this transition, see here.
View the source code on GitHub PageSlide.cs
`PageSlide.cs` - More Information
# Page Transition Combinations | Avalonia Docs
- How-To Guides
- Graphics and Animation
- Page Transitions
- Page Transition Combinations
## Page Transition Combinations
You can combine two or more built-in page transitions to create a new effect.
Add a CompositePageTransition element to combine the effects of two or more different built-in transitions.
`CompositePageTransition` For example, the code here sample creates a transition that slides the views diagonally (the result of combining a horizontal and vertical slide), and also fades the old views out and the new in.
```bash
<CompositePageTransition>  <CrossFade Duration="0:00:00.500" />  <PageSlide Duration="0:00:00.500" Orientation="Horizontal" />  <PageSlide Duration="0:00:00.500" Orientation="Vertical" /></CompositePageTransition>
```
```bash
var compositeTransition = new CompositePageTransition();compositeTransition.PageTransitions.Add(new PageSlide(TimeSpan.FromMilliseconds(500), PageSlide.SlideAxis.Vertical));compositeTransition.PageTransitions.Add(new PageSlide(TimeSpan.FromMilliseconds(500), PageSlide.SlideAxis.Horizontal));compositeTransition.PageTransitions.Add(new CrossFade(TimeSpan.FromMilliseconds(500)));
```
##### Source code​
CompositePageTransition.cs
##### Reference​
CompositePageTransition
# How To Create a Custom Page Transition | Avalonia Docs
- How-To Guides
- Graphics and Animation
- Page Transitions
- How To Create a Custom Page Transition
## How To Create a Custom Page Transition
This guide will show you how to create your own custom page transition by implementing the IPageTransition interface.
`IPageTransition` The interface has a single method that you need to implement:
```bash
public Task Start(Visual? from, Visual? to, bool forward,                 CancellationToken cancellationToken){  // Setup the transition here.}
```
### Example​
This example will shrink the old view and then open up the new view vertically.
```bash
using Avalonia.VisualTree;public class CustomTransition : IPageTransition{  /// <summary>  /// Initializes a new instance of the <see cref="CustomTransition"/> class.  /// </summary>  public CustomTransition()  {  }  /// <summary>  /// Initializes a new instance of the <see cref="CustomTransition"/> class.  /// </summary>  /// <param name="duration">The duration of the animation.</param>  public CustomTransition(TimeSpan duration)  {    Duration = duration;  }  /// <summary>  /// Gets the duration of the animation.  /// </summary>  public TimeSpan Duration { get; set; }  public async Task Start(Visual from, Visual to, bool forward,                       CancellationToken cancellationToken)  {    if (cancellationToken.IsCancellationRequested)    {      return;    }    var tasks = new List<Task>();    var parent = GetVisualParent(from, to);    var scaleYProperty = ScaleTransform.ScaleYProperty;    if (from != null)    {      var animation = new Animation      {        FillMode = FillMode.Forward,        Children =        {          new KeyFrame          {            Setters = { new Setter             { Property = scaleYProperty, Value = 1d } },            Cue = new Cue(0d)          },          new KeyFrame          {            Setters =            {              new Setter              {                Property = scaleYProperty,                Value = 0d              }            },            Cue = new Cue(1d)          }        },        Duration = Duration      };      tasks.Add(animation.RunAsync(from, cancellationToken));    }    if (to != null)    {      to.IsVisible = true;      var animation = new Animation      {        FillMode = FillMode.Forward,        Children =        {          new KeyFrame          {            Setters =            {              new Setter              {                Property = scaleYProperty,                Value = 0d              }            },            Cue = new Cue(0d)          },          new KeyFrame          {            Setters = { new Setter             {               Property = scaleYProperty, Value = 1d             }},            Cue = new Cue(1d)          }        },        Duration = Duration      };      tasks.Add(animation.RunAsync(to, cancellationToken));    }    await Task.WhenAll(tasks);    if (from != null && !cancellationToken.IsCancellationRequested)    {      from.IsVisible = false;    }  }  /// <summary>  /// Gets the common visual parent of the two control.  /// </summary>  /// <param name="from">The from control.</param>  /// <param name="to">The to control.</param>  /// <returns>The common parent.</returns>  /// <exception cref="ArgumentException">  /// The two controls do not share a common parent.  /// </exception>  /// <remarks>  /// Any one of the parameters may be null, but not both.  /// </remarks>  private static Visual GetVisualParent(Visual? from, Visual? to)  {    var p1 = (from ?? to)!.GetVisualParent();    var p2 = (to ?? from)!.GetVisualParent();    if (p1 != null && p2 != null && p1 != p2)    {      throw new ArgumentException(                "Controls for PageSlide must have same parent.");    }    return p1 ?? throw new InvalidOperationException(                        "Cannot determine visual parent.");  }}
```
![](https://docs.avaloniaui.net/assets/images/custom-page-transition-07b8db42817a78df94e9c229b07b3557.webp)
### More Information​
For the complete API documentation about this interface see here.
View the source code on GitHub IPageTransition.cs
`IPageTransition.cs` - Example
- More Information
# Types of Control | Avalonia Docs
- How-To Guides
- Custom Controls
- Types of Control
## Types of Control
If you want to create your own controls, there are three main categories of control in Avalonia. The first thing to do is choose the category of control that best suits your use-case.
#### User Controls​
UserControls are the simplest way to author controls. This type of control is best for "views" or "pages" that are specific to an application. UserControls are authored in the same way as you would author a Window: by creating a new UserControl from a template and adding controls to it.
#### Templated Controls​
TemplatedControls are best used for generic controls that can be shared among various applications. They are lookless controls, meaning that they can be restyled for different themes and applications. The majority of standard controls defined by Avalonia fit into this category.
In WPF/UWP you would inherit from the Control class to create a new templated control, but in Avalonia you should inherit from TemplatedControl.
If you want to provide a Style for your TemplatedControl in a separate file, remember to include this file in your Application via StyleInclude.
#### Basic Controls​
Basic Controls are the foundation of user interfaces - they draw themselves using geometry by overriding the Visual.Render method. Controls such as TextBlock and Image fall into this category.
In WPF/UWP you would inherit from the FrameworkElement class to create a new basic control, but in Avalonia you should inherit from Control.
- User Controls
- Templated Controls
- Basic Controls
# How To Troubleshoot Styles | Avalonia Docs
- How-To Guides
- Styles and Resources
- How To Troubleshoot Styles
## 👉 How To Troubleshoot Styles
Much of the Avalonia UI styling system corresponds to CSS styling approaches. So without knowledge of this technology, you may find the hints here helpful.
### Selector has no Targets​
An Avalonia UI selector, like a CSS selector, does not raise an error or warning when there are no controls which can be matched. The style will silently fail to show.
Check whether you have used a name or class that does not exist.
Check whether you have used a child selector where there are no children to match.
### Include File Sequence​
Styles are applied in order of declaration. If there are multiple style files included that target the same control property, the last style included will override the previous ones. For example:
```bash
<Style Selector="TextBlock.header">  <Style Property="Foreground" Value="Green" /></Style>
```
```bash
<Style Selector="TextBlock.header">  <Style Property="Foreground" Value="Blue" />  <Style Property="FontSize" Value="16" /></Style>
```
```bash
<StyleInclude Source="Style1.axaml" /><StyleInclude Source="Style2.axaml" />
```
Here styles from file Styles1.axaml were applied first, so setters in styles of file Styles2.axaml take priority. The resulting TextBlock will have FontSize="16" and Foreground="Green". The same order prioritization happens within style files also.
### Locally Set Properties Have Priority​
A local value defined directly on a control often has higher priority than any style value. So in this example the text block will have a red foreground:
```bash
<Style Selector="TextBlock.header">  <Setter Property="Foreground" Value="Green" /></Style>...<TextBlock Classes="header" Foreground="Red" />
```
You can see the full list of value priorities in the BindingPriority enum, where lower enum values have the higher priority.
`BindingPriority` `Animation` `LocalValue` `StyleTrigger` `TemplatedParent` `Style` `Unset` The exception is that Animation values have the highest priority and can even override local values.
`Animation` Some default Avalonia UI styles use local values in their templates instead of template bindings or style setters. This makes it impossible to update the template property without replacing the whole template.
#### Missing style pseudo class (trigger) selector​
Let's imagine a situation in which you might expect a second style to override previous one, but it doesn't:
```bash
<Style Selector="Border:pointerover">  <Setter Property="Background" Value="Blue" /></Style><Style Selector="Border">  <Setter Property="Background" Value="Red" /></Style>...<Border Width="100" Height="100" Margin="100" />
```
With this code example the Border has a Red background normally and Blue when the pointer is over it. This is because as with CSS more specific selectors have precedence. It is an issue, when you want to override default styles of any state (pointerover, pressed or others) with a single style. To achieve it you will need to have new styles for these states as well.
`Border` Visit the Avalonia source code to find the original templates when this happens and copy and paste the styles with pseudoclasses into your code.
#### Selector with a pseudoclass doesn't override the default​
The following code example of styles that can be expected to work on top of default styles:
```bash
<Style Selector="Button">  <Setter Property="Background" Value="Red" /></Style><Style Selector="Button:pointerover">  <Setter Property="Background" Value="Blue" /></Style>
```
You might expect the Button to be red by default and blue when pointer is over it. In fact, only setter of first style will be applied, and second one will be ignored.
`Button` The reason is hidden in the Button's template. You can find the default templates in the Avalonia source code (old Default theme and new Fluent theme), but for convenience here we have simplified one from the Fluent theme:
```bash
<Style Selector="Button">  <Setter Property="Background" Value="{DynamicResource ButtonBackground}"/>  <Setter Property="Template">    <ControlTemplate>      <ContentPresenter Name="PART_ContentPresenter"               Background="{TemplateBinding Background}"               Content="{TemplateBinding Content}"/>    </ControlTemplate>  </Setter></Style><Style Selector="Button:pointerover /template/ ContentPresenter#PART_ContentPresenter">  <Setter Property="Background" Value="{DynamicResource ButtonBackgroundPointerOver}" /></Style>
```
The actual background is rendered by a ContentPresenter, which in the default is bound to the Buttons Background property. However in the pointer-over state the selector is directly applying the background to the ContentPresenter (Button:pointerover /template/ ContentPresenter#PART_ContentPresenter) That's why when our setter was ignored in the previous code example. The corrected code should target content presenter directly as well:
`ContentPresenter` `Background` `ContentPresenter (Button:pointerover /template/ ContentPresenter#PART_ContentPresenter` ```bash
<!-- Here #PART_ContentPresenter name selector is not necessary, but was added to have more specific style --><Style Selector="Button:pointerover /template/ ContentPresenter#PART_ContentPresenter">  <Setter Property="Background" Value="Blue" /></Style>
```
You can see this behavior for all controls in the default themes (both old Default and the new Fluent), not just Button. And not just for Background, but also other state-dependent properties.
Why default styles change the ContentPresenter Background property directly instead of changing the Button.Background property?
`Background` `Button.Background` This is because if the user were to set a local value on the button, it would override all styles, and make button always the same color. For more details see this reverted PR.
#### Previous value of specific properties is not restored when style is not applied anymore​
In Avalonia we have multiple types of properties, and one of them, Direct Property, doesn't support styling at all. These properties work in simplified way to achieve lower overhead and higher performance, and do not store multiple values depending on priority. Instead only latest value is saved and cannot be restored. You can find more details about properties here.
Typical example is CommandProperty. It is defined as a DirectProperty, and it will never work properly. In the future attempt to style direct property will be resulted in compile time error, see #6837.
- Selector has no Targets
- Include File Sequence
- Locally Set Properties Have PriorityMissing style pseudo class (trigger) selectorSelector with a pseudoclass doesn't override the defaultPrevious value of specific properties is not restored when style is not applied anymore
- Missing style pseudo class (trigger) selector
- Selector with a pseudoclass doesn't override the default
- Previous value of specific properties is not restored when style is not applied anymore
- Missing style pseudo class (trigger) selector
- Selector with a pseudoclass doesn't override the default
- Previous value of specific properties is not restored when style is not applied anymore
# How To Use Custom Fonts | Avalonia Docs
- How-To Guides
- Styles and Resources
- How To Use Custom Fonts
## How To Use Custom Fonts
Customizing your Avalonia application with unique fonts can add a distinctive look and feel. This guide will walk you through the process of integrating custom fonts into your Avalonia application.
### Add Your Custom Font to the Project​
Before you can use a custom font, you need to include it in your project.
In this guide, we will be using a font called Nunito which is already stored in our application resources under avares://GoogleFonts/Assets/Fonts.
`avares://GoogleFonts/Assets/Fonts` Ensure that the fonts have the build property set to AvaloniaResource.
`AvaloniaResource` ### Declare Your Font in Application Resources​
In your Avalonia application, open your App.xaml file and include your custom font inside <Application.Resources>. Assign it a key, which you will use to reference it in your application. In this case, we have assigned the key NunitoFont.
`App.xaml` `<Application.Resources>` `NunitoFont` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="GoogleFonts.App"       RequestedThemeVariant="Default">  <Application.Styles>    <FluentTheme />  </Application.Styles>  <Application.Resources>    <FontFamily x:Key="NunitoFont">avares://GoogleFonts/Assets/Fonts#Nunito</FontFamily>  </Application.Resources></Application>
```
### Use Your Custom Font​
Once your font is declared in your application resources, you can use it in your application.
To reference your custom font, use the FontFamily attribute with the StaticResource markup extension. You need to pass the key of the declared font as the parameter. In this case, NunitoFont is the key for our custom font.
`FontFamily` `StaticResource` `NunitoFont` Here's an example of how to apply our custom Nunito font to a TextBlock:
`Nunito` `TextBlock` ```bash
<TextBlock Text="{Binding Greeting}"      FontSize="70"      FontFamily="{StaticResource NunitoFont}"      HorizontalAlignment="Center" VerticalAlignment="Center"/>
```
In the above example, the TextBlock control will use the Nunito font that we declared in our application resources. The text bound to the TextBlock will now appear in the Nunito font at the specified font size of 70.
`TextBlock` `Nunito` `TextBlock` `Nunito` Remember that the FontFamily attribute can be applied to any control that has the FontFamily property, meaning you can use your custom font throughout your application.
`FontFamily` `FontFamily` And that's it! You've successfully integrated a custom font into your Avalonia application. Now you can add a unique touch to your application's UI with the fonts of your choice.
### Adding a Font to the Font Collection​
The EmbeddedFontCollection provides an easy way to add fonts to your application's collection of fonts without requiring a reference to a resource when using them. For example, instead of setting the FontFamily to {StaticResource NunitoFont}, you can simply reference the name of the font family directly.
`EmbeddedFontCollection` `FontFamily` `{StaticResource NunitoFont}` ```bash
<TextBlock  Text="{Binding Greeting}"  FontSize="70"  FontFamily="Nunito"  HorizontalAlignment="Center" VerticalAlignment="Center" />
```
This requires additional setup on application construction, but it removes the need to remember a unique resource key when authoring your controls.
#### Defining a Font Collection​
First, we need to define a collection of fonts by specifying the font family name and the directory in which the font files reside.
```bash
public sealed class InterFontCollection : EmbeddedFontCollection{  public InterFontCollection() : base(    new Uri("fonts:Inter", UriKind.Absolute),    new Uri("avares://Avalonia.Fonts.Inter/Assets", UriKind.Absolute))  {  }}
```
Here, Inter is the name of the font family and avares://Avalonia.Fonts.Inter/Assets is the resource locator for the directory containing the font files. The actual names of the font files are not significant since the EmbeddedFontCollection will search every file in the given directory and only load those fonts with the given font family name.
`Inter` `avares://Avalonia.Fonts.Inter/Assets` `EmbeddedFontCollection` For more information on how to create a resource locator, see Assets for a primer on including assets in your project.
#### Adding the Font Collection​
Next, we need to add this font collection to the application. This can be done by using AppBuilder.ConfigureFonts to configure the FontManager to include your fonts on application construction.
`AppBuilder.ConfigureFonts` `FontManager` ```bash
public static class Program{  [STAThread]  public static void Main(string[] args) =>    BuildAvaloniaApp()      .StartWithClassicDesktopLifetime(args);  public static AppBuilder BuildAvaloniaApp() =>    AppBuilder.Configure<App>()      .UsePlatformDetect()      .ConfigureFonts(fontManager =>      {        fontManager.AddFontCollection(new InterFontCollection());      })      .LogToTrace();}
```
#### Creating Font Packages​
The Avalonia.Fonts.Inter package shows how you can create a separate project to contain one or many fonts that you might use in multiple projects. Once you have created and published a project similar to this, using the font becomes as simple as appending a method call to your application construction.
`Avalonia.Fonts.Inter` ```bash
public static class Program{  [STAThread]  public static void Main(string[] args) =>    BuildAvaloniaApp()      .StartWithClassicDesktopLifetime(args);  public static AppBuilder BuildAvaloniaApp() =>    AppBuilder.Configure<App>()      .UsePlatformDetect()      .WithInterFont()      .LogToTrace();}
```
### Which Fonts Are Supported?​
Most TrueType (.ttf) and OpenType (.otf, .ttf) fonts are supported. However, some font features, such as "Variable fonts" are not currently supported (see: Issue #11092).
`.ttf` `.otf` `.ttf` - Add Your Custom Font to the Project
- Declare Your Font in Application Resources
- Use Your Custom Font
- Adding a Font to the Font CollectionDefining a Font CollectionAdding the Font CollectionCreating Font Packages
- Defining a Font Collection
- Adding the Font Collection
- Creating Font Packages
- Which Fonts Are Supported?
- Defining a Font Collection
- Adding the Font Collection
- Creating Font Packages
# Assets and Images | Avalonia Docs
- Basics
- User Interface
- Assets and Images
## Assets
Many applications need to include assets such as bitmaps, styles and resource dictionaries. Resource dictionaries contain graphical fundamentals that can be declared in XAML. Styles can also be written in XAML, but bitmap assets are binary files, for example PNG and JPEG formats.
### Including assets​
You include assets in an application by using the <AvaloniaResource> element in your project file.
`<AvaloniaResource>` For example, the Avalonia .NET Core MVVM App solution template creates a folder called Assets (containing the avalonia-logo.ico file) and adds an element to the project file to include any files located there. As follows:
`Assets` `avalonia-logo.ico` ```bash
<ItemGroup> <AvaloniaResource Include="Assets\**"/></ItemGroup>
```
You can include whatever files you want by adding additional <AvaloniaResource> elements in this item group.
`<AvaloniaResource>` The element name AvaloniaResource here only indicates that the assets will be internally stored as .NET resources by the build. However, in Avalonia UI terms, these files are called 'Assets' to distinguish them from 'XAML resources'.
`AvaloniaResource` #### Referencing Included Assets​
Once asset files are included, they can be referenced as needed in the XAML that defines your UI. For example, these assets are referenced by specifying their relative path:
```bash
<Image Source="icon.png"/><Image Source="images/icon.png"/><Image Source="../icon.png"/>
```
As an alternative, you can use the rooted path:
```bash
<Image Source="/Assets/icon.png"/>
```
### Library Assets​
If the asset is included in a different assembly from the XAML file, then you use the avares: URI scheme. For example, if the asset is contained in an assembly called MyAssembly.dll in a Assets folder, then you use:
`avares:` `MyAssembly.dll` `Assets` ```bash
<Image Source="avares://MyAssembly/Assets/icon.png"/>
```
#### Asset Type Conversion​
Avalonia UI has built-in converters which can load assets for bitmaps, icons and fonts out of the box. So an assets Uri can be automatically converted to any of following:
- Image - Image type
- Bitmap - Bitmap type
- Window Icon - WindowIcon type
- Font - FontFamily type
`Image` `Bitmap` `WindowIcon` `FontFamily` #### Loading Assets in Code​
You can write code to load assets using the AssetLoader static class. For example:
`AssetLoader` ```bash
var bitmap = new Bitmap(AssetLoader.Open(new Uri(uri)));
```
The uri variable in the above code can contain any valid URI with avares: scheme (as described above).
`uri` `avares:` Avalonia UI does not provide support for file://, http://, or https:// schemes. If you want to load files from disk or the Web, you must implement that functionality yourself or use community implementations.
`file://` `http://` `https://` Avalonia UI has a community implementation for an image loader at https://github.com/AvaloniaUtils/AsyncImageLoader.Avalonia
- Including assetsReferencing Included Assets
- Referencing Included Assets
- Library AssetsAsset Type ConversionLoading Assets in Code
- Asset Type Conversion
- Loading Assets in Code
- Referencing Included Assets
- Asset Type Conversion
- Loading Assets in Code
# Animations | Avalonia Docs
- Basics
- User Interface
- Animations
## Animations
There are two types of animations in Avalonia UI:
- Keyframe Animation - can change one or more property values using a timeline. Keyframes are defined along the timeline at cue points. The properties being changed are adjusted between keyframes using an easing function (which is a straight-line interpolation by default). Keyframe animations are a very versatile type of animation.
- Transitions - can change a single property.
### Keyframe Animation​
The simplest keyframe animation will change one property value over a a specified duration by defining two keyframes with cue points at the start (0% of the duration) and the end (100% of the duration).
The property value is then changed over time between the keyframes using the profile defined by an easing function. The default easing function is also the simplest - a straight-line interpolation between two keyframes.
You can see the full range of easing functions in the reference, here.
### Triggering Animations​
Avalonia UI animations defined in XAML rely on selectors for their triggering behavior. Selectors can always apply to a control, or they can conditionally apply (for example if the control has a style class applied).
If the selector is not conditional then the animation will be triggered when a matching Control is spawned into the visual tree. Otherwise, the animations will run whenever its selector is activated. When the selector no longer matches, the currently running animation will be cancelled.
`Control` ### Other Animation Settings​
- Delay
- Repeat
- Playback Direction
- Value Fill Mode
- Easing Function
- Keyframe Animation
- Triggering Animations
- Other Animation Settings
# How To Use Theme Variants | Avalonia Docs
- How-To Guides
- Styles and Resources
- How To Use Theme Variants
## How To Use Theme Variants
Because theme variants are deeply integrated into resources system, it is important to understand the Avalonia resources first.
### Introduction​
In Avalonia, a theme variant refers to a specific visual appearance of control based on a chosen theme.
`theme variant` By using theme variants, developers can create visually appealing and consistent user interfaces that adapt to different user preferences or system settings. For example, an application may provide a light theme variant with a white background and black text, as well as a dark theme variant with a black background and white text. The user can choose their preferred theme, and the application will adjust its appearance accordingly.
Avalonia's built-in themes, SimpleTheme and FluentTheme, seamlessly support Dark and Light variants without extra code. This allows applications to adapt dynamically based on system preferences while using build-in controls. For advanced customization, this documentation explains defining custom variant-dependent resources and their referencing.
`SimpleTheme` `FluentTheme` `Dark` `Light` ### Switching current theme variant​
By default, Avalonia inherits theme variant set by user preferences system-wide. Application has control over theme variants through two important properties: ActualThemeVariant and RequestedThemeVariant. These properties allow to manage and switch theme variants at different levels within your application.
#### ActualThemeVariant Property​
`ActualThemeVariant` The ActualThemeVariant read-only property is used to retrieve the UI theme currently in use by a control, window, or application. It represents the theme variant that is actively applied to the element. This property is available on each control and is inherited down the tree. Its value also used by the styling system while accessing theme dictionaries.
`theme dictionaries` #### RequestedThemeVariant Property​
`RequestedThemeVariant` The RequestedThemeVariant property allows to override theme variant and specify a desired variant for a Application, Window (TopLevel) or ThemeVariantScope.
`Application` `Window` `TopLevel` `ThemeVariantScope` To override global application variant instead of using system default:
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"       RequestedThemeVariant="Dark"> <Application.Styles>  <FluentTheme /> </Application.Styles></Application>
```
Or it is possible to redefine theme variant per specific subtree using ThemeVariantScope control. In the example below Window uses Dark variant, while ThemeVariantScope inside redefines it with Light variant:
`ThemeVariantScope` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml'    x:Class="AvaloniaApplication.MainWindow"    RequestedThemeVariant="Dark"    Background="Gray"> <StackPanel Spacing="5" Margin="5">  <Button Content="Dark button" />  <ThemeVariantScope RequestedThemeVariant="Light">   <Button Content="Light button" />  </ThemeVariantScope> </StackPanel></Window>
```
If it's required to use reset RequestedThemeVariant value, RequestedThemeVariant="Default" value can be set on it.
`RequestedThemeVariant="Default"` Changing Window RequestedThemeVariant also affects window decorations variant on platform where it is supported.
### Defining and referencing custom variant specific resources​
In Avalonia, theme variant specific resources can be defined in the ResourceDictionary using the ThemeDictionaries property.
`ResourceDictionary` `ThemeDictionaries` Typically, developers use Light or Dark as the key for the theme variants. Using Default as the key marks this specific theme dictionary as a fallback in case the theme variant or resource key is not found in other theme dictionaries.
`Light` `Dark` `Default` Continuing previous example, let's add BackgroundBrush and ForegroundBrush with different values per theme variant:
`BackgroundBrush` `ForegroundBrush` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml'    x:Class="Sandbox.MainWindow"    RequestedThemeVariant="Dark"    Background="Gray"> <Window.Resources>  <ResourceDictionary>   <ResourceDictionary.ThemeDictionaries>    <ResourceDictionary x:Key='Light'>     <SolidColorBrush x:Key='BackgroundBrush'>SpringGreen</SolidColorBrush>     <SolidColorBrush x:Key='ForegroundBrush'>Black</SolidColorBrush>    </ResourceDictionary>    <ResourceDictionary x:Key='Dark'>     <SolidColorBrush x:Key='BackgroundBrush'>DodgerBlue</SolidColorBrush>     <SolidColorBrush x:Key='ForegroundBrush'>White</SolidColorBrush>    </ResourceDictionary>   </ResourceDictionary.ThemeDictionaries>  </ResourceDictionary> </Window.Resources>  <Window.Styles>  <Style Selector="Button">   <Setter Property="Background" Value="{DynamicResource BackgroundBrush}" />   <Setter Property="Foreground" Value="{DynamicResource ForegroundBrush}" />  </Style> </Window.Styles> <StackPanel Spacing="5" Margin="5">  <Button Content="Dark button"      Background="{DynamicResource BackgroundBrush}"      Foreground="{DynamicResource ForegroundBrush}" />  <ThemeVariantScope RequestedThemeVariant="Light">   <Button Content="Light button"       Background="{DynamicResource BackgroundBrush}"       Foreground="{DynamicResource ForegroundBrush}" />  </ThemeVariantScope> </StackPanel></Window>
```
Note that resources defined in ThemeDictionaries are only available for consumption using the DynamicResource markup extension. The StaticResource markup extension will not find such resources and will instead produce an exception at runtime unless a resource with an identical key exists in a non-ThemeDictionaries portion of a ResourceDictionary.
`ThemeDictionaries` `DynamicResource` `StaticResource` `ThemeDictionaries` `ResourceDictionary` For more details about using resources please follow How To Use Resources page.
- Introduction
- Switching current theme variantActualThemeVariant PropertyRequestedThemeVariant Property
- ActualThemeVariant Property
- RequestedThemeVariant Property
- Defining and referencing custom variant specific resources
- ActualThemeVariant Property
- RequestedThemeVariant Property
`ActualThemeVariant` `RequestedThemeVariant`
# How To Use Resources | Avalonia Docs
- How-To Guides
- Styles and Resources
- How To Use Resources
## 👉 How To Use Resources
You will often need to standardise graphical fundamentals such as (but not limited to) brushes and colors in your applications. You can define these as resources at various levels in your Avalonia UI application, as well as in files that can be included as required.
Resources are always defined inside a resource dictionary. This means that each resource has a key attribute.
The level of a resource dictionary defines the scope of the resources in it: resources are available in the file where they are defined, and below. So you can tailor the scope of resources by choosing where to locate a resource dictionary.
### Declaring Resources​
For example, you may want brush colors to be standardized across the whole application. In this case you can declare a resource dictionary in the application XAML App.axaml file, like this
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.App"> <Application.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </Application.Resources></Application>
```
Alternatively, you may want a set of resources to apply only to a specific window or user control. In this case you will define a resource dictionary in the window or user control file. For example:
```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.MyUserControl"> <UserControl.Resources>  <SolidColorBrush x:Key="Warning">LightYellow</SolidColorBrush> </UserControl.Resources></UserControl>
```
In fact you can define resources at control level if required:
```bash
<Window xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.MainWindow"> <StackPanel>  <StackPanel.Resources>   <SolidColorBrush x:Key="Warning">PaleGoldenRod</SolidColorBrush>  </StackPanel.Resources> </StackPanel></Window>
```
You can also declare resources to be specific to a style.
```bash
<Style Selector="TextBlock.warning"> <Style.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </Style.Resources> <Setter ... /></Style>
```
Keep in mind, this resource is not visible outside of the this specific style block, meaning it won't make every TextBlock with a "warning" class aware of this resource outside of the Style block.
It is also possible to define resources for specific theme variants: Dark, Light or custom. From the example below, BackgroundBrush and ForegroundBrush will have different values depending on the current theme variant set by the system or application. For more information about theme variants please read Theme Variants page.
`BackgroundBrush` `ForegroundBrush` ```bash
<ResourceDictionary>  <ResourceDictionary.ThemeDictionaries>    <ResourceDictionary x:Key='Light'>      <SolidColorBrush x:Key='BackgroundBrush'>White</SolidColorBrush>      <SolidColorBrush x:Key='ForegroundBrush'>Black</SolidColorBrush>    </ResourceDictionary>    <ResourceDictionary x:Key='Dark'>      <SolidColorBrush x:Key='BackgroundBrush'>Black</SolidColorBrush>      <SolidColorBrush x:Key='ForegroundBrush'>White</SolidColorBrush>    </ResourceDictionary>  </ResourceDictionary.ThemeDictionaries></ResourceDictionary>
```
### Resource Dictionary Files​
You can improve the organisation of your Avalonia UI application project by defining resource dictionaries in their own files. This makes resource definitions easy to locate and maintain.
Resources located in a resource dictionary file are accessible to the entire application.
To add a resource dictionary file, follow this procedure:
- Right-click your project at the location where you want the new file created.
- Click Add, then New Item.
- Click Avalonia in the list on the left:
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (8) (1) (2).png)
- Click Resource Dictionary (Avalonia).
- Type the file name you want to use.
- Click Add.
After the resource file is created you have to correctly include it into your application. See Include and Merge Resources section.
You can now add the resources you want to define in the position indicated. It looks like this:
```bash
<ResourceDictionary xmlns="https://github.com/avaloniaui"          xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <!-- Add Resources Here --></ResourceDictionary>
```
### Using Resources​
You can use a resource from a resources dictionary that is in scope using the {DynamicResource} mark-up extension.
`{DynamicResource}` For example, to use a resource directly on the background attribute of a border element, use the following XAML :
```bash
<Border Background="{DynamicResource Warning}"> Look out!</Border>
```
#### Static Resource​
Alternatively you can choose to use the StaticResource mark-up extension. For example:
`StaticResource` ```bash
<Border Background="{StaticResource Warning}"> Look out!</Border>
```
A static resource is different in that it will not respond to changes in the resource made in code (at runtime). Once loaded a static cannot be altered.
The benefit of using a static resource is that it has less work to do so it will be slightly faster to load, and it uses slightly less memory.
### Resource Priority​
Avalonia UI resolves what resource to use by searching upwards in the logical control tree from the level of a DynamicResource or StaticResource mark-up, looking for the resource key.
`DynamicResource` `StaticResource` This means that resources with the same key have priority based on their proximity to the resource mark-up being resolved. Resource definitions further up the logical control tree are therefore effectively 'overridden' by those that are closer. For example, consider this XAML:
```bash
<UserControl ... > <UserControl.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </UserControl.Resources> <StackPanel>  <StackPanel.Resources>   <SolidColorBrush x:Key="Warning">Orange</SolidColorBrush>  </StackPanel.Resources>  <Border Background="{DynamicResource Warning}">   Look out!  </Border> </StackPanel></UserControl>
```
Here the border control is using the resource with the key 'Warning'. This is defined twice - once at the level of the enclosing stack panel, and again at user control level. Avalonia UI will determine that the border background should be be orange because its parent stack panel is first in a search upwards in the logical control tree from the border itself.
### Include and Merge Resources​
Resources can be included from a resource dictionary file, and merged with the resources defined in another file (even if there are not any).
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (1) (4).png)
In case, if you would like to merge resource dictionary on the whole application level, you have to declare a resource dictionary in the in the Application.Resources section of application XAML App.axaml file, like this
```bash
<Application.Resources> <ResourceDictionary>  <ResourceDictionary.MergedDictionaries>   <MergeResourceInclude Source="/Assets/AppResources.axaml" />  </ResourceDictionary.MergedDictionaries> </ResourceDictionary></Application.Resources>
```
You can also merge resource dictionary to declare merged resources to be specific to a style.
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (1) (3).png)
This means that you can implement styles in one file, and use resources defined in another. This keeps your styling consistent, and your application solution well organised and easy to maintain.
To include the resources dictionary from a file in a styles file, add the following XAML:
```bash
<Styles.Resources>  <ResourceDictionary>   <ResourceDictionary.MergedDictionaries>    <ResourceInclude Source="/Assets/AppResources.axaml"/>   </ResourceDictionary.MergedDictionaries>  </ResourceDictionary> </Styles.Resources>
```
In the above examples, the resources file AppResources.axaml is located in the /Assets project folder. You can then define the styles using the resources, for example:
`AppResources.axaml` `/Assets` ```bash
<Style Selector="Button.btn-info">  <Setter Property="Background" Value="{StaticResource InfoColor}"/></Style>
```
Where the resource InfoColor is defined as a SolidColorBrush in the imported file.
`InfoColor` `SolidColorBrush` Note that the resource has been referenced using StaticResource because it must not change - the requirement here is to keep the styling consistent.
`StaticResource` ### Merged Resources Priority​
As you saw previously, resources are resolved by searching up the logical control tree from the point of mark-up until a resource with the requested key is found.
However the presence of styles and merged dictionaries defined at the various levels of an application, introduces extra priority rules as follows:
- Control resources -> Merged dictionaries
- Style resources -> Merged dictionaries
- App resources -> Merged dictionaries
For example, in the theoretical application below, the search for a resource used on the border control (at the bottom) will follow the order indicated in square [] brackets:
`[]` ```bash
Application |- Resources [11]   |- Merged dictionary [12]   |- Merged dictionary [13] |- Styles   |- Resources [14]     |- Merged dictionary [15]     |- Merged dictionary [16]Window |- Resources [6]   |- Merged dictionary [7] |- Styles   |- Resources [8]     |- Merged dictionary [9]     |- Merged dictionary [10] |- StackPanel   |- Resources [1]     |- Merged dictionary [2]     |- Merged dictionary [3]   |- Styles     |- Resources [4]       |- Merged dictionary [5]   |- Border
```
Starting at the border, the first resources searched are any defined in the parent (stack panel) control. After that any merged dictionaries at the same level are considered - in the sequence that they appear in the XAML.
The search then moves on to search any styles defined in the parent (stack panel) control, followed by any merged dictionaries at that level.
The search moves upwards in the logical control tree, behaving at each level in a similar manner. It finally reaches application-level resources and styles.
### Consuming Resources from code​
Avalonia provides different options to access Resources from code.
ResourceNode in the below samples can be any node that supports Resource, like Application.Current, Window, UserControl, ...
`ResourceNode` `Resource` `Application.Current` `Window` `UserControl` - ResourceNode.Resources["TheKey"]: This will directly access the underlying Dictionary. Be aware: Merged Dictionaries and parents will not be scanned.
- ResourceNode.TryGetResource: This function will try to get a specific resource and return true if successful, otherwise false. Merged dictionaries will be scanned, but it will not follow the logical tree.
- ResourceNode.TryFindResource:  This extension method will try to get a specific resource and return true if successful, otherwise false. Merged dictionaries and the logical tree will be scanned as well.
- ResourceNode.GetResourceObservable: This will return an IObservable which can be used to observe changes on the resource. For example you could bind to it.
`Dictionary` `true` `false` `true` `false` `IObservable` ```bash
// In this sample we have defined the resource in App.axaml and we want to look up the value in the MainWindow constructor.////  </Application.Resources>//     <x:String x:Key="TheKey">HelloWorld</x:String>//  </Application.Resources>public MainWindow(){  InitializeComponent();  // found1 = false | result1 = null  var found1 = this.TryGetResource("TheKey", this.ActualThemeVariant, out var result1);  // found2 = true | result2 = "Hello World"   var found2 = this.TryFindResource("TheKey", this.ActualThemeVariant, out var result2);  // Bind the resource to a TextBlock from code behind  myTextBlock.Bind(TextBlock.TextProperty, Resources.GetResourceObservable("TheKey"));  // This will update myTextBlock.Text via the bound observable  this.Resources["TheKey"] = "Hello from code behind"; }
```
- Declaring Resources
- Resource Dictionary Files
- Using ResourcesStatic Resource
- Static Resource
- Resource Priority
- Include and Merge Resources
- Merged Resources Priority
- Consuming Resources from code
- Static Resource
# How to Use Included Styles | Avalonia Docs
- How-To Guides
- Styles and Resources
- How to Use Included Styles
## How to Use Included Styles
This guide shows you how to share styles from a separate styles file (that is included in your application). This approach allows you to share styles across multiple applications.
To do this, you define styles in a new XAML file. Here, the root element must then be either a Style or Styles element. For example:
`Style` `Styles` ```bash
<Styles xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <Style Selector="TextBlock.h1">    <Setter Property="FontSize" Value="24"/>    <Setter Property="FontWeight" Value="Bold"/>  </Style></Styles>
```
The Avalonia UI solution templates provide a quick way of adding a styles file to your project. Follow this procedure:
- In the Solution Explorer, right-click your project.
- Click Add and New Item
- From the Avalonia Items, click Styles (Avalonia)
- Type a name for your styles file
To use the styles defined in a separate file, you must reference it using a StyleInclude element. The source attribute defines the location of the styles file. You can choose the level at which to add this element.
`StyleInclude` For example, to use styles defined in a file AppStyles.axaml (saved in the folder /Styles), you could write a a StyleInclude element in the window like this:
`AppStyles.axaml` `/Styles` `StyleInclude` ```bash
<Window ... >  <Window.Styles>    <StyleInclude Source="/Styles/AppStyles.axaml" />  </Window.Styles>  <StackPanel>    <TextBlock Classes="h1">Heading 1</TextBlock>    <TextBlock>This is not a heading and will not be changed.</TextBlock>  </StackPanel></Window>
```
However, it is more common to reference a styles file in the App.axaml file like this:
`App.axaml` ```bash
<Application... >   <Application.Styles>    <FluentTheme Mode="Light"/>    <StyleInclude Source="/AppStyles.axaml"/>  </Application.Styles></Application>
```
This will allow you to use the styles from the separate file throughout your application.
You can also include styles from a another assembly by using the avares:// prefix:
`avares://` ```bash
<Application... >   <Application.Styles>    <FluentTheme Mode="Light"/>    <StyleInclude Source="avares://MyApp.Shared/Styles/CommonAppStyles.axaml"/>  </Application.Styles></Application>
```
will reference the /Styles/CommonAppStyles.axaml file from the MyApp.Shared project.
`/Styles/CommonAppStyles.axaml` `MyApp.Shared`
# Setter Precedence | Avalonia Docs
- How-To Guides
- Styles and Resources
- Setter Precedence
## Setter Precedence
Avalonia Setters are applied in order of BindingPriority, then visual tree locality, and finally the Styles collection order. Precedence applies individually to each StyledProperty so that styling can benefit from composition. DirectProperty and CLR properties cannot be styled and therefore do not participate in this precedence.
`Setters` `BindingPriority` `Styles` `StyledProperty` `DirectProperty` ### BindingPriority Values​
```bash
Animation = -1, // Highest priorityLocalValue = 0,StyleTrigger,Template,Style,Inherited,Unset = int.MaxValue, // Lowest priority
```
### How is BindingPriority Assigned Within XAML?​
BindingPriority cannot be explicitly set in XAML. The following examples demonstrate how BindingPriority is implicitly assigned across each scenario. This is crucial for designing and troubleshooting styles that work as expected.
`BindingPriority` `BindingPriority` #### Animation​
Animation has the highest BindingPriority and is applied to Setters within a Keyframe and generally throughout the Transitions system.
`Animation` `BindingPriority` `Setter` `Keyframe` ```bash
<Button Background="Green" Content="Bounces from Red to Blue">  <Button.Styles>    <Style Selector="Button">      <Style.Animations>        <Animation IterationCount="Infinite" Duration="0:0:2">          <KeyFrame Cue="0%">            <Setter Property="Background" Value="Red" />          </KeyFrame>          <KeyFrame Cue="100%">            <Setter Property="Background" Value="Blue" />          </KeyFrame>        </Animation>      </Style.Animations>    </Style>  </Button.Styles></Button>
```
#### LocalValue​
Assigned when a XAML property is directly set outside of a ControlTemplate. Both Background Setters below will have LocalValue priority.
`ControlTemplate` `Background` `Setter` `LocalValue` ```bash
<Button Background="Orange" /><Button Background="{DynamicResource ButtonBrush}" />
```
Resource markup extensions do not have any effect on priority.
#### StyleTrigger​
When a Selector has conditional activation, the Setter's BindingPriority is promoted from Style to StyleTrigger. Two selectors with any conditional activation will have equal priority regardless of the number of activators present and the position of the activator within the selector syntax. Avalonia doesn't have CSS's concept of Specificity.
`Selector` `Setter` `BindingPriority` `Style` `StyleTrigger` ```bash
<Style Selector="Button:pointerover /template/ ContentPresenter#PART_ContentPresenter">  <Setter Property="Background" Value="Orange" /></Style>
```
Style class, pseudo class, child position, and property match selectors are conditional. Control name selectors are not conditional.
#### Template​
When a property is directly set within a ControlTemplate. BorderThickness, Background, and Padding below have Template priority.
`ControlTemplate` `BorderThickness` `Background` `Padding` `Template` ```bash
<ControlTemplate>  <Border BorderThickness="2">    <Button Background="{DynamicResource ButtonBrush}" Padding="{TemplateBinding Padding}" />  </Border></ControlTemplate>
```
#### Style​
When a Setter is defined within a Style without conditional activation.
`Setter` `Style` ```bash
<Style Selector="Button /template/ ContentPresenter#PART_ContentPresenter">  <Setter Property="Background" Value="Orange" /></Style>
```
Especially noteworthy is the lower priority than Template. Therefore, these selectors cannot be used to override the properties mentioned in the Template example above.
`Template` `Template` #### Inherited​
When a property is not set, it may inherit the property value from its parent. This must be specified during property registration or with OverrideMetadata.
`OverrideMetadata` ```bash
public static readonly StyledProperty<bool> UseLayoutRoundingProperty =  AvaloniaProperty.Register<Layoutable, bool>(    nameof(UseLayoutRounding),    defaultValue: true,    inherits: true);
```
### Visual Tree Locality​
Setters with equal BindingPriority are then selected by their location in the Visual Tree relative to the Control. The Setter with the fewest nodes required to traverse upwards to locate will take precedence. Inline style Setters have the highest precedence for this step.
`Setter` `BindingPriority` `Control` `Setter` `Setter` ```bash
<Window>  <Window.Styles>    <Style Selector="Button">      <Setter Property="FontSize" Value="16" />      <Setter Property="Foreground" Value="Red" />    </Style>  </Window.Styles>  <StackPanel>    <StackPanel.Styles>      <Style Selector="Button">        <Setter Property="FontSize" Value="24" />      </Style>    </StackPanel.Styles>    <Button Content="This Has FontSize=24 with Foreground=Red" />  </StackPanel></Window>
```
### Styles Collection Order​
When BindingPriority and visual tree locality are both equal, the final decider is the order within the Styles collection. The last applicable Setter will take precedence.
`BindingPriority` `Styles` `Setter` ```bash
<StackPanel>  <StackPanel.Styles>    <Style Selector="Button.small">      <Setter Property="FontSize" Value="12" />    </Style>    <Style Selector="Button.big">      <Setter Property="FontSize" Value="24" />    </Style>  </StackPanel.Styles>  <Button Classes="small big" Content="This Has FontSize=24" />  <Button Classes="big small" Content="This Also Has FontSize=24" /></StackPanel>
```
These Buttons specify their Classes in different order, but that has no effect on Setter Precedence.
### BindingPriority Does Not Propagate​
Recall the Animation example above. If you hover, the animated background is replaced with a static background despite BindingPriority.Animation having the highest priority. This is because the Selector targets the wrong Control. Examining the ControlTheme is necessary to diagnose the cause.
`Animation` `BindingPriority.Animation` `Selector` `Control` `ControlTheme` ![](https://docs.avaloniaui.net/assets/images/setter-precedence-animation-wrong-1ad4a33c4e9807cb5dd613309246f201.gif)
```bash
<ControlTheme x:Key="{x:Type Button}" TargetType="Button">  <Setter Property="Background" Value="{DynamicResource ButtonBackground}"/>  <Setter Property="Template">    <ControlTemplate>      <ContentPresenter x:Name="PART_ContentPresenter"               Background="{TemplateBinding Background}"/>    </ControlTemplate>  </Setter>  <Style Selector="^:pointerover /template/ ContentPresenter#PART_ContentPresenter">    <Setter Property="Background" Value="{DynamicResource ButtonBackgroundPointerOver}"/>  </Style></ControlTheme>
```
The top Setter applies the ButtonBackground to the Button with Style priority. The Background rendering is handled by the ContentPresenter which has a Template priority. It fetches the ButtonBackground which has been applied to Button.
`Setter` `ButtonBackground` `Button` `Style` `Background` `ContentPresenter` `Template` `ButtonBackground` `Button` However, when the Button is hovered, the :pointerover Selector is activated with its StyleTrigger priority, overrides the TemplateBinding, and fetches ButtonBackgroundPointerOver instead. This circumvents fetching the Button's Background that our original Animation Selector targeted. This is summarized in the following table:
`Button` `:pointerover` `Selector` `StyleTrigger` `TemplateBinding` `ButtonBackgroundPointerOver` `Button` `Background` `Animation` `Selector` `<ContentPresenter Background="{TemplateBinding Background}"/>` `^:pointerover /template/ ContentPresenter#PART_ContentPresenter` Instead, we should target the ContentPresenter with a Setter that has priority of at least StyleTrigger. BindingPriority.Animation fits that. This is an observation that cannot be made without examining the original ControlTemplate and emphasizes that relying on priority alone is insufficient to effectively style an application.
`ContentPresenter` `Setter` `StyleTrigger` `BindingPriority.Animation` `ControlTemplate` ```bash
<Button Background="Green" Content="Bounces from Red to Blue">  <Button.Styles>    <Style Selector="Button /template/ ContentPresenter#PART_ContentPresenter">      <Style.Animations>        <Animation IterationCount="Infinite" Duration="0:0:2">          <KeyFrame Cue="0%">            <Setter Property="Background" Value="Red" />          </KeyFrame>          <KeyFrame Cue="100%">            <Setter Property="Background" Value="Blue" />          </KeyFrame>        </Animation>      </Style.Animations>    </Style>  </Button.Styles></Button>
```
![](https://docs.avaloniaui.net/assets/images/setter-precedence-animation-correct-af3510217340cc2be4be339bcf9530bb.gif)
- BindingPriority Values
- How is BindingPriority Assigned Within XAML?AnimationLocalValueStyleTriggerTemplateStyleInherited
- Animation
- LocalValue
- StyleTrigger
- Template
- Style
- Inherited
- Visual Tree Locality
- Styles Collection Order
- BindingPriority Does Not Propagate
- Animation
- LocalValue
- StyleTrigger
- Template
- Style
- Inherited
# Property Setters | Avalonia Docs
- How-To Guides
- Styles and Resources
- Property Setters
## Property Setters
The setters in a style define what properties will be changed after Avalonia UI has matched the control in the logical control tree using the selector, and determined which style is to be used. Setters are simple property and value attribute pairs in the XAML, written in the format:
```bash
<Setter Property="propertyName" Value="newValueString"/>
```
For example:
```bash
<Setter Property="FontSize" Value="24"/><Setter Property="Padding" Value="4 2 0 4"/>
```
You can also use a long-form syntax to set a control property to an object with several properties set, like this:
```bash
<Setter Property="MyProperty">  <MyObject Property1="My Value" Property2="999"/></Setter>
```
A style can also set properties using bindings. After the usual selection process, this causes Avalonia UI to use a value from data context of the target control. For example, the setter can be defined like this:
```bash
<Setter Property="FontSize" Value="{Binding SelectedFontSize}"/>
```
### Style Priority​
There are two rules that govern which property setter has precedence when a selector matches multiple styles:
- Position of the enclosing styles collection in the application - 'closest' has priority.
- Position of the style in the located styles collection - 'latest' has priority.
For example, firstly this means that styles defined at window level will override those defined at application level. Secondly, this means that where the selected style collections are at the same level, then the later definition (as written in the file) has priority.
If you were comparing style classes to CSS you must note that: unlike CSS, the list sequence of class names in the Classes attribute has no effect on setter priority in Avalonia UI. That is, if both these style classes set the color, then either way of listing the classes has the same result:
`Classes` ```bash
<Button Classes="h1 blue"/><Button Classes="blue h1"/>
```
### Value Reversion​
Whenever a style is matched with a control, all of the setters will be applied to the control. If a style selector causes the style to no longer match a control, the property value will revert to the its next highest priority value.
### Mutable Values​
Note that the Setter creates a single instance of Value which will be applied to all controls that the style matches: if the object is mutable then changes will be reflected on all controls.
`Setter` `Value` Also note that bindings on an object defined in a setter value will not have access to the target control's data context. This is because there may be multiple target controls. This scenario may arise with a style defined like this:
```bash
<Style Selector="local|MyControl"> <Setter Property="MyProperty">   <MyObject Property1="{Binding MyViewModelProperty}"/> </Setter></Style>
```
This means that in the example above, the binding source for the setter will be MyObject.DataContext, and not MyControl.DataContext. Also if MyObject has no data context then the binding will unable to produce a value.
`MyObject.DataContext` `MyControl.DataContext` `MyObject` Note: if you are using compiled bindings, you need to explicitly set the data type of the binding source in the <Style> element:
`<Style>` ```bash
<Style Selector="MyControl" x:DataType="MyViewModelClass"> <Setter Property="ControlProperty" Value="{Binding MyViewModelProperty}" /></Style>
```
For more information about compiled bindings, see here. --> TO DO
### Setter Data Templates​
As previously described here, when you use a setter without a data template, a single instance of the setter value is created and shared across all matching controls. To change the value depending on a data template, you place the target control inside a template element, like this:
```bash
<Style Selector="Border.empty"> <Setter Property="Child">  <Template>   <TextBlock>No content available.</TextBlock>  </Template> </Setter></Style>
```
For information about the concepts behind a data template, see here.
- Style Priority
- Value Reversion
- Mutable Values
- Setter Data Templates
# Style Selectors | Avalonia Docs
- How-To Guides
- Styles and Resources
- Style Selectors
## Style Selectors
Avalonia UI uses style selectors to match controls using a custom XAML syntax.
If you are familiar with the CSS (Cascading Style Sheets) technology, then you will recognise this syntax as being very similar.
Here is a list of some example style selectors:
`Button` `Button` `Button.red` `Button` `red` `Button.red.large` `Button` `red` `large` `Button:focus` `Button` `:focus` `Button.red:focus` `Button` `red` `:focus` `Button#myButton` `Button` `Name` `"myButton"` `StackPanel Button.xl` `Button` `xl` `StackPanel` `StackPanel > Button.xl` `Button` `xl` `StackPanel` `Button /template/ ContentPresenter` `ContentPresenter` `Button` For a full description of these style selector formats, and more, see the reference here.
# Style Selector Syntax | Avalonia Docs
- Reference
- Styles
- Style Selector Syntax
## Style Selector Syntax
This page lists the XAML syntax for style selectors with the C# code methods that perform the same selection.
### By Control Class​
```bash
<Style Selector="Button"><Style Selector="local|Button">
```
```bash
new Style(x => x.OfType<Button>());new Style(x => x.OfType(typeof(Button)));
```
Selects a control by its class name.
The first example above selects the Avalonia.Controls.Button class. To include a XAML namespace in the type separate the namespace and the type with a | character.
`Avalonia.Controls.Button` `|` This selector does not match derived types. For that, use the :is selector, see below.
`:is` Note the type of an object is actually determined by looking at its StyleKey property. By default this simply returns the type of the current instance, but if, for example, you do want your control which inherits from Button to be styled as a Button, then you can override the StyleKeyOverride property on your class to return typeof(Button).
`StyleKey` `Button` `Button` `StyleKeyOverride` `typeof(Button)` ### By Name​
```bash
<Style Selector="#myButton"><Style Selector="Button#myButton">
```
```bash
new Style(x => x.Name("myButton"));new Style(x => x.OfType<Button>().Name("myButton"));
```
Selects a control by its Name attribute, with an added # (hash) character prefix.
`Name` `#` ### By Style Class​
```bash
<Style Selector="Button.large"><Style Selector="Button.large.red">
```
```bash
new Style(x => x.OfType<Button>().Class("large"));new Style(x => x.OfType<Button>().Class("large").Class("red"));
```
Selects a control with the specified style class or classes. Multiple classes are separated with a full stop. If multiple classes are specified in the selector, then the control must have all of the requested classes defined for a match.
### By Pseudo Class​
```bash
<Style Selector="Button:focus"><Style Selector="Button:focus:pointerover"><Style Selector="Button.large:focus">
```
```bash
new Style(x => x.OfType<Button>().Class(":focus"));new Style(x => x.OfType<Button>().Class(":focus").Class(":pointerover"));new Style(x => x.OfType<Button>().Class("large").Class(":focus"));
```
Selects a control using its current pseudo class. The colon character defines the start of the pseudo class name in the selector. Multiple pseudo classes may be applied to the same Control.
For more detail about pseudo classes, see the reference here.
### Include Derived Classes​
```bash
<Style Selector=":is(Button)"><Style Selector=":is(local|Button)">
```
```bash
new Style(x => x.Is<Button>());new Style(x => x.Is(typeof(Button)));
```
This is very similar to the style class selector except it also matches derived types.
Technical detail: during the matching process, Avalonia UI determines the type of a control by examining its StyleKey property.
`StyleKey` Interestingly, this allows you to write very general class-based selectors. As controls are all derived from the class Control, a selector that only selects on the style class margin2 can be written:
`Control` `margin2` ```bash
<Style Selector=":is(Control).margin2"><Style Selector=":is(local|Control.margin2)">
```
```bash
new Style(x => x.Is<Control>().Class("margin2"));new Style(x => x.Is(typeof(Control)).Class("margin2"));
```
### Child Operator​
```bash
<Style Selector="StackPanel > Button">
```
```bash
new Style(x => x.OfType<StackPanel>().Child().OfType<Button>());
```
A child selector is defined by separating two selectors with a > character. This selector matches only direct children in the logical controls tree.
`>` For the concept behind the logical controls tree, see here.
For example, applying the above selector to this XAML:
```bash
<StackPanel>  <Button>Save</Button>  <DockPanel Width="300" Height="300">    <Button DockPanel.Dock="Top">Top</Button>    <TextBlock>Some text</TextBlock>  </DockPanel></StackPanel>
```
The selector will match the first button, but not the second. This is because the second button is not a direct child of the stack panel (it is inside the dock panel as well).
### Any Descendant Operator​
```bash
<Style Selector="StackPanel Button">
```
```bash
new Style(x => x.OfType<StackPanel>().Descendant().OfType<Button>());
```
When two selectors are separated by a space, then the selector will match any descendants in the logical tree. The parent is on the left, and the descendant is on the right.
Therefore applying the above selector to the previous XAML sample, both buttons will be selected.
### By Property Match​
```bash
<Style Selector="Button[IsDefault=true]">
```
```bash
new Style(x => x.OfType<Button>().PropertyEquals(Button.IsDefaultProperty, true));
```
You can refine a selector so that it includes the value of a property. The property=value pair is defined inside square brackets. This matches any control that has the specified property set to the specified value.
```bash
<StackPanel Orientation="Horizontal">  <Button IsDefault="True">Save</Button>  <Button>Cancel</Button>  </StackPanel>
```
For example, in the XAML above, the first button will be selected, but not the second button.
Note: when you use an attached property as a property match, the property name must be wrapped in parentheses. For example:
```bash
<Style Selector="TextBlock[(Grid.Row)=0]">
```
Further note: when you use a property match, the property type must support the component model type converter, TypeConverter class. For more information see the Microsoft documentation here.
`TypeConverter` ### By Template​
```bash
<Style Selector="Button /template/ ContentPresenter">
```
```bash
new Style(x => x.OfType<Button>().Template().OfType<ContentPresenter>());
```
You can match a control in a control template using the above syntax. All the other selectors listed here work on the logical tree, but this selector can step into a template.
In the example above, if a button has a template, then the selector matches selects content presenter controls (class ContentPresenter) inside the template.
`ContentPresenter` ### Not Function​
```bash
<Style Selector="TextBlock:not(.h1)">
```
```bash
new Style(x => x.OfType<TextBlock>().Not(y => y.Class("h1")));
```
This function negates the selection in the brackets. In the example above all the text block controls that do not have the h1 class will be matched.
`h1` ### By List​
```bash
<Style Selector="TextBlock, Button">
```
```bash
new Style(x => Selectors.Or(x.OfType<TextBlock>(), x.OfType<Button>()))
```
You can select any element that matches a comma-separated list of selectors. Any setters in the style must change properties that are common to all the items.
### By Child Position Formula​
```bash
<Style Selector="TextBlock:nth-child(2n+3)">
```
```bash
new Style(x => x.OfType<TextBlock>().NthChild(2, 3));
```
You can match elements based on their position within a group of siblings. This is regardless of the class of the parent (container) control.
Selection is based on a simple formula in the style An + B so that A controls the step size and B the offset from the start. In the nth-child formula (above), n is supplied to the formula as zero and all positive integers starting at zero, and the match is made against the results of the formula compared with a one-based position of the child element.
`An + B` `A` `B` `n` So, for the above selector:
If the formula evaluates to less than 1 then it is ignored - there are never any child element with that index.
There is a corresponding selector with a formula that counts from the end of the group:
```bash
<Style Selector="TextBlock:nth-last-child(2n+3)">
```
```bash
new Style(x => x.OfType<TextBlock>().NthLastChild(2, 3));
```
#### Single child position​
You can omit the A and n from the formula in XAML to specify a single position only. For example, this selects only child number 3:
```bash
<Style Selector="TextBlock:nth-child(3)">
```
```bash
new Style(x => x.OfType<TextBlock>().NthChild(0, 3));
```
#### Keyword notation​
You can also use a keyword notation in place of the formula: odd or even. So these are selectors are equivalent:
`odd` `even` ```bash
<Style Selector="TextBlock:nth-child(2n)"><Style Selector="TextBlock:nth-child(even)">
```
```bash
<Style Selector="TextBlock:nth-child(2n+1)"><Style Selector="TextBlock:nth-child(odd)">
```
#### Other Formula Examples​
This table lists some examples of selection by child position:
`:nth-child(odd)` `:nth-child(even)` `:nth-child(2n+1)` `:nth-child(odd)` `:nth-child(2n)` `:nth-child(even)` `:nth-child(7)` `:nth-child(n+7)` `:nth-child(3n+4)` `:nth-child(-n+3)` #### Online Child Position Tester​
Although this is a CSS site, it will work for Avalonia UI child position selectors because the rules are the same.
You can use this site to test your child position selector: https://css-tricks.com/examples/nth-child-tester/
### Nesting​
```bash
<Style Selector="TextBlock">  <Setter Property="FontSize" Value="24"/>    <!-- Effectively "TextBlock:pointerover" -->  <Style Selector="^:pointerover">    <Setter Property="FontWeight" Value="Bold"/>  </Style></Style>
```
```bash
new Style(x => x.OfType<TextBlock>()){  Setters = { new Setter(TextBlock.FontSizeProperty, 24d) },  Children =  {    new Style(x => x.Nesting().Class(":pointerover"))    {      Setters = { new Setter(TextBlock.FontWeightProperty, FontWeight.Bold) }    }  }};
```
- By Control Class
- By Name
- By Style Class
- By Pseudo Class
- Include Derived Classes
- Child Operator
- Any Descendant Operator
- By Property Match
- By Template
- Not Function
- By List
- By Child Position FormulaSingle child positionKeyword notationOther Formula ExamplesOnline Child Position Tester
- Single child position
- Keyword notation
- Other Formula Examples
- Online Child Position Tester
- Nesting
- Single child position
- Keyword notation
- Other Formula Examples
- Online Child Position Tester
# Styles | Avalonia Docs
- Reference
- Styles
## Styles
Welcome to the Avalonia UI styles reference section. This contains information about:
- Style selector formats
- Pseudo classes
To review the concepts behind the Avalonia UI styling system, see here.
# JetBrains Rider Setup | Avalonia Docs
- Reference
- JetBrains Rider IDE
- JetBrains Rider Setup
## JetBrains Rider Setup
To set up JetBrains Rider for developing with Avalonia UI, follow this procedure:
- Download and install the .NET SDK of your choice from Microsoft. This contains the runtime, development kit (compiler, etc) that is used to build Avalonia UI applications.
- Install the Avalonia UI templates by running the command dotnet new install Avalonia.Templates from the command prompt on your machine.
`dotnet new install Avalonia.Templates` For the latest .NET SDK downloads, see here.
For SDK versions before .NET 7, you will need to run the command dotnet new -i Avalonia.Templates
`dotnet new -i Avalonia.Templates` The output will look similar to this.
```bash
$ dotnet new install Avalonia.Templates Determining projects to restore... Restored /Users/danwalmsley/.templateengine/dotnetcli/v5.0.200/scratch/restore.csproj (in 706 ms).Templates                   Short Name      Language  Tags.....Avalonia Resource Dictionary         avalonia.resource         ui/xaml/avalonia/avaloniauiAvalonia Styles                avalonia.styles          ui/xaml/avalonia/avaloniauiExamples:  dotnet new mvc --auth Individual  dotnet new mstest  dotnet new --help  dotnet new avalonia.mvvm --help$
```
To download JetBrains Rider, see here.
Rider will give you the very best development experience available for Avalonia UI. It is available for Windows, Linux, and macOS. Rider supports XAML out of the box. However, if you want to use the XAML previewer, you will need the Avalonia plugin.
### Install the Avalonia Plugin​
Once Rider loads you will see the Welcome to JetBrains Rider screen.
- Click Configure, and then click Plugins on the dropdown menu.
![](https://docs.avaloniaui.net/assets/images/rider-welcome-d215be7385c991eb68d4534a060fbd3b.png)
The Preferences screen will open.
- Click Marketplace enter 'Avalonia' in the search. Click AvaloniaRider when it appears in the search results pane, then click Install.
![](https://docs.avaloniaui.net/assets/images/rider-install-avalonia-plugin-08a069628f8ab34c88d0849f695b595a.png)
- After the installation has completed, click Restart IDE (button appears).
Now JetBrains Rider is ready to develop Avalonia UI applications.
- Install the Avalonia Plugin
# JetBrains Rider IDE | Avalonia Docs
- Reference
- JetBrains Rider IDE
## JetBrains Rider IDE
The JetBrains Rider IDE has built-in support for Avalonia UI XAML starting in 2020.3 including first-class support for Avalonia-specific XAML features and custom code inspections.
For more information about the JetBrains Rider IDE, see the website https://www.jetbrains.com/rider.
For the JetBrains Rider 2020.3 release announcement, see here.
# Pseudoclasses | Avalonia Docs
- Reference
- Styles
- Pseudoclasses
## Pseudoclasses
### Overview​
Pseudoclasses in Avalonia, similar to those in CSS, are keywords exposed by a Control that indicate a distinct control state in a convenient way for Style Selectors. These states are used to conditionally style controls. For example, a Button could have a different appearance while it's being pressed or a TextBox while it is disabled.
`Control` `Button` Pseudoclass state is tracked by the Control's PseudoClasses property. By convention, pseudoclass names begin with a :, such as :pointerover or :pressed.
`Control` `PseudoClasses` `:` `:pointerover` `:pressed` ### Selector Usage​
The following demonstrates how to apply Bold text to a CheckBox when it is checked:
`CheckBox` ```bash
<Window.Styles>  <Style Selector="CheckBox:checked">    <Setter Property="FontWeight" Value="Bold" />  </Style></Window.Styles><CheckBox Content="Pseudoselectors" />
```
A Control can have multiple pseudoclasses active and you can target multiple pseudoclasses with a Selector. For example:
`Control` ```bash
<Style Selector="Button.red:focus:pointerover">
```
The selector above targets Button controls with the red style class, and that have the :focus and the :pointerover pseudoclass state.
`Button` `:focus` `:pointerover` ### General Pseudoclasses​
These pseudoclasses are defined by InputElement and are accessible on every Control:
`InputElement` `Control` `:disabled` `:pointerover` `:focus` `:focus-within` `:focus-visible` ### Accessibility​
The PseudoClasses collection is a protected property. This accessibility blocks the external setting of existing and custom pseudoclasses via code-behind and attached behavior. As such, customizing must be implemented through inheritance.
`PseudoClasses` `protected` ### Custom Pseudoclass Example​
When creating a custom control, you can define custom pseudoclasses to expose control state. The [PseudoClasses] attribute provides information about your pseudoclass to the IDE. This behavior is inherited, so the custom control automatically benefits from pseudoclasses defined and managed by more primitive controls, such as InputElement's :pointerover.
`[PseudoClasses]` `InputElement` `:pointerover` The following example defines and sets pseudoclasses when the pointer is over different regions of a Button.
`Button` - C# Control
- Example XAML
- ControlTheme XAML
```bash
[PseudoClasses(":left", ":right", ":middle")]public class AreaButton : Button{    protected override void OnPointerMoved(PointerEventArgs e)  {    base.OnPointerMoved(e);    var pos = e.GetPosition(this);    if (pos.X < Bounds.Width * 0.25)      SetAreaPseudoclasses(true, false, false);    else if (pos.X > Bounds.Width * 0.75)      SetAreaPseudoclasses(false, true, false);    else      SetAreaPseudoclasses(false, false, true);  }  protected override void OnPointerExited(PointerEventArgs e)  {    base.OnPointerExited(e);    SetAreaPseudoclasses(false, false, false);  }  private void SetAreaPseudoclasses(bool left, bool right, bool middle)  {    PseudoClasses.Set(":left", left);    PseudoClasses.Set(":right", right);    PseudoClasses.Set(":middle", middle);  }}
```
```bash
<Window.Styles>  <Style Selector="local|AreaButton">    <Setter Property="Content" Value="Testing Area" />    <Setter Property="MinWidth" Value="200" />    <Style Selector="^:left">      <Setter Property="Content" Value="Left" />    </Style>    <Style Selector="^:right">      <Setter Property="Content" Value="Right" />    </Style>    <Style Selector="^:middle">      <Setter Property="Content" Value="Middle" />    </Style>  </Style></Window.Styles><local:AreaButton />
```
```bash
<ControlTheme  x:Key="{x:Type local:AreaButton}"  BasedOn="{StaticResource {x:Type Button}}"  TargetType="local:AreaButton" />
```
![](https://docs.avaloniaui.net/assets/images/custom-pseudoclass-1a43f78323816a718fef649b6367486d.gif)
StyleKeyOverride is used when creating simple, derived controls with the ControlTheme defined by their parent. In this case since Button is a TemplatedControl, creating a ControlTheme is necessary as the Selector must target AreaButton for the new pseudoclasses.
`StyleKeyOverride` `ControlTheme` `Button` `TemplatedControl` `ControlTheme` `AreaButton` - Overview
- Selector Usage
- General Pseudoclasses
- Accessibility
- Custom Pseudoclass Example
# FAQ | Avalonia Docs
- FAQ
## FAQ
### What is Avalonia?​
Avalonia is an open-source, cross-platform UI framework. It is the most popular cross-platform UI framework for .NET developers. It's designed for creating flexible and beautiful user interfaces. Avalonia supports a wide array of application development platforms, including Windows, Linux, macOS, iOS, Android and WebAssembly.
Built on a modern .NET stack, Avalonia allows developers to write in C# or any other .NET language, and to define UIs using the XAML markup language. Similar to WPF, Avalonia uses a XAML-based styling system, and its layout system and binding infrastructure model offer a familiar environment for developers experienced with XAML-based frameworks.
Avalonia stands out from many other UI frameworks as it doesn't rely on controls provided by the operating system. Instead, it draws the entire UI itself, which enables a high level of customization and a consistent experience across platforms.
### How is Avalonia different from other UI frameworks like WPF or Xamarin.Forms?​
Avalonia distinguishes itself from other UI frameworks such as WPF and Xamarin.Forms through several key aspects:
- Cross-platform by design: Unlike WPF, which is exclusive to Windows, Avalonia is designed from the ground up to be cross-platform. It supports Windows, Linux, macOS, iOS, Android, WebAssembly and more. It's capable of delivering a consistent look and feel across all these platforms.
- Independent rendering: While Xamarin.Forms relies on the native controls of the target platform for rendering, Avalonia has its own rendering engine. This means that it doesn't use the native UI controls of the operating system but instead draws the entire UI itself. This provides a high degree of flexibility and customization.
- Flexible styling: Avalonia uses a powerful styling system similar to WPF. It uses styles to define the appearance of your controls, and unlike Xamarin.Forms, these styles can be dynamically adjusted based on control state and inherited hierarchically.
- XAML and code-behind: Like WPF and Xamarin.Forms, Avalonia lets you define UIs using XAML, a markup language that many .NET developers are familiar with. You can also manipulate your UI directly in code, giving you the flexibility to choose the right approach for your application.
- Open source and community-driven: Avalonia is an open-source project with an active community contributing to its development. This means it's continually evolving and improving based on community feedback and needs.
Cross-platform by design: Unlike WPF, which is exclusive to Windows, Avalonia is designed from the ground up to be cross-platform. It supports Windows, Linux, macOS, iOS, Android, WebAssembly and more. It's capable of delivering a consistent look and feel across all these platforms.
Independent rendering: While Xamarin.Forms relies on the native controls of the target platform for rendering, Avalonia has its own rendering engine. This means that it doesn't use the native UI controls of the operating system but instead draws the entire UI itself. This provides a high degree of flexibility and customization.
Flexible styling: Avalonia uses a powerful styling system similar to WPF. It uses styles to define the appearance of your controls, and unlike Xamarin.Forms, these styles can be dynamically adjusted based on control state and inherited hierarchically.
XAML and code-behind: Like WPF and Xamarin.Forms, Avalonia lets you define UIs using XAML, a markup language that many .NET developers are familiar with. You can also manipulate your UI directly in code, giving you the flexibility to choose the right approach for your application.
Open source and community-driven: Avalonia is an open-source project with an active community contributing to its development. This means it's continually evolving and improving based on community feedback and needs.
### What versions of .NET can I use?​
- .NET Framework 4.6.2+
- .NET Core 2.0+
- .NET 5+ (including latest .NET 8)
### Can I use my existing knowledge of WPF or UWP to work with Avalonia?​
Yes, you certainly can! Avalonia is heavily influenced by WPF and UWP, and it leverages many of the same concepts, such as XAML for UI definition, data binding, and the MVVM (Model-View-ViewModel) design pattern. So, if you're already familiar with these technologies, you'll likely find Avalonia's learning curve quite gentle.
However, it's important to note that while Avalonia shares many similarities with WPF and UWP, it isn't a direct clone. Avalonia was designed to be cross-platform from the ground up, and as such, it has its own unique features and capabilities that are distinct from WPF and UWP. These differences could include the available controls, styling mechanism, platform-specific integrations, and so on.
Nevertheless, your existing knowledge of WPF or UWP will definitely give you a solid starting point for learning and working with Avalonia.
### Is Avalonia suitable for building complex desktop applications?​
Yes, Avalonia is indeed suitable for building complex desktop applications. It is designed to allow for the development of flexible and intricate user interfaces across a wide range of platforms, including Windows, macOS, Linux, iOS, Android, and WebAssembly.
Avalonia's powerful styling system, inspired by WPF and CSS, enables you to craft beautiful and unique user interfaces. Moreover, the use of data-binding and the MVVM architecture supports building scalable applications with well-structured, testable, and maintainable code.
In addition to this, Avalonia supports a multitude of other features important for complex desktop applications, such as multi-window support, popup layers, control templates, user controls, and more.
Whether you're developing a simple utility or a large-scale enterprise application, Avalonia offers the tools and flexibility you need to create robust, performant, and stunning applications.
### Can I code my UI instead of using XAML?​
Yes. You can code your entire UI with your preferred .NET language.
### Is there a drag and drop visual designer?​
We are working on bringing a full drag-and-drop designer experience to Avalonia in 2025. This designer will be part of Avalonia Accelerate, a paid offering designed to enhance developer productivity in the Avalonia ecosystem.
Avalonia Accelerate will help developers build applications more efficiently through visual design tools, complementing the existing XAML-first approach that Avalonia is known for.
### Does Avalonia support Hot Reload?​
You can use a community project to enable hot reload with Avalonia.
### Can Avalonia interop with native APIs?​
Yes. See our guide on using platform specific features.
### Can I cross-compile for different platforms?​
Yes. You can compile for macOS, Linux, Android and WebAssembly from Windows. You'll likely need to package your app on those platforms to create release packages of your app.
You will require a Mac to build iOS applications.
### Can I build a mobile app with Avalonia?​
Yes. You can develop for Android and iOS today. You should however give careful consideration to each platform and ensure that your app behaves well on smaller, touch focused devices.
### How can I get involved?​
Check out the community guide to see how you can get involved with the project.
### What platforms are supported?​
You also must know which platforms are supported by your .NET version. Often .NET will drop support for older OS versions, while Avalonia still can work with them. So you might need to hold on updating the SDK. For example, here is the list of supported OS versions by .NET 8.
#### Linux Distros​
- Debian 9+
- Ubuntu 16.04+
- Fedora 30+
Other distros might also work. The main limitation is .NET SDK support and availability of X11 system. Alternatively, framebuffer linux backend is also supported. Version with Wayland support is in preview and not yet released.
WSL 2 distros are supported as well, but libice6, libsm6 and libfontconfig1 dependencies must be installed individually.
`libice6` `libsm6` `libfontconfig1` Skia is built against glibc 2.17. If your distro uses something else instead, you need to build your own libSkiaSharp.so at SkiaSharp. You also can visit SkiaSharp home page for more information about supported versions.
#### What versions of Windows are supported?​
- Windows 8.1+
Avalonia also runs on Windows 7, but new platforms specific features won't be available there, and we do not provide bug fixes for this version anymore.
#### What versions of macOS are supported?​
- macOS 10.14+
Avalonia also runs on macOS 10.13, but we are in the process of migrating to the Metal GPU API, which is currently disabled by default. It is planned to be enabled during one of minor updates.
#### What versions of Android are supported?​
- Android 5.0+ (API 21)
.NET 7 is required for Android support.
#### What versions of iOS are supported?​
- iOS 13.0+
.NET 7 is required for iOS support.
#### What versions of Browser are supported?​
Any browser with full WebAssembly support technically should work - https://caniuse.com/wasm.
For the best performance and support we recommend latest Chrome or Safari versions.
.NET 7 is required for Browser support. Starting with 11.0.6 we recommend .NET 8.
### Credits​
- Portions of this documentation were adapted from Dotnet docs licensed under CC BY 4.0
- What is Avalonia?
- How is Avalonia different from other UI frameworks like WPF or Xamarin.Forms?
- What versions of .NET can I use?
- Can I use my existing knowledge of WPF or UWP to work with Avalonia?
- Is Avalonia suitable for building complex desktop applications?
- Can I code my UI instead of using XAML?
- Is there a drag and drop visual designer?
- Does Avalonia support Hot Reload?
- Can Avalonia interop with native APIs?
- Can I cross-compile for different platforms?
- Can I build a mobile app with Avalonia?
- How can I get involved?
- What platforms are supported?Linux DistrosWhat versions of Windows are supported?What versions of macOS are supported?What versions of Android are supported?What versions of iOS are supported?What versions of Browser are supported?
- Linux Distros
- What versions of Windows are supported?
- What versions of macOS are supported?
- What versions of Android are supported?
- What versions of iOS are supported?
- What versions of Browser are supported?
- Credits
- Linux Distros
- What versions of Windows are supported?
- What versions of macOS are supported?
- What versions of Android are supported?
- What versions of iOS are supported?
- What versions of Browser are supported?
# Dealing with Multiple Platforms | Avalonia Docs
- How-To Guides
- Building Cross Platform Applications
- Dealing with Multiple Platforms
## Dealing with Multiple Platforms
### Managing Platform Differences & Capabilities​
Platform differences aren't just an issue in cross-platform development; even devices within the same platform can possess diverse capabilities.
Most notably, this includes differences in screen size, but numerous other device characteristics may also vary, requiring the application to verify certain capabilities and adapt its behavior based on their presence (or absence). This is especially important when designing for cross paradigm situations, with desktop and mobile operating systems providing very different interaction models.
Therefore, all applications must be equipped to handle a graceful scaling back of functionality, or risk presenting a minimal feature set that does not leverage the full potential of the underlying platform.
#### Examples of Platform Divergence​
There are certain fundamental characteristics inherent to applications that are universally applicable. These are high-level concepts that hold true across all devices and platforms and can thus form the core of your application's design:
- A screen, which can display your application UI.
- Some form of input devices, typically touch for mobile and mouse and keyboard for desktop.
- Display views of data.
- Editing data.
- Navigation capabilities.
#### Platform-Specific features​
Beyond the universal application characteristics, you will also have to address key platform differences in your design. You may need to consider, and possibly write or tweak code specifically to handle, these differences:
- Screen Sizes: While some platforms (like iOS) have standardized screen sizes that are relatively easy to target, others, like Desktop and WebAssembly, enable an unlimited variety of screen dimensions which would require more effort to support in your application.
- Navigation Metaphors: These can vary across platforms (e.g., hardware 'back' button) and even within platforms (e.g., differences between Android 2 and 4, iPhone vs iPad).
- Keyboards: Some devices may come with physical keyboards, while others only feature a software keyboard. Code that detects when a soft-keyboard is obscuring part of the screen needs to be sensitive to these differences.
Screen Sizes: While some platforms (like iOS) have standardized screen sizes that are relatively easy to target, others, like Desktop and WebAssembly, enable an unlimited variety of screen dimensions which would require more effort to support in your application.
Navigation Metaphors: These can vary across platforms (e.g., hardware 'back' button) and even within platforms (e.g., differences between Android 2 and 4, iPhone vs iPad).
Keyboards: Some devices may come with physical keyboards, while others only feature a software keyboard. Code that detects when a soft-keyboard is obscuring part of the screen needs to be sensitive to these differences.
These platform-specific differences should be carefully considered when designing your Avalonia application to ensure a seamless user experience across all platforms. While you should strive to maximize your code reuse, you should also avoid attempting to reuse 100% of your code across all supported platforms. Instead, tailor each platform UIs to the feel at home on the device.
#### Dealing with Platform Divergence​
Supporting multiple platforms from the same code-base can be achieved through abstracting platform features or conditional code.
- Platform Abstraction: This approach leverages the Business Façade pattern to provide uniform access across platforms. It abstracts the unique platform implementations into a single, cohesive API. The primary advantage is the ability to write platform-agnostic code, enhancing code reusability and maintainability. However, this approach may not fully exploit the unique features and capabilities of each platform.
### Platform Abstraction​
In Avalonia, you can employ class abstractions to streamline your development process across different platforms. This can be achieved using interfaces or base classes defined in the shared code, then implemented or extended in platform-specific projects.
#### Interfaces​
The utilization of interfaces empowers you to create platform-specific classes that can be incorporated into your shared libraries for code reuse.
##### How it works​
The interface is defined within the shared code and passed into the shared library as a parameter or property. The platform-specific applications can then implement the interface, allowing shared code to process it effectively.
##### Advantages​
The main advantage of this approach is that the implementation can contain platform-specific code and even reference platform-specific external libraries, offering high flexibility.
##### Disadvantages​
A potential disadvantage is the need to create and pass implementations into the shared code. If the interface is employed deep within the shared code, it may have to be passed through multiple method parameters, which might lead to a more complex call chain. If the shared code uses numerous different interfaces, they all must be created and set within the shared code.
#### Inheritance​
Your shared code can implement abstract or virtual classes that could be extended in one or more platform-specific projects. This technique resembles the use of interfaces but provides some already implemented behaviors.
##### How it works​
By using inheritance, you can create base classes in your shared code that can be optionally extended in your platform-specific projects. However, as C# allows only single inheritance, this approach may influence your future API design. Hence, use inheritance with caution.
##### Advantages and Disadvantages​
The advantages and disadvantages of using interfaces apply equally to inheritance. However, an additional advantage of inheritance is that the base class can contain some implementation code. This potentially could provide an entire platform-agnostic implementation that can be optionally extended as needed.
### Using Maui.Essentials​
Another approach would be to use any library that abstracts some features under a common higher level API. Maui.Essentials is one of these libraries, that can be used with Avalonia on .NET 8 or higher via Microsoft.Maui.Essentials nuget package. Alternatively, you can use full set of MAUI packages with Avalonia.Maui hybrid package. This package provides a deeper integration with MAUI packages.
While Maui.Essentials is a great library that abstracts platform APIs, MAUI itself has a limited set of supported platforms. It doesn't provide APIs for Linux, Browser and macOS (non macCatalyst) platforms.
`Maui.Essentials` - Managing Platform Differences & CapabilitiesExamples of Platform DivergencePlatform-Specific featuresDealing with Platform Divergence
- Examples of Platform Divergence
- Platform-Specific features
- Dealing with Platform Divergence
- Platform AbstractionInterfacesInheritance
- Interfaces
- Inheritance
- Using Maui.Essentials
- Examples of Platform Divergence
- Platform-Specific features
- Dealing with Platform Divergence
- Interfaces
- Inheritance
# Implementation Guides | Avalonia Docs
- How-To Guides
- Implementation Guides
## Implementation Guides
These guides show you how to use various implementation architectures and techniques with Avalonia UI.
# How To Use the MVVM Pattern | Avalonia Docs
- How-To Guides
- Implementation Guides
- How To Use the MVVM Pattern
## How To Use the MVVM Pattern
In the meantime, please see the following:
# How to use INotifyPropertyChanged | Avalonia Docs
- How-To Guides
- Data Binding
- How to use INotifyPropertyChanged
## How to use INotifyPropertyChanged
### Introduction​
The INotifyPropertyChanged interface is a critical component in the Model-View-ViewModel (MVVM) design pattern that helps create scalable and maintainable applications. By notifying that a property has been changed, it allows the View to update automatically, improving the communication between the components of your application.
`INotifyPropertyChanged` ### What is INotifyPropertyChanged?​
INotifyPropertyChanged is an interface provided by .NET that a class can implement to signal that a property has changed its value. This is especially useful in data-binding scenarios, where an automatic update of the UI can be triggered once the data it's bound to changes.
`INotifyPropertyChanged` The INotifyPropertyChanged interface has one event member, PropertyChanged. When a property's value is changed, the object raises a PropertyChanged event to notify any bound elements that the property has changed.
`INotifyPropertyChanged` `PropertyChanged` `PropertyChanged` ### Why is INotifyPropertyChanged Important in MVVM?​
In the MVVM pattern, the ViewModel encapsulates the interaction logic for the View and encapsulates the data from the Model. The View binds to properties in the ViewModel, which in turn exposes data contained in Model objects.
For the MVVM pattern to work as intended, the View needs to be updated whenever the underlying data changes. That's where INotifyPropertyChanged comes in. By implementing this interface in your ViewModel, you can notify the View about changes in the Model, which automatically updates the UI.
`INotifyPropertyChanged` ### Implementing INotifyPropertyChanged​
Here's an example of how to implement INotifyPropertyChanged:
`INotifyPropertyChanged` ```bash
public class MyViewModel : INotifyPropertyChanged{  private string _name;  public string Name  {    get { return _name; }    set    {      _name = value;      OnPropertyChanged(nameof(Name));    }  }  public event PropertyChangedEventHandler PropertyChanged;  protected virtual void OnPropertyChanged(string propertyName)  {    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));  }}
```
In this code, whenever the Name property is set to a new value, the OnPropertyChanged method is called, which raises the PropertyChanged event. Any UI elements bound to this property will then update to reflect the new value.
`Name` `OnPropertyChanged` `PropertyChanged` ### Using MVVM Toolkit to Simplify INotifyPropertyChanged​
While implementing INotifyPropertyChanged isn't particularly complex, it can become tedious if you have many properties in your ViewModel. Luckily, the .NET Community Toolkit's MVVM library offers an even more efficient way to implement INotifyPropertyChanged using its ObservableObject class and the [ObservableProperty] attribute with the help of Source Generators.
`INotifyPropertyChanged` `INotifyPropertyChanged` `ObservableObject` `[ObservableProperty]` Here's how you can achieve the same result as before, but using ObservableObject:
`ObservableObject` ```bash
using CommunityToolkit.Mvvm.ComponentModel;public partial class MyViewModel : ObservableObject{  [ObservableProperty]  private string _name;}
```
In this code, the ObservableObject class implements INotifyPropertyChanged, and the [ObservableProperty] attribute is used to indicate that _name is an observable property. The Source Generator will then generate the necessary boilerplate code behind the scenes, including the property's getter and setter, and automatically call the OnPropertyChanged method when the property changes. This makes the implementation cleaner and less error-prone.
`ObservableObject` `INotifyPropertyChanged` `[ObservableProperty]` `_name` `OnPropertyChanged` The MVVM Toolkit provides a range of tools to help simplify the implementation of the MVVM pattern in your .NET applications, including simplifying the use of INotifyPropertyChanged. The use of Source Generators makes your code more efficient and readable, while still maintaining the same functionality.
`INotifyPropertyChanged` - Introduction
- What is INotifyPropertyChanged?
- Why is INotifyPropertyChanged Important in MVVM?
- Implementing INotifyPropertyChanged
- Using MVVM Toolkit to Simplify INotifyPropertyChanged
# Localizing using ResX | Avalonia Docs
- How-To Guides
- Implementation Guides
- Localizing using ResX
## Localizing using ResX
Localization is a crucial step in delivering a great user experience for a global audience. In .NET, the ResXResourceReader and ResXResourceWriter classes are used to read and write resources in an XML-based format (.resx). This guide will walk you through the process of localizing an Avalonia application using ResX files.
`ResXResourceReader` `ResXResourceWriter` ### Add ResX Files to the Project​
Before localizing, you need to include ResX files for each language you want to support. For this guide, we'll consider three ResX files, one for each of the following cultures:
- Resources.fil-PH.resx (Filipino)
- Resources.ja-JP.resx (Japanese)
- Resources.resx (Default language, usually English)
`Resources.fil-PH.resx` `Resources.ja-JP.resx` `Resources.resx` Each ResX file will contain translated text that corresponds to the keys used in the application.
In this example, we added new files to a new folder called Lang. Since .NET generator creates namespaces depending on folder structure, it might be different for you.
`Lang` If you add the files into the Assets folder make sure to switch Build Action to Embedded resource, otherwise the code generation may fail.
`Assets` `Build Action` `Embedded resource` ### Set the Culture​
To use a specific language in the application, you need to set the current culture. This can be done in the App.axaml.cs file. The following example sets the culture to Filipino (fil-PH):
`App.axaml.cs` `fil-PH` ```bash
public partial class App : Application{  public override void Initialize()  {    AvaloniaXamlLoader.Load(this);  }  public override void OnFrameworkInitializationCompleted()  {    Lang.Resources.Culture = new CultureInfo("fil-PH");    if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)    {      desktop.MainWindow = new MainWindow      {        DataContext = new MainWindowViewModel(),      };    }    base.OnFrameworkInitializationCompleted();  }}
```
Replace "fil-PH" with the appropriate culture code as required.
### Use Localized Text in the View​
To use the localized text in a view, you can refer to the resources statically in XAML:
```bash
<TextBlock Text="{x:Static lang:Resources.GreetingText}"/>
```
In the above example, GreetingText is the key that corresponds to a string in the ResX file. The {x:Static} markup extension is used to reference a static property that's been defined in a .NET class, which, in this case, is the resources file (lang:Resources.GreetingText).
`GreetingText` `{x:Static}` `lang:Resources.GreetingText` That's it! You've now successfully localized your Avalonia application using ResX. By setting the culture to a different locale, you can display the user interface in the selected language, thereby creating an application that supports multiple languages and caters to a global audience.
For the localized properties to be available from XAML, the code generated from the resource file must be publicly accessible. By default, the Resources class is generated by ResXFileCodeGenerator and is internal. Make sure to change the custom tool to PublicResXFileCodeGenerator. The relevant part of the csproj should look like this:
`Resources` `ResXFileCodeGenerator` `internal` `PublicResXFileCodeGenerator` `csproj` ```bash
<ItemGroup> <EmbeddedResource Update="Resources.resx">  <Generator>PublicResXFileCodeGenerator</Generator>  <LastGenOutput>Resources.Designer.cs</LastGenOutput> </EmbeddedResource></ItemGroup><ItemGroup> <Compile Update="Resources.Designer.cs">  <DesignTime>True</DesignTime>  <AutoGen>True</AutoGen>  <DependentUpon>Resources.resx</DependentUpon> </Compile></ItemGroup>
```
NB: also note that only the default resource file (Resources.resx) should generate code.
`Resources.resx` - Add ResX Files to the Project
- Set the Culture
- Use Localized Text in the View
# How To Use Design-time Data | Avalonia Docs
- How-To Guides
- Implementation Guides
- How To Use Design-time Data
## How To Use Design-time Data
Design-time data can help you style and position your UI layer without having to build the rest of the application. This is especially useful when you are trying to achieve a pixel-perfect presentation.
The Avalonia UI solution templates all add design-time code to the main window for you to copy.
This guide shows you how to use design-time data with the MVVM pattern to create a realistic UI with only mock data (that is without a data service layer).
This implementation pattern is based on the concept of deriving a design version of any view model that you create, and adding mock data to its constructor. Your XAML files can then declare a design data context, and reference the design version of the view model to display mock data in the preview pane for you.
In this example you are working on the UI for an appointment card to display an appointment view model, like this:
```bash
// Data Properties  public string ServerName { get; set; } = null!;  public string ServiceTitle { get; set; } = null!;    public decimal ServicePrice { get; set; }  public DateTime ServiceDateTime { get; set; }  public string Description { get; set; } = null!;     // Commands  private bool _isCancelVisible = true;  public bool IsCancelVisible  {    get => _isCancelVisible;    set => this.RaiseAndSetIfChanged(ref _isCancelVisible, value);  }  public ReactiveCommand<Unit, Unit> CancelAppointmentCommand =>    ReactiveCommand.Create(() =>    {      IsCancelVisible = false;    });
```
This code creates the design version of this view model:
```bash
public class DesignAppointmentViewModel: AppointmentViewModel{  public DesignAppointmentViewModel()  {    ServerName = "John Price";    ServiceTitle = "Hair Cut and Beard Trim";    ServicePrice = (decimal)25.5;    ServiceDateTime = new DateTime(2023, 1, 3, 11, 15, 0);    Description = "Please allow 30 minutes.";  }}
```
To continue with this example: you are next working on a user control to present the appointment card. Firstly, you must first add a reference to the view models. Next check that you have set a suitable design width and/or height. Then you can add some XAML for the design data context.
As of Avalonia version 11, the default sample app is set to use Compiled bindings. This requires two declarations:
- Import the ViewModels namespace: this is done from the line xmlns:vm is to include the ViewModel namespace. In this example the project name is AvaloniaApplication1.
- Declare the ViewModel class, so that the design time environment can do a type check on the class properties. This is done through the line x:DataType
```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:d="http://schemas.microsoft.com/expression/blend/2008"       xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"       xmlns:vm="using:DesignTimeData.ViewModels"       mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="250"       x:Class="DesignTimeData.Views.AppointmentView"       xmlns:vm="using:AvaloniaApplication1.ViewModels"       x:DataType="vm:DesignAppointmentViewModel">   <Design.DataContext>      <vm:DesignAppointmentViewModel/>  </Design.DataContext></UserControl>
```
This means that when you start to write the XAML for the UI, you can see your progress in the preview pane. When completed, this example has XAML like this:
```bash
<Border CornerRadius="10" Background="LightBlue" Width="350" Margin="20"> <DockPanel Width="350" >     <StackPanel Height="10"          DockPanel.Dock="Bottom"          IsVisible="{Binding !IsCancelVisible, }" >  </StackPanel>  <Button Margin="0 10"      HorizontalAlignment="Center"      DockPanel.Dock="Bottom"      ClickMode="Release"      Command="{Binding CancelAppointmentCommand}"      IsVisible="{Binding IsCancelVisible}">Cancel</Button>  <StackPanel DockPanel.Dock="Left" Margin="10 10 0 0" Width="200" >   <TextBlock Text="{Binding ServiceTitle}" FontWeight="Bold"/>   <TextBlock Text="{Binding ServerName, StringFormat='with {0}'}"/>   <TextBlock Margin="0 5 0 0"         Text="{Binding ServiceDateTime, StringFormat={}{0:dd MMM yyyy}}"/>   <TextBlock Text="{Binding ServiceDateTime, StringFormat={}{0:HH:mm}}"/>   <TextBlock Margin="0 5" FontSize="20"         Text="{Binding ServicePrice, StringFormat={}{0:£0.00}}"/>   <TextBlock Text="{Binding Description, StringFormat={}{0:£0.00}}"/>  </StackPanel>  <Border DockPanel.Dock="Right"   Background="Gainsboro" CornerRadius="10"      Width="75" Height="75"      Margin="0 20 20 0">   <Image ToolTip.Tip="{Binding ServerName}" />  </Border>  <Rectangle/> </DockPanel></Border>
```
The preview pane shows the completed UI design with the mock data:
To have the project fully compiled, you can use the example MainWindow.axaml to include the AppointmentView UserControl into the main window view.
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:vm="using:AvaloniaApplication1.ViewModels"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    xmlns:views="using:AvaloniaApplication1.Views"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaApplication1.Views.MainWindow"    x:DataType="vm:MainWindowViewModel"    WindowStartupLocation="CenterScreen" Width="400" Height="250"    Icon="/Assets/avalonia-logo.ico"    Title="AvaloniaApplication1">  <Design.DataContext>    <!-- This only sets the DataContext for the previewer in an IDE,       to set the actual DataContext for runtime, set the DataContext property in code (look at App.axaml.cs) -->    <vm:MainWindowViewModel/>  </Design.DataContext>    <views:AppointmentView></views:AppointmentView></Window>
```
The AppointmentView will need to have its DataContext set. This can be done in the code behind file AppointmentView.axaml.cs. Sample code below:
```bash
namespace AvaloniaApplication1.Views;public partial class AppointmentView : UserControl{  public AppointmentView()  {    InitializeComponent();    this.DataContext = new AppointmentViewModel();  }}
```
# How To Use Live Preview | Avalonia Docs
- How-To Guides
- Implementation Guides
- How To Use Live Preview
## How To Use Live Preview
This guide will show you how to use the live preview feature of the Avalonia UI extensions for Visual Studio and ReSharper.
The Avalonia for Visual Studio extension includes a XAML designer which can be used to show a live preview of the XAML as you are writing it. With the Avalonia for Visual Studio extension installed, double click on an Avalonia XAML file to open it.
For Visual Studio and ReSharper users, ReSharper 2020.3 introduces built-in code analysis, code completion, navigation, and find usages.
![Shows the XAML Previewer in Visual Studio](https://docs.avaloniaui.net/assets/images/vs-xaml-previewer-83923469c8b7489af5f829fbee9ae7fb.png)
If your XAML is in a library, Avalonia UI needs an executable application in order to be able to preview it. Select an executable project from the dropdown on the top right of the designer. Once your project is built, editing the XAML in the editor will cause the preview to update automatically.
In some cases, due to bugs/limitations in Visual Studio, the Avalonia XAML designer is not shown and instead the WPF designer gets shown. If your XAML file is showing a lot of errors, try right-clicking the file then selecting "Open With..." → "Avalonia XAML Editor".
### Design-Time Properties​
There are a number of properties that can be applied to your controls which will take effect only at design-time. To use these you must add a namespace to your XAML file:
```bash
xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
```
With the namespace added, the following design-time properties become available:
#### d:DesignWidth and d:DesignHeight​
The d:DesignWidth and d:DesignHeight properties apply a width and height to the control being previewed.
`d:DesignWidth` `d:DesignHeight` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    d:DesignWidth="800" d:DesignHeight="450"    x:Class="AvaloniaApplication1.MainWindow">  Welcome to Avalonia!</Window>
```
#### d:DataContext​
The d:DataContext property applies a DataContext only at design-time. It is recommended that you use this property in conjunction with the {x:Static} directive to reference a static property in one of your assemblies:
`d:DataContext` `DataContext` `{x:Static}` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:dd="clr-namespace:My.Namespace;assembly=MyAssembly"    d:DataContext="{x:Static dd:DesignData.ExampleViewModel}"    x:Class="AvaloniaApplication1.MainWindow">  Welcome to Avalonia!</Window>
```
```bash
namespace My.Namespace{  public static class DesignData  {    public static MyViewModel ExampleViewModel { get; } = new MyViewModel    {      // View Model initialization here.    };  }}
```
#### Design.DataContext​
Alternatively you can use Design.DataContext attached property. As well as Design.Width and Design.Height.
`Design.DataContext` `Design.Width` `Design.Height` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:dd="clr-namespace:My.Namespace;assembly=MyAssembly"    x:Class="AvaloniaApplication1.MainWindow"    Design.Width="100">  <Design.DataContext>    <dd:MyViewModel />  </Design.DataContext>  Welcome to Avalonia!</Window>
```
#### Setting the Design-Time DataContext in Code​
Setting the design-time DataContext in XAML by one of the methods shown above is only possible if the view model has a parameterless constructor. Yet view model constructors with parameters are required with typical dependency injection patterns. One option is to use a special design-time view model with a parameterless constructor. However, a design-time DataContext that references a view model constructor with parameters may be set in code with the Design.SetDataContext method.
`DataContext` `DataContext` `Design.SetDataContext` ```bash
public MainWindow(){  // Prevent the previewer's DataContext from being set when the application is run.  if (Design.IsDesignMode)  {    // This can be before or after InitializeComponent.    Design.SetDataContext(this, new MainWindowViewModel(new DialogService()));  }  InitializeComponent();}
```
### Diagnosing Errors​
If you're having problems, try enabling verbose logging. To do this in Visual Studio, follow this procedure:
- Click Options... on the Tools menu
- Click Avalonia XAML Editor in the list
- Click Verbose in the Minimum Log Verbosity drop-down.
Logs will now be displayed in the Visual Studio Output window.
Select Avalonia Diagnostics from the drop-down at the top of this window.
- Design-Time Propertiesd:DesignWidth and d:DesignHeightd:DataContextDesign.DataContextSetting the Design-Time DataContext in Code
- d:DesignWidth and d:DesignHeight
- d:DataContext
- Design.DataContext
- Setting the Design-Time DataContext in Code
- Diagnosing Errors
- d:DesignWidth and d:DesignHeight
- d:DataContext
- Design.DataContext
- Setting the Design-Time DataContext in Code
# How To Implement Dependency Injection | Avalonia Docs
- How-To Guides
- Implementation Guides
- How To Implement Dependency Injection
## How To Implement Dependency Injection in Avalonia
Dependency injection (DI) allows developers to write cleaner, more modular, and testable code. It accomplishes this by creating discrete services that are passed around/created as needed.
This guide will show you step by step how to use Dependency Injection (DI) with Avalonia UI and the MVVM pattern.
### Step 0: Context and Initial Code​
Let's assume that you have an app with a MainViewModel, a BusinessService and a Repository. MainViewModel has a dependency on IBusinessService and BusinessService on IRepository. A simple implementation would look like this:
```bash
public partial class MainViewModel{  private readonly IBusinessService _businessService;  public MainViewModel(IBusinessService businessService)  {    _businessService = businessService;  }}
```
```bash
public class BusinessService : IBusinessService{  private readonly IRepository _repository;  public BusinessService(IRepository repository)  {    _repository = repository;  }}
```
```bash
public class Repository : IRepository{}
```
Typically you would directly instantiate Repository and pass it into BusinessService then pass it into MainViewModel, like this:
`Repository` `BusinessService` `MainViewModel` ```bash
var window = new MainWindow{  DataContext = new MainViewModel(new BusinessService(new Repository()))}
```
This works great for simple constructors that are not used very often and don't change. But this technique does not scale very well because:
- The more dependencies your constructor has the more things you will need to instantiate and pass in. Instantiating the dependencies locally (such as by doing new MainViewModel(new MyService())) results in direct rigid coupling to a specific instance of the dependencies.
- Similarly if MainViewModel creates its dependencies itself, (such as in the constructor body) it also becomes directly coupled to the creation of the dependencies which can result in mostly the same problems.
- Furthermore, if the object is instantiated in many places, every single reference to any of the dependencies would also need to be updated should the dependencies of MainViewModel ever change (such as by requiring additional dependencies or require a different implementation of a dependency).
`MainViewModel` Dependency injection solves these problem by abstracting away the creation of objects and their dependencies. This allows for well encapsulated services to be used that will be automatically passed into any other service that is registered to use them.
### Step 1: Install the NuGet package for DI​
There are many dependency injection (DI) container providers available (DryIoC, Autofac, Pure.DI) but this guide will only focus on Microsoft.Extensions.DependencyInjection which is a lightweight, extensible dependency injection container. It provides an easy-to-use and convention-based way to add DI to .NET applications, including Avalonia-based desktop applications.
`Microsoft.Extensions.DependencyInjection` Run the following command in a terminal inside your project directory to install the DI package:
```bash
dotnet add package Microsoft.Extensions.DependencyInjection
```
### Step 2: Add ServiceCollectionExtensions​
The following code is creating an extension method for IServiceCollection that will register services to our service collection and make them available for injection.
`IServiceCollection` ```bash
public static class ServiceCollectionExtensions{  public static void AddCommonServices(this IServiceCollection collection)  {    collection.AddSingleton<IRepository, Repository>();    collection.AddTransient<BusinessService>();    collection.AddTransient<MainViewModel>();  }}
```
### Step 3: Modify App.axaml.cs​
Next, the App.xaml.cs class should be modified to use the DI container. This will allow the previously registered view model to be resolved via the dependency injection container. The fully realised view model can then be set to the data context of the main view.
`App.xaml.cs` ```bash
public class App : Application{  public override void Initialize()  {    AvaloniaXamlLoader.Load(this);  }  public override void OnFrameworkInitializationCompleted()  {    // If you use CommunityToolkit, line below is needed to remove Avalonia data validation.    // Without this line you will get duplicate validations from both Avalonia and CT    BindingPlugins.DataValidators.RemoveAt(0);    // Register all the services needed for the application to run    var collection = new ServiceCollection();    collection.AddCommonServices();    // Creates a ServiceProvider containing services from the provided IServiceCollection    var services = collection.BuildServiceProvider();    var vm = services.GetRequiredService<MainViewModel>();    if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)    {      desktop.MainWindow = new MainWindow      {        DataContext = vm      };    }    else if (ApplicationLifetime is ISingleViewApplicationLifetime singleViewPlatform)    {      singleViewPlatform.MainView = new MainView      {        DataContext = vm      };    }    base.OnFrameworkInitializationCompleted();  }}
```
- Step 0: Context and Initial Code
- Step 1: Install the NuGet package for DI
- Step 2: Add ServiceCollectionExtensions
- Step 3: Modify App.axaml.cs
# Legacy Developer Tools | Avalonia Docs
- How-To Guides
- Implementation Guides
- Legacy Developer Tools
## Legacy Developer Tools
This documentation covers the Legacy Developer Tools. A new AvaloniaUI Developer Tools is now available, offering enhanced features and improved debugging capabilities. The Legacy Developer Tools remain supported with stability updates.
Avalonia has a built-in DevTools window which is enabled by calling the attached AttachDevTools() method in a Window constructor. The default templates have this enabled when the program is compiled in DEBUG mode:
`AttachDevTools()` `Window` `DEBUG` ```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();  }}// in auto-generated by Avalonia.NameGenerator MainWindow.g.cs:partial class MainWindow{  // ...  public void InitializeComponent(bool loadXaml = true, bool attachDevTools = true)  {    // ...#if DEBUG    if (attachDevTools)    {      this.AttachDevTools();    }#endif    // ...  }}
```
To open the DevTools, press F12, or pass a different Gesture to the this.AttachDevTools() method.
`Gesture` `this.AttachDevTools()` To use DevTools, you must add Avalonia.Diagnostics nuget package.
`Avalonia.Diagnostics` ```bash
dotnet add package Avalonia.Diagnostics
```
But by default, it is already installed.
![](https://docs.avaloniaui.net/assets/images/devtools-overview-8855f3e9a56e43393e2b9f8c9df009f5.png)
There is a known issue when running under .NET core 2.1 that pressing F12 will cause the program to quit. In this case, either switch to .NET core 2.0 or 3.0+ or change the open gesture to something different, such as Ctrl+F12.
`Ctrl+F12` ### Logical and Visual Trees​
The Logical Tree and Visual Tree tabs display the controls in the window's logical and visual trees. Selecting a control will show the properties of that control in the right-hand pane where they can be edited.
`Logical Tree` `Visual Tree` #### Properties​
Allows for quickly checking and editing properties of the control. One can also search for properties (by name or by using a regex).
![](https://docs.avaloniaui.net/assets/images/devtools-properties-7f2ce0ecefdc55878cff959781d29b7b.png)
#### Layout​
Allows for inspecting and editing of common layout properties (Margin, Border , Padding). Control size and size constraints are also shown.
`Margin` `Border` `Padding` If Width or Height are underlined that means there is an active constraint. Hover over the value to see a tooltip containing relevant information.
`Width` `Height` #### Styles​
While properties panel shows currently active values of properties, styles panel shows all values and origin of the value.
Additionally one can see all styles that could potentially match this control (by toggling Show inactive option).
`Show inactive` Current styles can be snap-shotted by either pressing the Snapshot button or pressing Alt+S while hovering over the target window. Snap-shotting means that styles panel won't update to reflect new state of the control. This is especially useful when troubleshooting problems with :pointerover or :pressed selectors.
`Snapshot` `Alt+S` `:pointerover` `:pressed` If setter value is bound to a resource it will be indicated by a circle followed by the resource key.
![](https://docs.avaloniaui.net/assets/images/devtools-styles-f6d139f3c807564a37707e1a5fef2628.png)
If given value has a strikethrough it means that it is being overridden by a value in style with higher priority.
![](https://docs.avaloniaui.net/assets/images/devtools-overridden-styles-6e74eae31959d124ee8e5eb3ff55dae2.png)
Setters have a context menu that allows for quickly copying names and values to the clipboard.
### Events​
The events tab can be used to track the propagation of events. Select the events to track in the left pane, and all events of that type will be shown in the center upper pane. Select one of these events to see the event route.
Dotted underline under event name or control type indicates that quick navigation is possible.
- Double clicking an event type will select and scroll to the given event type
- Double clicking a control type (and/or name) will navigate to the visual tree tab and select said control.
![](https://docs.avaloniaui.net/assets/images/devtools-events-252178788bdc52c5582de28cf1b37063.png)
### Hotkeys​
### Examples​
#### Changing a property value​
![](https://docs.avaloniaui.net/assets/images/devtools-change-property-7b4ec184aaaaa019c0f420a0b2889fd5.gif)
#### Changing layout properties​
![](https://docs.avaloniaui.net/assets/images/devtools-change-layout-96099e8dce1440bc57c1db752d65bf73.gif)
- Logical and Visual TreesPropertiesLayoutStyles
- Properties
- Layout
- Styles
- Events
- Hotkeys
- ExamplesChanging a property valueChanging layout properties
- Changing a property value
- Changing layout properties
- Properties
- Layout
- Styles
- Changing a property value
- Changing layout properties
# Legacy Developer Tools | Avalonia Docs
- How-To Guides
- Implementation Guides
- Legacy Developer Tools
## Legacy Developer Tools
This documentation covers the Legacy Developer Tools. A new AvaloniaUI Developer Tools is now available, offering enhanced features and improved debugging capabilities. The Legacy Developer Tools remain supported with stability updates.
Avalonia has a built-in DevTools window which is enabled by calling the attached AttachDevTools() method in a Window constructor. The default templates have this enabled when the program is compiled in DEBUG mode:
`AttachDevTools()` `Window` `DEBUG` ```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();  }}// in auto-generated by Avalonia.NameGenerator MainWindow.g.cs:partial class MainWindow{  // ...  public void InitializeComponent(bool loadXaml = true, bool attachDevTools = true)  {    // ...#if DEBUG    if (attachDevTools)    {      this.AttachDevTools();    }#endif    // ...  }}
```
To open the DevTools, press F12, or pass a different Gesture to the this.AttachDevTools() method.
`Gesture` `this.AttachDevTools()` To use DevTools, you must add Avalonia.Diagnostics nuget package.
`Avalonia.Diagnostics` ```bash
dotnet add package Avalonia.Diagnostics
```
But by default, it is already installed.
![](https://docs.avaloniaui.net/assets/images/devtools-overview-8855f3e9a56e43393e2b9f8c9df009f5.png)
There is a known issue when running under .NET core 2.1 that pressing F12 will cause the program to quit. In this case, either switch to .NET core 2.0 or 3.0+ or change the open gesture to something different, such as Ctrl+F12.
`Ctrl+F12` ### Logical and Visual Trees​
The Logical Tree and Visual Tree tabs display the controls in the window's logical and visual trees. Selecting a control will show the properties of that control in the right-hand pane where they can be edited.
`Logical Tree` `Visual Tree` #### Properties​
Allows for quickly checking and editing properties of the control. One can also search for properties (by name or by using a regex).
![](https://docs.avaloniaui.net/assets/images/devtools-properties-7f2ce0ecefdc55878cff959781d29b7b.png)
#### Layout​
Allows for inspecting and editing of common layout properties (Margin, Border , Padding). Control size and size constraints are also shown.
`Margin` `Border` `Padding` If Width or Height are underlined that means there is an active constraint. Hover over the value to see a tooltip containing relevant information.
`Width` `Height` #### Styles​
While properties panel shows currently active values of properties, styles panel shows all values and origin of the value.
Additionally one can see all styles that could potentially match this control (by toggling Show inactive option).
`Show inactive` Current styles can be snap-shotted by either pressing the Snapshot button or pressing Alt+S while hovering over the target window. Snap-shotting means that styles panel won't update to reflect new state of the control. This is especially useful when troubleshooting problems with :pointerover or :pressed selectors.
`Snapshot` `Alt+S` `:pointerover` `:pressed` If setter value is bound to a resource it will be indicated by a circle followed by the resource key.
![](https://docs.avaloniaui.net/assets/images/devtools-styles-f6d139f3c807564a37707e1a5fef2628.png)
If given value has a strikethrough it means that it is being overridden by a value in style with higher priority.
![](https://docs.avaloniaui.net/assets/images/devtools-overridden-styles-6e74eae31959d124ee8e5eb3ff55dae2.png)
Setters have a context menu that allows for quickly copying names and values to the clipboard.
### Events​
The events tab can be used to track the propagation of events. Select the events to track in the left pane, and all events of that type will be shown in the center upper pane. Select one of these events to see the event route.
Dotted underline under event name or control type indicates that quick navigation is possible.
- Double clicking an event type will select and scroll to the given event type
- Double clicking a control type (and/or name) will navigate to the visual tree tab and select said control.
![](https://docs.avaloniaui.net/assets/images/devtools-events-252178788bdc52c5582de28cf1b37063.png)
### Hotkeys​
### Examples​
#### Changing a property value​
![](https://docs.avaloniaui.net/assets/images/devtools-change-property-7b4ec184aaaaa019c0f420a0b2889fd5.gif)
#### Changing layout properties​
![](https://docs.avaloniaui.net/assets/images/devtools-change-layout-96099e8dce1440bc57c1db752d65bf73.gif)
- Logical and Visual TreesPropertiesLayoutStyles
- Properties
- Layout
- Styles
- Events
- Hotkeys
- ExamplesChanging a property valueChanging layout properties
- Changing a property value
- Changing layout properties
- Properties
- Layout
- Styles
- Changing a property value
- Changing layout properties
# How To Log Errors and Warnings | Avalonia Docs
- How-To Guides
- Implementation Guides
- How To Log Errors and Warnings
## How To Log Errors and Warnings
This guide shows you how to can log warnings and errors in Avalonia UI using the standard (Microsoft)System.Diagnostics.Trace component.
`System.Diagnostics.Trace` The code to achieve logging is added to your project by the Avalonia UI solution templates if you use them.
To enable, or to check that logging is enabled, follow this procedure:
- Locate the Program.cs file for your application.
- Check that the BuildAvaloniaApp method calls LogToTrace, for example:
`BuildAvaloniaApp` `LogToTrace` ```bash
public static AppBuilder BuildAvaloniaApp()  => AppBuilder.Configure<App>()    .UsePlatformDetect()    .LogToTrace();
```
Without parameters, LogToTrace will log messages with a severity of Warning or higher. You can change this to another level by passing a LogLevel parameter to the LogToTrace call. For example:
`LogToTrace` `Warning` `LogLevel` `LogToTrace` ```bash
using Avalonia.Logging;...public static AppBuilder BuildAvaloniaApp()  => AppBuilder.Configure<App>()    .UsePlatformDetect()    .LogToTrace(LogEventLevel.Verbose)
```
For the full API documentation on the LogEventLevel enum, see here.
`LogEventLevel` Log messages are then shown in the Debug view of the Output window of your IDE. For example, with verbose logging enabled:
If you want to re-route these messages to different location, you can use the methods on the System.Diagnostics.Trace component.
`System.Diagnostics.Trace` ### Log Area​
Each message from Avalonia UI is assigned an area that can be used to filter the log. These are described by the members of Avalonia.Logging.LogArea static class:
`Avalonia.Logging.LogArea` - Property
- Binding
- Animations
- Visual
- Layout
- Control
`Property` `Binding` `Animations` `Visual` `Layout` `Control` You can restrict the log to a specific area, or areas by adding arguments of type Avalonia.Logging.LogArea after the LogEventLevel argument in the LogToTrace call. For example, this will log only property and layout messages:
`Avalonia.Logging.LogArea` `LogEventLevel` `LogToTrace` ```bash
public static AppBuilder BuildAvaloniaApp()  => AppBuilder.Configure<App>()    .UsePlatformDetect()    .LogToTrace(LogEventLevel.Debug, LogArea.Property, LogArea.Layout);
```
### Log Sinks​
The LogToTrace extension method uses TraceLogSink which writes its messages to Trace. Avalonia supports custom sinks by implementing ILogSink. Assigning your custom sink to Avalonia.Logging.Logger.Sink will allow Avalonia to use it.
`LogToTrace` `TraceLogSink` `Trace` `ILogSink` `Avalonia.Logging.Logger.Sink` ```bash
using Avalonia.Controls;using Avalonia.Logging;namespace MyNamespace;public static class MyLogExtensions{  public static AppBuilder LogToMySink(this AppBuilder builder,     LogEventLevel level = LogEventLevel.Warning,     params string[] areas)  {    Logger.Sink = new MyLogSink(level, areas);    return builder;  }}
```
```bash
public static AppBuilder BuildAvaloniaApp()  => AppBuilder.Configure<App>()    .UsePlatformDetect()    .LogToMySink();
```
View the source code on GitHub TraceLogSink.cs
`TraceLogSink.cs` - Log Area
- Log Sinks
# How To Bind Style Classes | Avalonia Docs
- How-To Guides
- Data Binding
- How To Bind Style Classes
## How To Bind Style Classes
This guide will show you how to apply style classes to a control depending on the Boolean value of a data binding.
To do this, you will need some classes defined in a <Styles> collection that target the control class you are using.
`<Styles>` You can then conditionally apply the classes to a control using special classes syntax and a data binding. The syntax is like this:
```bash
<SomeControl Classes.class1="{Binding IsClass1Active}">
```
### Example​
In this example, two styles with class selectors have been defined. These give a text block either a red or a green background. The style class binding assigns class1 when the IsClass1 property of an item is true. Using the negation operator, class2 is assigned when the IsClass1 property is false.
`class1` `IsClass1` `class2` `IsClass1` ```bash
<StackPanel Margin="20"> <ListBox ItemsSource="{Binding ItemList}">  <ListBox.Styles>   <Style Selector="TextBlock.class1">    <Setter Property="Background" Value="OrangeRed" />   </Style>   <Style Selector="TextBlock.class2">    <Setter Property="Background" Value="PaleGreen" />   </Style>  </ListBox.Styles>  <ListBox.ItemTemplate>   <DataTemplate>    <StackPanel>     <TextBlock       Classes.class1="{Binding IsClass1 }"       Classes.class2="{Binding !IsClass1 }"       Text="{Binding Title}"/>    </StackPanel>   </DataTemplate>  </ListBox.ItemTemplate> </ListBox></StackPanel>
```
```bash
public class MainWindowViewModel : ViewModelBase{  public ObservableCollection<ItemClass> ItemList { get; set; }  public MainWindowViewModel()  {    ItemList = new ObservableCollection<ItemClass>(new List<ItemClass>    {      new ItemClass("Item 1", false),      new ItemClass("Item Two", false),      new ItemClass("Third Item", true),      new ItemClass("Item #4", false),            });  }}
```
```bash
public class ItemClass{  public string Title { get; set; }  public bool IsClass1 { get; set; }  public ItemClass(string title, bool isClass1 )  {    Title = title;    IsClass1 = isClass1;  }}
```
- Example
# How To Bind to a Control | Avalonia Docs
- How-To Guides
- Data Binding
- How To Bind to a Control
## How To Bind to a Control
With Avalonia UI, as well as binding to a data context you can also bind one control directly to another.
Note that this technique does not use a data context at all. When you do this, you are binding directly to another control itself.
### Binding to a Named Control​
If you want to bind to a property on another named control, you can use the control name prefixed by a # character.
`#` ```bash
<TextBox Name="other"><!-- Binds to the Text property of the "other" control --><TextBlock Text="{Binding #other.Text}"/>
```
This is the equivalent to the long-form binding that will be familiar to WPF and UWP users:
```bash
<TextBox Name="other"><TextBlock Text="{Binding Text, ElementName=other}"/>
```
Avalonia UI supports both syntaxes.
### Binding to an Ancestor​
You can bind to the (logical control tree) parent of the target using the $parent syntax:
`$parent` ```bash
<Border Tag="Hello World!"> <TextBlock Text="{Binding $parent.Tag}"/></Border>
```
Or to any level of ancestor by using an index with the $parent syntax:
`$parent` ```bash
<Border Tag="Hello World!"> <Border>  <TextBlock Text="{Binding $parent[1].Tag}"/> </Border></Border>
```
The index is zero based so $parent[0] is equivalent to $parent.
`$parent[0]` `$parent` You can also bind to the closest ancestor of a given type, like this:
```bash
<Border Tag="Hello World!"> <Decorator>  <TextBlock Text="{Binding $parent[Border].Tag}"/> </Decorator></Border>
```
Finally, you can combine the index and the type:
```bash
<Border Tag="Hello World!"> <Border>  <Decorator>  <TextBlock Text="{Binding $parent[Border;1].Tag}"/>  </Decorator> </Border></Border>
```
If you need to include a XAML namespace in the ancestor type, you separate the namespace and class using a colon, like this:
```bash
<local:MyControl Tag="Hello World!"> <Decorator>  <TextBlock Text="{Binding $parent[local:MyControl].Tag}"/> </Decorator></local:MyControl>
```
To access a property of a parent's DataContext it will be necessary to cast it with a casting expression (vm:MyUserControlViewModel)DataContext to its actual type. Otherwise DataContext would be considered as of type object and accessing a custom property would result in an compile-time error.
`DataContext` `(vm:MyUserControlViewModel)DataContext` `DataContext` `object` ```bash
<local:MyControl Tag="Hello World!"> <Decorator>  <TextBlock Text="{Binding $parent[local:MyControl].((vm:MyUserControlViewModel)DataContext).CustomProperty}"/> </Decorator></local:MyControl>
```
Avalonia UI also supports WPF/UWP's RelativeSource syntax which does something similar, but is not the same. RelativeSource works on the visual tree whereas the syntax given here works on the logical tree.
`RelativeSource` `RelativeSource` - Binding to a Named Control
- Binding to an Ancestor
# How to Bind to a Collection | Avalonia Docs
- How-To Guides
- Data Binding
- How to Bind to a Collection
## How to Bind to a Collection
Binding to a collection in Avalonia UI is an effective way to display dynamic data. This guide will demonstrate how to bind an ObservableCollection to a control, like a ListBox or ItemsControl, to show a list of items.
`ObservableCollection` `ListBox` `ItemsControl` ### Binding to a Simple ObservableCollection​
For a start, consider you have an ObservableCollection<string> and you want to bind it to a ListBox to display a list of string items.
`ObservableCollection<string>` `ListBox` Here's an example ViewModel with an ObservableCollection<string>:
`ViewModel` `ObservableCollection<string>` ```bash
public class ViewModel : ObservableObject{  private ObservableCollection<string> _items;  public ObservableCollection<string> Items  {    get { return _items; }    set { SetProperty(ref _items, value); }  }  public ViewModel()  {    Items = new ObservableCollection<string> { "Item 1", "Item 2", "Item 3" };  }}
```
In your view, you can bind this ObservableCollection to a ListBox like so:
`ObservableCollection` `ListBox` ```bash
<ListBox ItemsSource="{Binding Items}"/>
```
### Binding to an ObservableCollection of Complex Objects​
But what if your ObservableCollection contains complex objects that themselves need to propagate changes? Let's modify our ViewModel to accommodate this scenario.
`ObservableCollection` `ViewModel` Consider a Person class:
`Person` ```bash
public class Person : ObservableObject{  private string _name;  private int _age;  public string Name  {    get { return _name; }    set { SetProperty(ref _name, value); }  }  public int Age  {    get { return _age; }    set { SetProperty(ref _age, value); }  }}
```
And an ObservableCollection<Person> in our ViewModel:
`ObservableCollection<Person>` ```bash
public class ViewModel : ObservableObject{  private ObservableCollection<Person> _people;  public ObservableCollection<Person> People  {    get { return _people; }    set { SetProperty(ref _people, value); }  }  public ViewModel()  {    People = new ObservableCollection<Person>     {      new Person { Name = "John Doe", Age = 30 },      new Person { Name = "Jane Doe", Age = 28 }    };  }}
```
You can bind this ObservableCollection to a ListBox in your view, and use a DataTemplate to specify how each Person should be presented:
`ObservableCollection` `ListBox` `DataTemplate` `Person` ```bash
<ListBox ItemsSource="{Binding People}">  <ListBox.ItemTemplate>    <DataTemplate>      <StackPanel Orientation="Horizontal">        <TextBlock Text="{Binding Name}" Margin="0,0,10,0"/>        <TextBlock Text="{Binding Age}"/>      </StackPanel>    </DataTemplate>  </ListBox.ItemTemplate></ListBox>
```
In this scenario, each Person in the list will be displayed with their Name and Age separated by a small margin. If any of items properties change, the ListBox item will automatically update.
`Person` `Name` `Age` `ListBox` - Binding to a Simple ObservableCollection
- Binding to an ObservableCollection of Complex Objects
# How To Bind from Code | Avalonia Docs
- How-To Guides
- Data Binding
- How To Bind from Code
## How To Bind from Code
Binding from code in Avalonia works somewhat differently to WPF/UWP. At the low level, Avalonia's binding system is based on Reactive Extensions' IObservable which is then built upon by XAML bindings (which can also be instantiated in code).
`IObservable` ### Subscribing to Changes to a Property​
You can subscribe to changes on a property by calling the GetObservable method. This returns an IObservable<T> which can be used to listen for changes to the property:
`GetObservable` `IObservable<T>` ```bash
var textBlock = new TextBlock();var text = textBlock.GetObservable(TextBlock.TextProperty);
```
Each property that can be subscribed to has a static readonly field called [PropertyName]Property which is passed to GetObservable in order to subscribe to the property's changes.
`[PropertyName]Property` `GetObservable` IObservable (part of Reactive Extensions, or rx for short) is out of scope for this guide, but here's an example which uses the returned observable to print a message with the changing property values to the console:
`IObservable` ```bash
var textBlock = new TextBlock();var text = textBlock.GetObservable(TextBlock.TextProperty);text.Subscribe(value => Console.WriteLine(value + " Changed"));
```
When the returned observable is subscribed, it will return the current value of the property immediately and then push a new value each time the property changes. If you don't want the current value, you can use the rx Skip operator:
`Skip` ```bash
var text = textBlock.GetObservable(TextBlock.TextProperty).Skip(1);
```
### Binding to an observable​
You can bind a property to an observable using the AvaloniaObject.Bind method:
`AvaloniaObject.Bind` ```bash
// We use an Rx Subject here so we can push new values using OnNextvar source = new Subject<string>();var textBlock = new TextBlock();// Bind TextBlock.Text to sourcevar subscription = textBlock.Bind(TextBlock.TextProperty, source);// Set textBlock.Text to "hello"source.OnNext("hello");// Set textBlock.Text to "world!"source.OnNext("world!");// Terminate the bindingsubscription.Dispose();
```
Notice that the Bind method returns an IDisposable which can be used to terminate the binding. If you never call this, then then binding will automatically terminate when the observable finishes via OnCompleted or OnError.
`Bind` `IDisposable` `OnCompleted` `OnError` ### Setting a binding in an object initializer​
It is often useful to set up bindings in object initializers. You can do this using the indexer:
```bash
var source = new Subject<string>();var textBlock = new TextBlock{  Foreground = Brushes.Red,  MaxWidth = 200,  [!TextBlock.TextProperty] = source.ToBinding(),};
```
Using this method you can also easily bind a property on one control to a property on another:
```bash
var textBlock1 = new TextBlock();var textBlock2 = new TextBlock{  Foreground = Brushes.Red,  MaxWidth = 200,  [!TextBlock.TextProperty] = textBlock1[!TextBlock.TextProperty],};
```
Of course the indexer can be used outside object initializers too:
```bash
textBlock2[!TextBlock.TextProperty] = textBlock1[!TextBlock.TextProperty];
```
The only downside of this syntax is that no IDisposable is returned. If you need to manually terminate the binding then you should use the Bind method.
`IDisposable` `Bind` ### Transforming binding values​
Because we're working with observables, we can easily transform the values we're binding!
```bash
var source = new Subject<string>();var textBlock = new TextBlock{  Foreground = Brushes.Red,  MaxWidth = 200,  [!TextBlock.TextProperty] = source.Select(x => "Hello " + x).ToBinding(),};
```
### Using XAML bindings from code​
Sometimes when you want the additional features that XAML bindings provide, it's easier to use XAML bindings from code. For example, using only observables you could bind to a property on DataContext like this:
`DataContext` ```bash
var textBlock = new TextBlock();var viewModelProperty = textBlock.GetObservable(TextBlock.DataContextProperty)  .OfType<MyViewModel>()  .Select(x => x?.Name);textBlock.Bind(TextBlock.TextProperty, viewModelProperty);
```
However, it might be preferable to use a XAML binding in this case:
```bash
var textBlock = new TextBlock{  [!TextBlock.TextProperty] = new Binding("Name")};
```
Or, if you need an IDisposable to terminate the binding:
`IDisposable` ```bash
var textBlock = new TextBlock();var subscription = textBlock.Bind(TextBlock.TextProperty, new Binding("Name"));subscription.Dispose();
```
### Subscribing to a Property on Any Object​
The GetObservable method returns an observable that tracks changes to a property on a single instance. However, if you're writing a control you may want to implement an OnPropertyChanged method which isn't tied to an instance of an object.
`GetObservable` `OnPropertyChanged` To do this you can subscribe to AvaloniaProperty.Changed which is an observable which fires every time the property is changed on any instance.
`AvaloniaProperty.Changed` In WPF this is done by passing a static PropertyChangedCallback to the DependencyProperty registration method, but this only allows the control author to register a property changed callback.
`PropertyChangedCallback` `DependencyProperty` In addition there is an AddClassHandler extension method which can automatically route the event to a method on your control.
`AddClassHandler` For example if you want to listen to changes to your control's Foo property you'd do it like this:
`Foo` ```bash
static MyControl(){  FooProperty.Changed.AddClassHandler<MyControl>(FooChanged);}private static void FooChanged(MyControl sender, AvaloniaPropertyChangedEventArgs e){  // The 'e' parameter describes what's changed.}
```
### Binding to INotifyPropertyChanged objects​
`INotifyPropertyChanged` Binding to objects that implements INotifyPropertyChanged is also available.
`INotifyPropertyChanged` ```bash
var textBlock = new TextBlock();var binding = new Binding {   Source = someObjectImplementingINotifyPropertyChanged,   Path = nameof(someObjectImplementingINotifyPropertyChanged.MyProperty)}; textBlock.Bind(TextBlock.TextProperty, binding);
```
- Subscribing to Changes to a Property
- Binding to an observable
- Setting a binding in an object initializer
- Transforming binding values
- Using XAML bindings from code
- Subscribing to a Property on Any Object
- Binding to INotifyPropertyChanged objects
`INotifyPropertyChanged`
# How to Create a Custom Data Binding Converter | Avalonia Docs
- How-To Guides
- Data Binding
- How to Create a Custom Data Binding Converter
## How to Create a Custom Data Binding Converter
When one of the built-in data binding converters does not meet your conversion requirements, you can write a custom converter based on the IValueConverter interface. This guide will show you how.
`IValueConverter` To review the Microsoft documentation for the IValueConverter interface, see here.
`IValueConverter` As the IValueConverter interface was not available in .NET standard 2.0, Avalonia UI contains a copy in the Avalonia.Data.Converters namespace. You can see the API documentation about this interface, here.
`IValueConverter` `Avalonia.Data.Converters` You must reference a custom converter in some resources before it can be used. This can be at any level in your application. In this example, the custom converter myConverter is referenced in the window resources:
`myConverter` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:local="clr-namespace:ExampleApp;assembly=ExampleApp"> <Window.Resources>  <local:MyConverter x:Key="myConverter"/> </Window.Resources> <TextBlock Text="{Binding Value, Converter={StaticResource myConverter}}"/></Window>
```
### Example​
This example data binding converter can convert text to specific case from a parameter:
```bash
<TextBlock Text="{Binding TheContent,   Converter={StaticResource textCaseConverter},  ConverterParameter=lower}" />
```
The above XAML assumes that the textCaseConverter has been referenced in a resource.
`textCaseConverter` ```bash
public class TextCaseConverter : IValueConverter{  public static readonly TextCaseConverter Instance = new();  public object? Convert(object? value, Type targetType, object? parameter,                               CultureInfo culture)  {    if (value is string sourceText && parameter is string targetCase      && targetType.IsAssignableTo(typeof(string)))    {      switch (targetCase)      {        case "upper":        case "SQL":          return sourceText.ToUpper();        case "lower":          return sourceText.ToLower();        case "title": // Every First Letter Uppercase          var txtinfo = new System.Globalization.CultureInfo("en-US",false)                  .TextInfo;          return txtinfo.ToTitleCase(sourceText);        default:          // invalid option, return the exception below          break;      }    }    // converter used for the wrong type    return new BindingNotification(new InvalidCastException(),                         BindingErrorType.Error);  }  public object ConvertBack(object? value, Type targetType,                 object? parameter, CultureInfo culture)  {   throw new NotSupportedException();  }}
```
### Target Property Type​
You may want to write a a custom converter that can switch the output type depending on what the target property requires. You can achieve this because the Convert method receives a targetType argument that you can test with the IsAssignableTo function.
`Convert` `targetType` `IsAssignableTo` In this example, the animalConverter can find an image, or a text name for a bound Animal class object:
`animalConverter` `Animal` ```bash
<Image Width="42"    Source="{Binding Animal, Converter={StaticResource animalConverter}}"/><TextBlock    Text="{Binding Animal, Converter={StaticResource animalConverter}}" />
```
```bash
public class AnimalConverter : IValueConverter{  public static readonly AnimalConverter Instance = new();  public object? Convert( object? value, Type targetType,                   object? parameter, CultureInfo culture )  {    if (value is Animal animal)    {      if (targetType.IsAssignableTo(typeof(IImage)))      {        img = @"icons/generic-animal-placeholder.png"        switch (animal)        {          case Dog d:           img = d.IsGoodBoy ? @"icons/dog-happy.png"                            : @"icons/dog.png";           break;          case Cat:           img = @"icons/cat.png";           break;          // etc. etc.        }        // see https://docs.avaloniaui.net/docs/guides/data-binding/how-to-create-a-custom-data-binding-converter        return BitmapAssetValueConverter.Instance          .Convert(img, typeof(Bitmap), parameter, culture);      }      else if (targetType.IsAssignableTo(typeof(string)))      {        return !string.IsNullOrEmpty(animal.NickName) ?           $"{animal.Name} \"{animal.NickName}\"" : animal.Name;      }    }    // converter used for the wrong type    return new BindingNotification(new InvalidCastException(),                           BindingErrorType.Error);      }  public object ConvertBack( object? value, Type targetType,                   object? parameter, CultureInfo culture )  {   throw new NotSupportedException();  }}
```
### FuncValueConverter and FuncMultiConverter​
You can also implement a FuncValueConverter if you don't need to convert back and also not the the ConverterParameter. The FuncValueConverter has two generic parameters:
`FuncValueConverter` `ConverterParameter` - TIn: This parameter defines the expected input type. This can also be an array in case you want to use this converter in a MultiBinding.
- TOut: This parameter defines the expected output type.
TIn: This parameter defines the expected input type. This can also be an array in case you want to use this converter in a MultiBinding.
TOut: This parameter defines the expected output type.
#### Example:​
```bash
public static class MyConverters {  /// <summary>  /// Gets a Converter that takes a number as input and converts it into a text representation  /// </summary>  public static FuncValueConverter<decimal?, string> MyConverter { get; } =     new FuncValueConverter<decimal?, string> (num => $"Your number is: '{num}'");    /// <summary>  /// Gets a Converter that takes several numbers as input and converts it into a text representation  /// </summary>  public static FuncMultiValueConverter<decimal?, string> MyMultiConverter { get; } =     new FuncMultiValueConverter<decimal?, string> (num => $"Your numbers are: '{string.Join(", ", num)}'");}
```
```bash
<StackPanel>  <!-- Input -->  <NumericUpDown x:Name="Num1" Value="3" />  <NumericUpDown x:Name="Num2" Value="3" />  <!-- Output -->  <TextBlock Text="{Binding #Num1.Value, Converter={x:Static my:MyConverters.MyConverter}}" />  <TextBlock>    <TextBlock.Text>      <MultiBinding Converter="{x:Static my:MyConverters.MyMultiConverter}">        <Binding Path="#Num1.Value" />        <Binding Path="#Num2.Value" />      </MultiBinding>    </TextBlock.Text>  </TextBlock></StackPanel>
```
### More Information​
For further guidance about how to bind images, see here.
- Example
- Target Property Type
- FuncValueConverter and FuncMultiConverterExample:
- Example:
- More Information
- Example:
# How To Bind Image Files | Avalonia Docs
- How-To Guides
- Data Binding
- How To Bind Image Files
## How To Bind Image Files
In Avalonia UI, binding to an image file opens up opportunities for displaying dynamic image content within your application. This guide provides an overview on how to bind image files from various sources.
### Binding to Image Files from Various Sources​
Assuming you have images from various sources (i.e., a local resource or a web URL) that you want to display in your view, here's how you can achieve this:
First, in your ViewModel, you need to define properties that represent these image sources. The properties can be of type Bitmap or Task<Bitmap> (if loading the image involves an asynchronous operation). The ImageHelper class is used to load these images.
`ViewModel` `Bitmap` `Task<Bitmap>` `ImageHelper` ```bash
public class MainWindowViewModel : ViewModelBase{  public Bitmap? ImageFromBinding { get; } = ImageHelper.LoadFromResource(new Uri("avares://LoadingImages/Assets/abstract.jpg"));  public Task<Bitmap?> ImageFromWebsite { get; } = ImageHelper.LoadFromWeb(new Uri("https://upload.wikimedia.org/wikipedia/commons/4/41/NewtonsPrincipia.jpg"));}
```
You'll need to have a helper class ImageHelper that provides methods to load images from resources and from a web URL. Here's how you can implement this class:
`ImageHelper` ```bash
using System;using System.IO;using System.Net.Http;using System.Threading.Tasks;using Avalonia;using Avalonia.Media.Imaging;using Avalonia.Platform;namespace ImageExample.Helpers{  public static class ImageHelper  {    public static Bitmap LoadFromResource(Uri resourceUri)    {      return new Bitmap(AssetLoader.Open(resourceUri));    }    public static async Task<Bitmap?> LoadFromWeb(Uri url)    {      using var httpClient = new HttpClient();      try      {        var response = await httpClient.GetAsync(url);        response.EnsureSuccessStatusCode();        var data = await response.Content.ReadAsByteArrayAsync();        return new Bitmap(new MemoryStream(data));      }      catch (HttpRequestException ex)      {        Console.WriteLine($"An error occurred while downloading image '{url}' : {ex.Message}");        return null;      }    }  }}
```
The LoadFromResource method takes a resource URI and loads the image using the AssetLoader class provided by Avalonia. The LoadFromWeb method loads an image from a web URL using the HttpClient class.
`LoadFromResource` `AssetLoader` `LoadFromWeb` `HttpClient` Then, in your view, you can bind these image sources to Image controls:
`Image` ```bash
<Grid ColumnDefinitions="*,*,*" RenderOptions.BitmapInterpolationMode="HighQuality">  <Image Grid.Column="0" Source="avares://LoadingImages/Assets/abstract.jpg" MaxWidth="300" />  <Image Grid.Column="1" Source="{Binding ImageFromBinding}" MaxWidth="300" />  <Image Grid.Column="2" Source="{Binding ImageFromWebsite^}" MaxWidth="300" /></Grid>
```
The Source property of the Image control can accept various types of image sources including a file path, a URL, or a resource. Please note that for asynchronous image sources, you must use the ^ character after the binding expression to tell Avalonia that this is an asynchronous binding.
`Source` `Image` `^` Ensure that local image file paths are accurate, the image file is accessible, and if it's part of your application resources, it's been correctly included in your project. If you're binding to a web image, ensure that the URL is reachable.
- Binding to Image Files from Various Sources
# How To Bind Tabs | Avalonia Docs
- How-To Guides
- Data Binding
- How To Bind Tabs
## How To Bind Tabs
### Binding Support Example​
You can dynamically create tab items with data binding. To do this, bind the ItemsSource property of a tab control to an array of objects representing the tab header and content.
`ItemsSource` You can then use a data template to display the objects.
This example uses an array of objects created from this TabItemViewModel class:
`TabItemViewModel` ```bash
namespace MyApp.ViewModel;public class TabItemViewModel{  public string Header { get; }  public string Content { get; }  public TabItemViewModel(string header, string content)  {    Header = header;    Content = content;  }}
```
Create an array of two TabItemViewModel instances and bind it to the DataContext.
`TabItemViewModel` ```bash
DataContext = new TabItemViewModel[] {   new TabItemViewModel("One", "Some content on first tab"),  new TabItemViewModel("Two", "Some content on second tab"),};
```
The TabStrip header content is defined by ItemTemplate property, while TabItem's content is defined by ContentTemplate property.
`TabStrip` `TabItem` Finally create a TabControl and bind its ItemsSource property to the DataContext.
`TabControl` `ItemsSource` ```bash
<TabControl ItemsSource="{Binding}">  <TabControl.ItemTemplate>   <DataTemplate>    <TextBlock Text="{Binding Header}" />   </DataTemplate>  </TabControl.ItemTemplate>  <TabControl.ContentTemplate>    <!-- ContentTemplate's DataTemplate must specify the view model in DataType.    The alias 'vm' references the specification of the view model's namespace in     an attribute of the XAML's root element, which will look like      xmlns:vm="using:MyApp.ViewModel"    or      xmlns:vm="clr-namespace:MyApp.ViewModel;assembly=MyApp.ViewModel" -->   <DataTemplate DataType="vm:TabItemViewModel">    <DockPanel LastChildFill="True">     <TextBlock Text="This is content of selected tab" DockPanel.Dock="Top" FontWeight="Bold" />     <TextBlock Text="{Binding Content}" />    </DockPanel>   </DataTemplate>  </TabControl.ContentTemplate> </TabControl>
```
- Binding Support Example
# How to Bind Multiple Properties | Avalonia Docs
- How-To Guides
- Data Binding
- How to Bind Multiple Properties
## How to Bind Multiple Properties
### MultiBinding​
In scenarios where a target property must be assigned a result calculated from several other bound properties, a MultiBinding may be the appropriate solution. MultiBinding aggregates multiple Binding objects and produces a result through the use of an IMultiValueConverter. The Convert method is called each time any of the bound properties notify of change. Similar to Binding, MultiBinding can be used to bind properties on ViewModels, Controls, or other sources.
`MultiBinding` `MultiBinding` `Binding` `IMultiValueConverter` `Convert` `Binding` `MultiBinding` `Control` MultiBinding only supports BindingMode.OneTime and BindingMode.OneWay.
`MultiBinding` `BindingMode.OneTime` `BindingMode.OneWay` ### IMultiValueConverter​
Similar to IValueConverter in that it defines conversions to a target property. There is no ConvertBack method as aggregate operations are irreversible.
`IValueConverter` `ConvertBack` ```bash
public interface IMultiValueConverter{  object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture);}
```
### MultiBinding Example​
Consider the following scenario where you have inputs for red, green, and blue color channels. The aim is to bind all 3 inputs and provide an IBrush for another control to draw with. Below, the color channel values are constrained to the proper range ([0, 255]) by the NumericUpDown. Creating <Binding> objects is necessary as the Binding MarkupExtension cannot be used because there aren't properties to target.
`IBrush` `NumericUpDown` `<Binding>` `Binding` `MarkupExtension` ```bash
<StackPanel HorizontalAlignment="Center" VerticalAlignment="Center" Spacing="8">  <NumericUpDown x:Name="red" Minimum="0" Maximum="255" Increment="20" Value="0" Foreground="Red" />  <NumericUpDown x:Name="green" Minimum="0" Maximum="255" Increment="20" Value="0" Foreground="Green" />  <NumericUpDown x:Name="blue" Minimum="0" Maximum="255" Increment="20" Value="0" Foreground="Blue" />  <TextBlock Text="MultiBinding Text Color!" FontSize="24">    <TextBlock.Foreground>      <MultiBinding Converter="{StaticResource RgbToBrushMultiConverter}">        <Binding Path="Value" ElementName="red" />        <Binding Path="Value" ElementName="green" />        <Binding Path="Value" ElementName="blue" />      </MultiBinding>    </TextBlock.Foreground>  </TextBlock></StackPanel>
```
Next, we create the IMultiValueConverter. Type checking of parameters is important. In this scenario, NumericUpDown.Value is a decimal? so both decimal and null must be checked. The value may also be UnsetValueType when the bindings are being initialized. Further numeric conversion could be done to make the converter broadly compatible with numeric types.
`IMultiValueConverter` `NumericUpDown.Value` `decimal?` `decimal` `null` `UnsetValueType` ```bash
public sealed class RgbToBrushMultiConverter : IMultiValueConverter{  public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)  {    // Ensure all bindings are provided and attached to correct target type    if (values?.Count != 3 || !targetType.IsAssignableFrom(typeof(ImmutableSolidColorBrush)))      throw new NotSupportedException();    // Ensure all bindings are correct type    if (!values.All(x => x is decimal or UnsetValueType or null))      throw new NotSupportedException();    // Pull values, DoNothing if any are unset.    // Convert is called several times during initialization of bindings,    // so some properties will be initially unset.    if (values[0] is not decimal r ||      values[1] is not decimal g ||      values[2] is not decimal b)      return BindingOperations.DoNothing;    byte a = 255;    var color = new Color(a, (byte)r, (byte)g, (byte)b);    return new ImmutableSolidColorBrush(color);  }}
```
![](https://docs.avaloniaui.net/assets/images/multibinding-rgb-e99dc0f20485f69304c38c9edc8313dc.gif)
- Consider creating a MarkupExtension to simplify the XAML syntax when a MultiBinding is frequently reused.
- Consider using FuncMultiValueConverter to reduce the amount of code needed for simpler converters.
`MarkupExtension` `MultiBinding` `FuncMultiValueConverter` - MultiBinding
- IMultiValueConverter
- MultiBinding Example
# How to Bind Can Execute | Avalonia Docs
- How-To Guides
- Data Binding
- How to Bind Can Execute
## How to Bind Can Execute
Whether a control, that can initiate an action in response to user interaction, is in its enabled state, is an important principle of the 'revealed functionality' part of user experience design (UX). User confidence is reinforced by disabling commands that cannot run. For example where a button or menu item cannot run due to the current state of an application, they should be presented as inactive.
This example assumes that you are using the MVVM implementation pattern with the ReactiveUI framework. This (recommended) approach gives a very clear separation between the view and the view model.
In this example, the button can only be clicked when the message is not empty. As soon as the output is shown; the message is reset to the empty string - which in turn will disable the button again.
```bash
<StackPanel Margin="20"> <TextBox Margin="0 5" Text="{Binding Message}"      Watermark="Add a message to enable the button"/> <Button Command="{Binding ExampleCommand}">    Run the example </Button> <TextBlock Margin="0 5" Text="{Binding Output}" /></StackPanel>
```
```bash
namespace AvaloniaGuides.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    private string _message = string.Empty;    private string _output = "Waiting...";    public string Message     {       get => _message;       set => this.RaiseAndSetIfChanged(ref _message, value);     }    public string Output    {      get => _output;      set => this.RaiseAndSetIfChanged(ref _output, value);    }    public ReactiveCommand<Unit, Unit> ExampleCommand { get; }    public MainWindowViewModel()    {      var isValidObservable = this.WhenAnyValue(        x => x.Message,        x => !string.IsNullOrWhiteSpace(x));      ExampleCommand = ReactiveCommand.Create(PerformAction,                           isValidObservable);    }    private void PerformAction()    {       Output = $"The action was called. {_message}";       Message = String.Empty;    }  }}
```
```bash
using ReactiveUI;namespace AvaloniaGuides.ViewModels{  public class ViewModelBase : ReactiveObject  {  }}
```
In the constructor of the view model, the reactive command is created with two parameters. The first is the private method that performs the action. The second is an observable which is created by the WhenAnyValue method of the ReactiveObject that underlies the view model (from the ViewModelBase class).
`WhenAnyValue` `ReactiveObject` `ViewModelBase` The ViewModelBase class is added to your project when you use the 'Avalonia MVVM Application' solution template.
`ViewModelBase` Here the WhenAnyValue method takes two arguments, the first collects a value for the parameter of the validation function, and the second is the validation function that returns a Boolean result.
`WhenAnyValue` The WhenAnyValue method actually has overloads that can take up to 10 different value getters (for the validation function parameters), plus the validation function itself.
`WhenAnyValue` ![](https://docs.avaloniaui.net/assets/images/bind-canexecute-c298c4ec58854143e8c3425893ead22e.gif)
# How to Bind to a Command with ReactiveUI | Avalonia Docs
- How-To Guides
- Data Binding
- How to Bind to a Command with ReactiveUI
## How to Bind to a Command with ReactiveUI
This guide shows you how to bind a view model method (that performs an action) to a control that can initiate an action in response to user interaction (for example, a button). This binding is defined in XAML using the Command attribute, for example:
`Command` ```bash
<Window xmlns="https://github.com/avaloniaui">  ... <StackPanel Margin="20">   <Button Command="{Binding ExampleCommand}">Run the example</Button> </StackPanel>
```
This guide assumes that you are using the MVVM implementation pattern, and you have based your view model on the ReactiveUI framework.
To review the concept behind the MVVM implementation pattern, see here.
If you created your application using the Avalonia MVVM Application solution template then your solution will already contain the ReactiveUI framework package, and you can reference it like this:
```bash
using ReactiveUI;
```
A view model that can perform actions implements them through the ICommand interface. The ReactiveUI framework provides the ReactiveCommand class that implements ICommand.
`ICommand` `ReactiveCommand` `ICommand` For details of the definition of the ICommand interface, see here.
`ICommand` The Command attribute data binding will call the bound view model method through its ICommand.Execute interface, when the bound control is activated. In this example: when the button is clicked.
`Command` `ICommand.Execute` To create a view model with a ReactiveCommand, follow this example:
`ReactiveCommand` - In your view model, declare a command, like this:
```bash
public ReactiveCommand<Unit, Unit> ExampleCommand { get; }
```
- Create a private method in the view model to perform the action.
- Initialize the reactive command, passing the name of the method that performs the action.
Your view model code will now look like this:
```bash
namespace AvaloniaGuides.ViewModels{  public class MainWindowViewModel   {    public ReactiveCommand<Unit, Unit> ExampleCommand { get; }    public MainWindowViewModel()    {      ExampleCommand = ReactiveCommand.Create(PerformAction);    }    private void PerformAction()    {      Debug.WriteLine("The action was called.");    }  }}
```
- Run the app and monitor the debug output.
When the control bound to the reactive command is activated (in this example: when the button is clicked); then the private method to perform the action is called through the reactive command.
![](https://docs.avaloniaui.net/assets/images/bind-reactivecommand-5f6f3971318fa3967a2d90dedd759740.gif)
### Command Parameter​
You will often need to pass an argument to the reactive command that is bound to a control. You can achieve this using the CommandParameter attribute in the XAML. For example:
`CommandParameter` ```bash
<Window xmlns="https://github.com/avaloniaui">  ...  <StackPanel Margin="20">   <Button Command="{Binding ExampleCommand}"       CommandParameter="From the button">Run the example</Button>  </StackPanel></Window>
```
You must now modify the view model so that the reactive commend expects a string parameter, the initialisation expects a string parameter, and the private method to perform the action expects a string parameter. As follows:
```bash
namespace AvaloniaGuides.ViewModels{  public class MainWindowViewModel   {    public ReactiveCommand<string, Unit> ExampleCommand { get; }    public MainWindowViewModel()    {      ExampleCommand = ReactiveCommand.Create<string>(PerformAction);    }    private void PerformAction(string msg)    {      Debug.WriteLine($"The action was called. {msg}");    }  }}
```
Note that no type conversion is carried out on the CommandParameter attribute, so if you need to use a type parameter that is not a string, then you must define the type in the XAML. You will also need to use the expanded XAML syntax for the parameter.
`CommandParameter` For example to pass an integer parameter:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:sys="clr-namespace:System;assembly=mscorlib"> ...    <Button Command="{Binding ExampleIntegerCommand}">    <Button.CommandParameter>      <sys:Int32>42</sys:Int32>    </Button.CommandParameter>    What is the answer?  </Button></Window>
```
You will get an error if your parameter definitions are missing or not the correct type.
Like any other property, the command parameter can be bound.
- Command Parameter
# How to Bind to a Command without ReactiveUI | Avalonia Docs
- How-To Guides
- Data Binding
- How to Bind to a Command without ReactiveUI
## How to Bind to a Command without ReactiveUI
Sometimes you just want to call a method when a button is clicked without the full ceremony of creating a reactive command, using the ReactiveUI framework.
To see how to how to bind to a command with ReactiveUI, see here.
Avalonia UI data binding allows you to implement directly both a view model method that performs an action, and a property that can control whether the method can execute.
For example, using the XAML as follows:
```bash
<Window xmlns="https://github.com/avaloniaui">  ...  <StackPanel Margin="20">   <Button Command="{Binding PerformAction}"       CommandParameter="From the button, without ReactiveUI">       Run the example</Button>  </StackPanel></Window>
```
You can write a view model capable of running the action, like this
```bash
namespace AvaloniaGuides.ViewModels{  public class MainWindowViewModel   {    public void PerformAction(object msg)    {      Debug.WriteLine($"The action was called. {msg}");    }  }}
```
![](https://docs.avaloniaui.net/assets/images/bind-method-19f1b3b6ef0381eb9311c9a91cc4c6d9.gif)
### Can Execute?​
Avalonia UI data binding provides a simple way of implementing a 'can execute?' feature using a naming convention.
If you need to have execution dependent on the value of a command parameter or a view model property, then you can write a second Boolean method to check if the action method can execute.
To make this work, Avalonia UI uses the naming convention that the Boolean method has the same root name as the action method, but with the added prefix 'Can'.
For example:
```bash
namespace AvaloniaGuides.ViewModels{  public class MainWindowViewModel   {    public void PerformAction(object msg)    {      Debug.WriteLine($"The action was called. {msg}");    }    public bool CanPerformAction(object msg)    {      if (msg!=null) return !string.IsNullOrWhiteSpace( msg.ToString() );      return false;    }  }}
```
So, extending the example XAML to supply the parameter (string) from a text box:
```bash
<StackPanel Margin="20"> <TextBox Margin="0 5" x:Name="message"      Watermark="Add a message to enable the button"/> <Button Command="{Binding PerformAction}"     CommandParameter="{Binding #message.Text}">  Run the example </Button></StackPanel>
```
This example uses the technique of binding directly to another control. You can see how to do this, here.
You will see that the button becomes enables only when the text box contains a string.
![](https://docs.avaloniaui.net/assets/images/bind-method-canexecute-5c24cc1db21bd5d013e1ec574bbad409.gif)
### Trigger Can Execute​
If you want to trigger the 'can execute?' method from another property in your view model, then you will have to decorate the property with one or more DependsOn attributes, and write the code to invoke property changed events yourself.
`DependsOn` This technique applies to a view model that is not using the ReactiveUI framework.
- Can Execute?
- Trigger Can Execute
# How to Bind to a Task Result | Avalonia Docs
- How-To Guides
- Data Binding
- How to Bind to a Task Result
## How to Bind to a Task Result
### Example 1: Binding to a task​
If you need to do some heavy work to load the content of a property you can bind to the result of an async Task<TResult>
`async Task<TResult>` Consider you have the following view model which generates some text in a long running process:
```bash
public Task<string> MyAsyncText => GetTextAsync();private async Task<string> GetTextAsync(){ await Task.Delay(1000); // The delay is just for demonstration purpose return "Hello from async operation";}
```
You can bind to the result in the following way:
```bash
<TextBlock Text="{Binding MyAsyncText^, FallbackValue='Wait a second'}" />
```
Note: You can use FallbackValue to display some loading indicator.
`FallbackValue` - Example 1: Binding to a task
# How To Bind to an Observable | Avalonia Docs
- How-To Guides
- Data Binding
- How To Bind to an Observable
## How To Bind to an Observable
Content in preparation.
You can subscribe to the result of a task or an observable by using the ^ stream binding operator.
`^` ### Example 1: Binding to an observable​
For example if DataContext.Name is an IObservable<string> then the following example will bind to the length of each string produced by the observable as each value is produced
`DataContext.Name` `IObservable<string>` ```bash
<TextBlock Text="{Binding Name^.Length}"/>
```
- Example 1: Binding to an observable
# Community Support | Avalonia Docs
- Community Support
## Community Support
The Avalonia community offers several ways to get help, share knowledge, and connect with other developers. Each platform serves a different purpose to help you get the most effective support for your needs.
### GitHub Discussions​
We encourage developers to ask questions on GitHub Discussions. This is our preferred platform for technical questions because:
- Questions and answers are publicly searchable, helping future developers find solutions
- Complex technical discussions can be properly formatted with code blocks
- Issues can be easily linked to relevant pull requests or documentation
- The community can build a knowledge base over time
GitHub Discussions is ideal for:
- Implementation questions
- Architecture discussions
- Feature requests
- General technical queries
### Community Chats​
While our community chats are a fantastic resource for real-time discussion and quick help, it's important to understand their limitations. Chat platforms, by their nature, are where valuable information often gets lost to time. These conversations aren't indexed by search engines, can't be easily referenced later, and aren't accessible for AI learning systems that could help future developers. This means the same questions often get asked and answered repeatedly, reducing the efficiency of our community's knowledge sharing.
This is why we highly encourage using GitHub Discussions as your first destination for questions. By posting on GitHub Discussions, you're not just getting help, you're contributing to a searchable, permanent knowledge base that benefits the entire Avalonia community and ecosystem.
#### Telegram​
Access the Avalonia chat using the Telegram app (recommended for the best experience). Our Telegram community is great for:
- Quick questions specific to your application
- Keeping up with community news and updates
- Real-time troubleshooting
- Networking with other Avalonia developers
You can access the Telegram chat here.
#### C# Discord​
Some members of the Avalonia community can also be found in the GUI channel on the C# Discord server. While this isn't an official Avalonia-specific channel, it can be a helpful resource for:
- General GUI development discussions
- Cross-pollination of ideas with other .NET UI frameworks
- Broader .NET ecosystem conversations
### Best Practices for Getting Help​
To get the most effective help:
- Use GitHub Discussions for general questions that could help others
- Use community chats for quick, specific questions about your implementation
- Always include relevant code examples and what you've tried
- Check the documentation and existing GitHub Discussions first
- Be specific about which version of Avalonia you're using
- GitHub Discussions
- Community ChatsTelegramC# Discord
- Telegram
- C# Discord
- Best Practices for Getting Help
- Telegram
- C# Discord
# MenuFlyout | Avalonia Docs
- Reference
- Controls Reference
- MenuFlyout
## MenuFlyout
A 'MenuFlyout' allows you to host a simple menu as the flyout for a control. You might use this as an alternative to the context menu.
For details of the context menu, see the reference here.
The properties of a menu flyout are the same as for a flyout. See here.
### Example​
This is a simple example of the menu flyout:
```bash
<Button Content="Button" HorizontalAlignment="Center"> <Button.Flyout>  <MenuFlyout>   <MenuItem Header="Open"/>   <MenuItem Header="-"/>   <MenuItem Header="Close"/>      </MenuFlyout> </Button.Flyout></Button>
```
Note the <Separator/> element will not work in a menu flyout. To make a separator line, use a <MenuItem> element with the header set to '-' as shown above.
`<Separator/>` `<MenuItem>` The resulting menu flyout looks like this:
![](https://docs.avaloniaui.net/assets/images/menuflyout-button-adbe8e917f2a713f50ed38c2ea7f622f.gif)
### Dynamic MenuFlyout​
This is an example for a MenuFlyout that is created dynamically during runtime based on a collection MyMenuItems with items of type MyMenuItemViewModel.
`MenuFlyout` `MyMenuItems` `MyMenuItemViewModel` ```bash
<Button Content="Button"> <Button.Flyout>  <MenuFlyout ItemsSource="{Binding MyMenuItems}">   <MenuFlyout.ItemContainerTheme>    <ControlTheme TargetType="MenuItem" BasedOn="{StaticResource {x:Type MenuItem}}"      x:DataType="l:MyMenuItemViewModel">     <Setter Property="Header" Value="{Binding Header}"/>     <Setter Property="ItemsSource" Value="{Binding Items}"/>     <Setter Property="Command" Value="{Binding Command}"/>     <Setter Property="CommandParameter" Value="{Binding CommandParameter}"/>         </ControlTheme>   </MenuFlyout.ItemContainerTheme>  </MenuFlyout> </Button.Flyout></Button>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub MenuFlyout.cs
`MenuFlyout.cs` - Example
- Dynamic MenuFlyout
- More Information
# Menu Controls | Avalonia Docs
- Reference
- Controls Reference
- Menu Controls
## Menu Controls
Menu controls allow you to add menus to your Avalonia UI app.
`TabStrip`
# MaskedTextBox | Avalonia Docs
- Reference
- Controls Reference
- MaskedTextBox
## MaskedTextBox
The MaskedTextBox presents an area for typed (keyboard) input, but where the format and characters permitted can be constrained by a mask pattern formed from special characters.
`MaskedTextBox` The mask pattern can also contain literal characters that appear in the input and cannot be typed over.
### Useful Properties​
You will probably use these properties most often:
`Mask` `AsciiOnly` `Text` ### Mask Characters​
The mask property accepts a string that can contain a combination of fixed characters and the following special characters:
`0` `9` `#` `L` `?` `&` `C` `A` `a` `.` `,` `:` `/` `$` `<` `>` `|` `\` The escape character (backslash) can be used to include a special character as a literal. For example, to include the dollar sign:
Mask="\$999,000.00"
`Mask="\$999,000.00"` ### Example​
This is a basic example:
```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5">International phone number:</TextBlock> <MaskedTextBox Mask="(+09) 000 000 0000" /> <TextBlock Margin="0 15 0 5">UK VAT number:</TextBlock> <MaskedTextBox Mask="GB 000 000 000" /></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/maskedtextbox-phone-c69e3c5439f2cc42a37a05902d1265be.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub MaskedTextBox.cs
`MaskedTextBox.cs` - Useful Properties
- Mask Characters
- Example
- More Information
# ListBox | Avalonia Docs
- Reference
- Controls Reference
- ListBox
## ListBox
The ListBox displays items from an items source collection, on multiple lines, and allows individual or multiple selection.
`ListBox` The items in the list can be composed, bound and templated.
The list height expands to fit all the items unless set specifically (using the height attribute), or set by a containing control, such as the dock panel.
To learn more about the dock panel, see the reference page here.
When the height is constrained, and the total item height is larger, then the built-in scroll viewer in the list box will display a vertical scrollbar.
Similarly when the width of any item exceeds the width of the list box, then the built-in scroll viewer in the list box will display a horizontal scrollbar (unless prevented - see below).
### Useful Properties​
You will probably use these properties most often:
`Items` `SelectedIndex` `SelectedItem` `SelectedItems` `Selection` `ISelectionModel` `SelectionMode` ScrollViewer.Horizontal
`ScrollViewer.Horizontal` ScrollBarVisibility
`ScrollBarVisibility` ScrollViewer.Vertical
`ScrollViewer.Vertical` ScrollBarVisibility
`ScrollBarVisibility` `ItemPanel` `Styles` To optimize performance when the items collection is large, use of the ISelectionModel is recommended.
`ISelectionModel` ### Selection Mode​
The following selection modes are available for the list box:
`Single` `Multiple` `Toggle` `AlwaysSelected` These values can be combined, for example:
```bash
<ListBox SelectionMode="Multiple,Toggle">
```
### Example​
This simple example has the ItemsSource property set to an array in the C# code-behind.
`ItemsSource` ```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5">Choose an animal:</TextBlock> <ListBox x:Name="animals"/></StackPanel>
```
```bash
using Avalonia.Controls;using System.Linq;namespace AvaloniaControls.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();      animals.ItemsSource = new string[]        {"cat", "camel", "cow", "chameleon", "mouse", "lion", "zebra" }      .OrderBy(x => x);    }  }}
```
![](https://docs.avaloniaui.net/assets/images/listbox-string-0ba0a000ccf4ef22ec92ffcf6bd85f9e.gif)
### Item Template​
You can customize how an item is displayed by using an data template inside the list box ItemTemplate element.
`ItemTemplate` To review the concepts behind data template, see here.
This example displays each item inside a blue border with rounded corners. The C# code-behind is the same as before:
```bash
<DockPanel Margin="20"> <TextBlock Margin="0 5" DockPanel.Dock="Top">Choose an animal:</TextBlock> <ListBox x:Name="animals">  <ListBox.ItemTemplate>   <DataTemplate>    <Border BorderBrush="Blue" BorderThickness="1"         CornerRadius="4" Padding="4">     <TextBlock Text="{Binding}"/>    </Border>   </DataTemplate>  </ListBox.ItemTemplate> </ListBox></DockPanel>
```
```bash
using Avalonia.Controls;using System.Linq;namespace AvaloniaControls.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();      animals.ItemsSource = new string[]        {"cat", "camel", "cow", "chameleon", "mouse", "lion", "zebra" }      .OrderBy(x => x);    }  }}
```
The list is the fill area of the dock panel here, so its height is set to the remaining. This shows the scrollbar in the list box.
![](https://docs.avaloniaui.net/assets/images/listbox-datatemplate-73c30ddec05a6e08ec6b0878d88eb79b.gif)
### Item Styling​
Each item displayed in a list box is drawn inside a ListBoxItem element. You can see this using the Avalonia UI Dev Tools (F12), using the Visual Tools tab. For example:
`ListBoxItem` The ListBoxItem element acts as a container for the content specified in a ListBox.ItemTemplate element; but it is not ever defined in the XAML, instead it is generated by Avalonia UI.
`ListBoxItem` `ListBox.ItemTemplate` This means you can target a style to customize the ListBoxItem elements in a list box. For example, to give the list items a fixed width of 200 and then right-align them:
`ListBoxItem` ```bash
<DockPanel Margin="20"> <TextBlock Margin="0 5" DockPanel.Dock="Top">Choose an animal:</TextBlock> <ListBox x:Name="animals">  <ListBox.Styles>   <Style Selector="ListBoxItem">    <Setter Property="Width" Value="200"/>    <Setter Property="HorizontalAlignment" Value="Right"/>   </Style>  </ListBox.Styles> </ListBox></DockPanel>
```
```bash
using Avalonia.Controls;using System.Linq;namespace AvaloniaControls.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();      animals.ItemsSource = new string[]        {"cat", "camel", "cow", "chameleon", "mouse", "lion", "zebra" }      .OrderBy(x => x);    }  }}
```
![](https://docs.avaloniaui.net/assets/images/listbox-item-style-f11955ecf3a1901af9e4d4bafb90fb2c.gif)
#### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ListBox.cs
`ListBox.cs` - Useful Properties
- Selection Mode
- Example
- Item Template
- Item StylingMore Information
- More Information
# LayoutTransformControl | Avalonia Docs
- Reference
- Controls Reference
- LayoutTransformControl
## LayoutTransformControl
The LayoutTransformControl can dynamically transform a UI layout completely within a view.
`LayoutTransformControl` ### Useful Properties​
You will probably use these properties most often:
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub LayoutTransformControl.cs
`LayoutTransformControl.cs` - Useful Properties
- More Information
# Layout Controls | Avalonia Docs
- Reference
- Controls Reference
- Layout Controls
## Layout Controls
Layout controls allow you to use UI Composition to arrange your UI in a variety of ways. Some allow just one child control, while others can have multiple child controls and follow specific rules for arranging them.
To review the concepts behind UI Composition, see here.
# Label | Avalonia Docs
- Reference
- Controls Reference
- Label
## Label
A text label control that does not receive the focus, but transfers it to a defined target control. This behaviour occurs on pointer click or when an access key is pressed in combination with the Alt key.
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Label.cs
`Label.cs` - More Information
# ItemsRepeater | Avalonia Docs
- Reference
- Controls Reference
- ItemsRepeater
## ItemsRepeater
The ItemsRepeater can display repeating data from a bound data source. It has both a layout template and a data template.
`ItemsRepeater` The items repeater is a port of the UWP ItemsRepeater control. For further information see here.
`ItemsRepeater` The ItemsRepeater was moved inside an additional Avalonia UI package. To use the ItemsRepeater in your project, you must reference the Avalonia.Controls.ItemsRepeater NuGet package. Check this PR for additional information.
`ItemsRepeater` `ItemsRepeater` The default layout template is a vertical stack layout, so that items appear in a vertical list.
### Example​
This example binds an observable collection of crockery items to an items repeater control, where some custom layout and formatting for each item is provided by the data template:
```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5">List of crockery:</TextBlock> <ItemsRepeater ItemsSource="{Binding CrockeryList}" >  <ItemsRepeater.ItemTemplate>  <DataTemplate>   <Border Margin="0,10,0,0"     CornerRadius="5"     BorderBrush="Blue" BorderThickness="1"     Padding="5">    <StackPanel Orientation="Horizontal">     <TextBlock Text="{Binding Title}"/>     <TextBlock Margin="5 0" FontWeight="Bold"            Text="{Binding Number}"/>    </StackPanel>   </Border>  </DataTemplate>  </ItemsRepeater.ItemTemplate>  </ItemsRepeater></StackPanel>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Crockery> CrockeryList { get; set; }        public MainWindowViewModel()    {      CrockeryList = new ObservableCollection<Crockery>(new List<Crockery>      {        new Crockery("dinner plate", 12),        new Crockery("side plate", 12),        new Crockery("breakfast bowl", 6),        new Crockery("cup", 10),        new Crockery("saucer", 10),        new Crockery("mug", 6),        new Crockery("milk jug", 1)      });      }  }}
```
```bash
public class Crockery{  public string Title { get; set; }  public int Number{ get; set; }  public Crockery(string title, int number)  {    Title = title;    Number = number;  }}
```
By default, an items repeater will render the items in a vertical stack layout. You can display the items horizontally by overriding this using a <ItemsRepeater.Layout> element, which must contain a stack layout. For example:
`<ItemsRepeater.Layout>` ```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5">List of crockery:</TextBlock> <ScrollViewer HorizontalScrollBarVisibility="Auto">  <ItemsRepeater ItemsSource="{Binding CrockeryList}" Margin="0 20">   <ItemsRepeater.Layout>    <StackLayout Spacing="40"      Orientation="Horizontal" />   </ItemsRepeater.Layout>   <ItemsRepeater.ItemTemplate>    <DataTemplate>     <Border Margin="0,10,0,0"       CornerRadius="5"       BorderBrush="Blue" BorderThickness="1"       Padding="5">      <StackPanel Orientation="Horizontal">       <TextBlock Text="{Binding Title}"/>       <TextBlock Margin="5 0" FontWeight="Bold"              Text="{Binding Number}"/>      </StackPanel>     </Border>    </DataTemplate>   </ItemsRepeater.ItemTemplate>  </ItemsRepeater> </ScrollViewer></StackPanel>
```
The items display horizontally, and those too far to the right would be hidden if it were not for the scroll viewer element added around the items repeater.
![](https://docs.avaloniaui.net/assets/images/itemsrepeater-horizontal-45aa36df3b618a9e6057b7ce5d1e88e0.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ItemsRepeater.cs
`ItemsRepeater.cs` - Example
- More Information
# NumericUpDown | Avalonia Docs
- Reference
- Controls Reference
- NumericUpDown
## NumericUpDown
The NumericUpDown is an editable numeric input with up and down spinner buttons attached. Non-numeric characters are ignored in the input. The value can also be changed by clicking the buttons, or by using the keyboard arrow keys. The mouse wheel (if present) will also change the value.
`NumericUpDown` ### Useful Properties​
You will probably use these properties most often:
`Value` `Increment` `Minimum` `Maximum` `FormatString` `ButtonSpinnerLocation` `AllowSpin` `ShowButtonSpinner` ### Examples​
This is a basic example of a numeric up-down control. There are no limits to the value here:
```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5">Number of items:</TextBlock> <NumericUpDown Value="10" /></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/numericupdown-basic-9a22295888cad28d0ef8a9753a2512a8.gif)
The value and other properties are nullable decimals; so you can create a custom decimal increment/decrement and range if you need to.
Remember to specify a FormatString property when you create a custom decimal increment and range.
`FormatString` For example:
```bash
<StackPanel Margin="20">  <TextBlock Margin="0 5">Opacity:</TextBlock> <NumericUpDown Value="0.5" Increment="0.05"    FormatString="0.00"   Minimum="0" Maximum="1"/></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/numericupdown-format-string-98d3d55ae015955b00cb8fe02081a50f.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub NumericUpDown.cs
`NumericUpDown.cs` - Useful Properties
- Examples
- More Information
# TransitioningContentControl | Avalonia Docs
- Reference
- Controls Reference
- TransitioningContentControl
## TransitioningContentControl
The TransitioningContentControl can use a page transition to animate a content change on an inner control.
`TransitioningContentControl` You can use this control to display a collection of different images in a slideshow.
### Useful Properties​
You will probably use these properties most often:
`Content` `TransitioningContentControl. ContentTemplate` `TransitioningContentControl. PageTransition` ### Example​
In this example, the view model contains a collection of different images to show them in a slideshow. The following XAML will use the default page transition to change the image (in the data template) whenever the bound SelectedImage property changes:
`SelectedImage` ```bash
<TransitioningContentControl Content="{Binding SelectedImage}" >  <TransitioningContentControl.ContentTemplate>    <DataTemplate DataType="Bitmap">      <Image Source="{Binding}" />    </DataTemplate>  </TransitioningContentControl.ContentTemplate></TransitioningContentControl>
```
![](https://docs.avaloniaui.net/assets/images/transitioningcontentcontrol-fade-a8e3970b2e5d152cd81c1e24c75aa22f.webp)
In this example, a different page transition has been specified to slide the images horizontally:
```bash
<TransitioningContentControl Content="{Binding SelectedImage}" >  <TransitioningContentControl.PageTransition>    <PageSlide Orientation="Horizontal" Duration="0:00:00.500" />  </TransitioningContentControl.PageTransition>  <TransitioningContentControl.ContentTemplate>    <DataTemplate DataType="Bitmap">      <Image Source="{Binding}" />    </DataTemplate>  </TransitioningContentControl.ContentTemplate></TransitioningContentControl>
```
![](https://docs.avaloniaui.net/assets/images/transitioningcontentcontrol-slide-035dcf9cb28f0f2603b427b285048544.webp)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TransitioningContentControl.cs
`TransitioningContentControl.cs` - Useful Properties
- Example
- More Information
# ToolTip | Avalonia Docs
- Reference
- Controls Reference
- ToolTip
## ToolTip
The ToolTip is a popup that shows its content when the user hovers over the 'host' control to which it is attached.
`ToolTip` ### Useful Properties​
You will probably use these properties most often:
`ToolTip.Tip` `ToolTip.Placement` `ToolTip.HorizontalOffset` `ToolTip.VerticalOffset` `ToolTip.ShowDelay` ### Examples​
This is a simple text-based tooltip, using default values for the placement and delay properties; this rectangle is placed in a window with larger dimensions:
```bash
<Rectangle Fill="Aqua" Height="200" Width="400"      ToolTip.Tip="This is a rectangle" />
```
![](https://docs.avaloniaui.net/assets/images/tooltip-text-hover-d33971ee4df54e46878f0da7fa3c5960.gif)
To provide a richer presentation for a tooltip, use a <ToolTip.Tip> element. For example:
`<ToolTip.Tip>` ```bash
<Rectangle Fill="Aqua" Height="200" Width="400"  ToolTip.Placement="Bottom">  <ToolTip.Tip>   <StackPanel>    <TextBlock FontSize="16">Rectangle</TextBlock>    <TextBlock>Some explanation here.</TextBlock>   </StackPanel>  </ToolTip.Tip></Rectangle>
```
![](https://docs.avaloniaui.net/assets/images/tooltip-content-hover-7705f1c4797bfc35678fe0c83b8b7201.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ToolTip.cs
`ToolTip.cs` - Useful Properties
- Examples
- More Information
# TimePicker | Avalonia Docs
- Reference
- Controls Reference
- TimePicker
## TimePicker
The TimePicker has two or three 'spinner' controls to allow the user to pick a time value. The time picker can work in 24 or 12 hour formats. The picker controls display when the control is clicked.
`TimePicker` ### Useful Properties​
You will probably use these properties most often:
`ClockIdentifier` `MinuteIncrement` `SelectedTime` ### Example​
This example shows how to create a time picker for the 24 hour clock, with 20 minute time slots:
```bash
<StackPanel Margin="20" Spacing="4"> <Label Content="Please choose your time:"/> <TimePicker ClockIdentifier="24HourClock"              MinuteIncrement="20"/></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/timepicker-d65e321e074d8ebc9b05661d2fe2e91c.gif)
### Initializing the Time​
You can set the time value as an attribute in XAML. Use a string in the form Hh:Mm where Hh is hours and can be between 0 and 23 and Mm is minutes and can be between 0 and 59.
```bash
<TimePicker SelectedTime="09:15"/>
```
If you need to write code-behind, it can look like this:
```bash
TimePicker timePicker = new TimePicker{  SelectedTime = new TimeSpan(9, 15, 0) // Seconds are ignored.};
```
You can clear the display by resetting the selected time to null.
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TimePicker.cs
`TimePicker.cs` - Useful Properties
- Example
- Initializing the Time
- More Information
# TextBox | Avalonia Docs
- Reference
- Controls Reference
- TextBox
## TextBox
The TextBox presents an area for typed (keyboard) input. It can be for a single or multiple lines of input.
`TextBox` ### Useful Properties​
You will probably use these properties most often:
`Text` `PasswordChar` `Watermark` `AcceptsReturn` `TextWrapping` ### Example​
This example has a basic one line text box, a password box, and a text-wrapping multiline text box:
```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5" >Name:</TextBlock> <TextBox Watermark="Enter your name"/> <TextBlock Margin="0 5" >Password:</TextBlock> <TextBox PasswordChar="*" Watermark="Enter your password"/> <TextBlock Margin="0 15 0 5">Notes:</TextBlock> <TextBox Height="100" AcceptsReturn="True" TextWrapping="Wrap"/></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/textbox-entry-6e655cee770e2366cc84cd2923536397.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TextBox.cs
- Useful Properties
- Example
- More Information
# TextBlock | Avalonia Docs
- Reference
- Controls Reference
- TextBlock
## TextBlock
The TextBlock is a read-only label for the display of text. It can display multiple lines, and features full control over the font used.
`TextBlock` ### Useful Properties​
You will probably use these properties most often:
`Bold` `Italic` `Underline` `Strikethrough` `Baseline` `Overline` `xml:space="preserve"` `TextBlock` ### Example​
This example demonstrates using multiple TextBlock controls to show a heading, single line containing extra space, and multi-line displays.
`TextBlock` ```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5" FontSize="18" FontWeight="Bold">Heading</TextBlock> <TextBlock Margin="0 5" FontStyle="Italic" xml:space="preserve">This is a single line.</TextBlock> <TextBlock Margin="0 5" xml:space="preserve">This is a multi-line displaythat has returns in it.The text block respects the line breaksas set out in XAML.</TextBlock></StackPanel>
```
The styling works in the preview pane:
### Inlines​
Text inlines allow diverse formatting of text and controls inside of a single TextBlock. While TextBlock.Text is routinely used to display a single uniformly formatted text, its child Content allows for a collection of inlines.
`TextBlock` `TextBlock.Text` `Content` #### Run​
The Run inline represents a contiguous run of uniformly formatted text.
`Run` ```bash
<Style Selector="Run.activity">	<Setter Property="Foreground" Value="#C469EE" />	<Setter Property="FontStyle" Value="Italic" />	<Setter Property="TextDecorations" Value="Underline" /></Style><TextBlock>	<Run Text="Your name is" />	<Run FontSize="24" FontWeight="Bold" Foreground="Orange" Text="{Binding Name}" />	<Run Text="and your favorite activity is" />	<Run Classes="activity" Text="{Binding Activity}" /></TextBlock>
```
#### LineBreak​
The LineBreak inline forces a line break.
`LineBreak` ```bash
<TextBlock>  This is the first line and<LineBreak />here comes the second</TextBlock>
```
#### Span​
The Span inline allows grouping of inlines, including non-text inlines. While Span can apply its own text formatting, there are a few predefined formatting inlines derived from Span: Bold, Italic, and Underline. Users may also derive from Span to create their own formatting instead of using styles.
`Span` `Span` `Span` `Bold` `Italic` `Underline` `Span` ```bash
<TextBlock>	This text is <Span Foreground="Green"> green with <Bold>bold sections,</Bold>	<Italic>italic <Span Foreground="Red">red</Span> sections,</Italic>	some	<Run FontSize="24"> enlarged font runs,</Run>	and</Span>	back to the original formatting</TextBlock>
```
#### InlineUIContainer​
The InlineUIContainer allows any Control to be included as an inline.
`InlineUIContainer` `Control` ```bash
<TextBlock ClipToBounds="False" FontSize="32" TextWrapping="Wrap">  🚀 This <Span BaselineAlignment="TextTop">example</Span> shows the <Bold>power</Bold> of  <InlineUIContainer BaselineAlignment="Baseline">    <Image Width="32" Height="32" VerticalAlignment="Top" Source="/Assets/avalonia-logo.ico" />  </InlineUIContainer>  in creating rich text displays with  <InlineUIContainer>    <Button Padding="0,8,0,0">      <TextBlock ClipToBounds="False" FontSize="24" Text="👍👍🏼👍🏽👍🏾👍🏿" />    </Button>  </InlineUIContainer>  inline controls 📈</TextBlock>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TextBlock.cs
`TextBlock.cs` - Useful Properties
- Example
- InlinesRunLineBreakSpanInlineUIContainer
- Run
- LineBreak
- Span
- InlineUIContainer
- More Information
- Run
- LineBreak
- Span
- InlineUIContainer
# Text Controls | Avalonia Docs
- Reference
- Controls Reference
- Text Controls
## Text Controls
These controls are for displaying and editing text:
# SelectableTextBlock | Avalonia Docs
- Reference
- Controls Reference
- SelectableTextBlock
## SelectableTextBlock
The SelectableTextBlock block is a label for the display of text that allows selecting and copying of text. It can display multiple lines, and features full control over the font used.
`SelectableTextBlock` ### Useful Properties​
You will probably use these properties most often:
`Bold` `Italic` `Underline` `Strikethrough` `Baseline` `Overline` `xml:space="preserve"` ### Example​
This example shows a text block used as a heading, single line and multi-line displays.
```bash
<StackPanel Margin="20"> <SelectableTextBlock Margin="0 5" FontSize="18" FontWeight="Bold" >Heading</SelectableTextBlock> <SelectableTextBlock Margin="0 5" FontStyle="Italic" xml:space="preserve" SelectionBrush="Red">This is a single line.</SelectableTextBlock> <SelectableTextBlock Margin="0 5" xml:space="preserve" SelectionStart="3" SelectionEnd="13">This is a multi-line display  that has returns in it.  The text block respects the line breaks  as set out in XAML.</SelectableTextBlock></StackPanel>
```
The styling works in the preview pane:
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub SelectableTextBlock.cs
`SelectableTextBlock.cs` - Useful Properties
- Example
- More Information
# ScrollViewer | Avalonia Docs
- Reference
- Controls Reference
- ScrollViewer
## ScrollViewer
The ScrollViewer control can have content that is bigger than its content zone, and will provide scroll bars to move hidden content into view.
`ScrollViewer` A ScrollViewer cannot be contained in a control that has infinite height or width (depending on scrolling direction) such as a StackPanel. To avoid it, you can either set fixed Height/Width or MaxHeight/MaxWidth or choose another container panel.
`ScrollViewer` `StackPanel` ### Useful Properties​
You will probably use these properties most often:
`AllowAutoHide` `ScrollViewer` `IsScrollChainingEnabled` ### Scroll Chaining​
If you have a control that can itself scroll (see list below) nested inside a scroll viewer, and the user hits a limit on the control, this property sets whether the outer scroll viewer should continue scrolling or not. You enable or disable this behaviour with an attached property on the inner control, using the format:
ScrollViewer.IsScrollChainingEnabled=[true|false]
`ScrollViewer.IsScrollChainingEnabled=[true|false]` This attached property is available on these controls:
- Scroll Viewer
- Data Grid
- List Box
- Text Box
- Tree View
### Example​
This example creates a stack panel that is bigger than the border it is inside. The scroll viewer automatically creates a vertical scroll bar.
```bash
<Border Background="AliceBlue" Width="300" Height="300"> <ScrollViewer>  <StackPanel>   <TextBlock FontSize="22" Height="100" Background="LightBlue">Block 1</TextBlock>   <TextBlock FontSize="22" Height="100">Block 2</TextBlock>   <TextBlock FontSize="22" Height="100" Background="LightBlue">Block 3</TextBlock>   <TextBlock FontSize="22" Height="100">Block 4</TextBlock>   <TextBlock FontSize="22" Height="100" Background="LightBlue">Block 5</TextBlock>  </StackPanel> </ScrollViewer></Border>
```
![](https://docs.avaloniaui.net/assets/images/scrollviewer-a37781b2a923f2125b9eba8396a60eaa.gif)
### More Information​
For the complete API documentation, see here.
View the source code on GitHub ScrollViewer.cs
`ScrollViewer.cs` - Useful Properties
- Scroll Chaining
- Example
- More Information
# ScrollBar | Avalonia Docs
- Reference
- Controls Reference
- ScrollBar
## ScrollBar
A ScrollBar control can be displayed in a horizontal or vertical orientation. The default value (double) range for the scroll bar is 0-100.
`ScrollBar` You can configure the range and how the value changes (small and large steps). Small steps can be controlled by the keyboard arrow keys, and large steps by mouse clicks in the scroll bar track, or by the page-up and page-down keys.
### Useful Properties​
You will probably use these properties most often:
`Orientation` `VerticalAlignment` `HorizontalAlignment` To create a meaningful layout, you will need to use corresponding orientation and alignment properties. For example, a vertical orientation matches a horizontal alignment.
### Example​
```bash
<Panel> <Border Background="AliceBlue">  <ScrollBar Visibility="Auto"       HorizontalAlignment="Left"       Scroll="ScrollHandler"></ScrollBar> </Border> <TextBlock Name="valueText" Margin="60">0</TextBlock></Panel>
```
```bash
using Avalonia.Controls;using Avalonia.Controls.Primitives;namespace AvaloniaControls.Views{  public partial class MainWindow : Window  {    public MainWindow()    {      InitializeComponent();    }    public void ScrollHandler(object source, ScrollEventArgs args)    {      valueText.Text = args.NewValue.ToString();    }  }}
```
With the example code-behind, the text block displays the value of the scrollbar.
![](https://docs.avaloniaui.net/assets/images/scrollbar-2ded37f48e37fe5a958545fe9421e150.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ScrollBar.cs
`ScrollBar.cs` - Useful Properties
- Example
- More Information
# Separator | Avalonia Docs
- Reference
- Controls Reference
- Separator
## Separator
The Separator control is used to provide visual separators within a Menu control.
`Separator` `Menu` #### Reference​
Separator
#### Source code​
Separator.cs
#### Related Controls​
Menu
- Reference
- Source code
- Related Controls
# Slider | Avalonia Docs
- Reference
- Controls Reference
- Slider
## Slider
The slider control presents its numerical value as the relative position of a slider button along the length of a track. The position is relative to maximum and minimum values.
Drag interaction on the slider button can alter the value between the maximum and minimum values. Keyboard and click interactions can also nudge the value.
### Useful Properties​
You will probably use these properties most often:
### Example​
In this example the slider value is displayed in the text block below, using binding to a control.
To review how to bind one control to another, see the guide here.
Here the maximum and minimum values are default (0 and 100 respectively).
```bash
<StackPanel Margin="20"> <TextBlock Text="{Binding #slider.Value}"        HorizontalAlignment="Center"/> <Slider x:Name="slider" /></StackPanel>
```
The slider looks like this on Windows:
![](https://docs.avaloniaui.net/assets/images/slider-1320aba115fea34426c896c1469d2a39.gif)
### Binding to TextBox​
In this example, the slider value is bound to the text box above using binding to the control.
#### Views​
```bash
<StackPanel> <TextBlock Text="Damage: " /> <TextBox Text="{Binding Damage}" /> <TextBlock Text="MaxDamage: " /> <TextBox Text="{Binding MaxDamage}" /> <Slider Maximum="{Binding MaxDamage}" Value="{Binding Damage}" /> <Button Command="{Binding UnlimitedDamage}" Content="∞" /></StackPanel>
```
#### ViewModels​
- You can choose ReactiveUI or CommunityToolkit when creating a project.
- The ViewModel code will change depending on which one you select.
- It doesn't matter which you choose, but here i will only detail how to binding using ReactiveUI.
```bash
using ReactiveUI;using System.Windows.Input;public class MainViewModel : ViewModelBase{  private int _damage;  public int Damage  {    get => _damage;    set => this.RaiseAndSetIfChanged(ref _damage, value);  }  private int _maxDamage;  public int MaxDamage  {    get => _maxDamage;    set => this.RaiseAndSetIfChanged(ref _maxDamage, value);  }
```
- using ReactiveUI.Fody.Helpers NOTE: Fody.Helpers is not required (optional).
On how to add a nuget package, you can follow steps from the NuGet page or Visual Studio, Rider documentation.
```bash
using ReactiveUI.Fody.Helpers;public class MainViewModel : ViewModelBase{  [Reactive]  public int Damage { get; set; }  [Reactive]  public int MaxDamage { get; set; }
```
- In the above configuration (i.e. when a change notification is bound between the Views and the ViewModels) can the values ​​in the view be updated seemless.
- You can also values ​​are updated in ViewModels.:
```bash
public ICommand UnlimitedDamage { get; }  public MainViewModel()  {    MaxDamage = 9999;    UnlimitedDamage = ReactiveCommand.Create(      () => Damage = MaxDamage = 0xFFFF);  }
```
![](https://docs.avaloniaui.net/assets/images/slider-max-value-af0708462004708b42c2dabec8eb0bda.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Slider.cs
`Slider.cs` - Useful Properties
- Example
- Binding to TextBoxViewsViewModels
- Views
- ViewModels
- More Information
- Views
- ViewModels
# ReactiveUI | Avalonia Docs
- Deep Dives
- ReactiveUI
## ReactiveUI
ReactiveUI is used in our examples, but it's not required. Avalonia supports any MVVM framework or your own custom solutions.
These pages explain how Avalonia UI uses a version of the open-source ReactiveUI framework to make it easier to implement the MVVM pattern in your application.
ReactiveUI is an advanced, composable, functional reactive model-view-viewmodel (MVVM) framework for all .NET platforms. It was inspired by the functional reactive programming paradigm.
For a full technical background on functional reactive programming, see the Wikipedia article here.
Avalonia UI ships with its own fork of ReactiveUI in the Avalonia.ReactiveUI NuGet package.
`Avalonia.ReactiveUI` To use ReactiveUI and the MVVM pattern in your Avalonia UI application, add the package to your project using the NuGet package manager (as above), or execute the following CLI command:
```bash
dotnet add package Avalonia.ReactiveUI
```
For detailed information about ReactiveUI itself, see the website https://reactiveui.net/
For more background about the MVVM pattern, see the Microsoft article here.
The package includes helpers specifically for Avalonia UI to handle the ReactiveUI tasks of view model-based routing, view activation and scheduling. (see the above reference for full details of these tasks).
If you start your application from the Avalonia MVVM Application solution template; then you will already have the ReactiveUI package installed and configured.
### Configure to Use ReactiveUI​
Having installed the NuGet package, you must configure the application Program class to use it. Check that you call the UseReactiveUI()method in the AppBuilder code.
`Program` `UseReactiveUI()` `AppBuilder` For example, if you use the Avalonia MVVM Application solution template, it will automatically add the NuGet package, and then add the code:
```bash
internal class Program{  // Initialization code. Don't use any Avalonia, third-party APIs or any  // SynchronizationContext-reliant code before AppMain is called: things aren't initialized  // yet and stuff might break.  [STAThread]  public static void Main(string[] args) => BuildAvaloniaApp()    .StartWithClassicDesktopLifetime(args);  // Avalonia configuration, don't remove; also used by visual designer.  public static AppBuilder BuildAvaloniaApp()    => AppBuilder.Configure<App>()      .UsePlatformDetect()      .LogToTrace()      .UseReactiveUI();}
```
In the following pages, you will learn how ReactiveUI works with Avalonia UI to allow you to implement the following application scenarios:
- Data Binding a Reactive View Model
- View Activation
- Routing
- Data Persistence
- Binding to Sorted/Filtered Data
- Configure to Use ReactiveUI
# Markup Extensions | Avalonia Docs
- Deep Dives
- Markup Extensions
## Markup Extensions
A MarkupExtension allows code-based customization of setter logic to a target property in a convenient, reusable syntax within XAML. Curly braces are used to differentiate the usage from plain text.
`MarkupExtension` Avalonia provides the following:
`ControlTemplate` ### Compiler intrinsics​
These technically fall outside of MarkupExtensions as part of the XAML compiler, but the XAML syntax is the same.
`MarkupExtension` `true` `false` `null` `System.Type` The x:True and x:False literals have use cases where the target binding property is object and you need to provide a boolean. In these scenarios that lack type information, providing "True" remains a string.
`x:True` `x:False` `object` `string` ```bash
<Button Command="{Binding SetStateCommand}" CommandParameter="{x:True}" />
```
### Creating MarkupExtensions​
Derive from MarkupExtension or add one of the following signatures which are supported via duck-typing:
`MarkupExtension` ```bash
T ProvideValue();T ProvideValue(IServiceProvider provider);object ProvideValue();object ProvideValue(IServiceProvider provider);
```
When strong types are used instead of object, you will receive compile-time errors when there is a mismatch in the XAML use of constructor parameters, properties, or the return value in ProvideValue. When returning object, the actual type returned must match the target property's type else an InvalidCastException is thrown at runtime.
`object` `ProvideValue` `object` `InvalidCastException` #### Receiving Literal Parameters​
When parameters are required, use a constructor to receive each parameter in order.
For optional or unordered parameters, use properties instead. Mix and matching with multiple constructors is allowed, including parameterless ones.
```bash
public class MultiplyLiteral{  private readonly double _first;  private readonly double _second;    public double? Third { get; set; }  public MultiplyLiteral(double first, double second)  {    _first = first;    _second = second;  }  public double ProvideValue(IServiceProvider provider)  {    return First * Second * Third ?? 1;  }}
```
```bash
<TextBlock Text="This has FontSize=40" FontSize="{namespace:MultiplyLiteral 10, 8, Third=0.5}" />
```
#### Receiving Parameters From Bindings​
A common scenario is wanting to transform data coming in from a binding and updating the target property. When all parameters come from bindings, this is somewhat straightforward by creating a MultiBinding with an IMultiValueConverter. In the sample below, MultiplyBinding requires two bound parameters. If a mix of literal and bound parameters is necessary, creating an IMultiValueConverter would allow for passing of literals as constructor or init parameters. BindingBase allows for both CompiledBinding and ReflectionBinding to be used, but does not allow literals.
`MultiBinding` `IMultiValueConverter` `MultiplyBinding` `IMultiValueConverter` `init` `BindingBase` `CompiledBinding` `ReflectionBinding` ```bash
public class MultiplyBinding{  private readonly BindingBase _first;  private readonly BindingBase _second;  public MultiplyBinding(BindingBase first, BindingBase second)  {    _first = first;    _second = second;  }  public object ProvideValue()  {    var mb = new MultiBinding()    {      Bindings = new[] { _first, _second },      Converter = new FuncMultiValueConverter<double, double>(doubles => doubles.Aggregate(1d, (x, y) => x * y))    };    return mb;  }}
```
```bash
<TextBlock FontSize="{local:MultiplyBinding {Binding Multiplier}, {Binding Multiplicand}}"      Text="MarkupExtension with Bindings!" />
```
An alternate approach is to return an IObservable<T>.ToBinding() instead.
`IObservable<T>.ToBinding()` #### Returning Parameters​
To make a MarkupExtension compatible with multiple target property types, return an object and handle each supported type individually.
`MarkupExtension` `object` ```bash
public object ProvideValue(IServiceProvider provider){  var target = (IProvideValueTarget)provider.GetService(typeof(IProvideValueTarget))!;  var targetProperty = target.TargetProperty as AvaloniaProperty;  var targetType = targetProperty?.PropertyType;  double result = First * Second * (Third ?? 1);  if (targetType == typeof(double))    return result;  else if (targetType == typeof(float))    return (float)result;  else if (targetType == typeof(int))    return (int)result;  else    throw new NotSupportedException();}
```
Constructors can also receive parameter types using the object approach, but compile-time errors similarly turn into runtime exceptions.
`object` #### MarkupExtension Property Attributes​
- [ConstructorArgument] - Associated property may be initialized by a constructor parameter and should be ignored for XAML serialization if the constructor is used.
- [MarkupExtensionOption], [MarkupExtensionDefaultOption] - Used with ShouldProvideOption, check OnPlatform and OnFormFactor source for an example.
`[ConstructorArgument]` `[MarkupExtensionOption]` `[MarkupExtensionDefaultOption]` `ShouldProvideOption` `OnPlatform` `OnFormFactor` - Compiler intrinsics
- Creating MarkupExtensionsReceiving Literal ParametersReceiving Parameters From BindingsReturning ParametersMarkupExtension Property Attributes
- Receiving Literal Parameters
- Receiving Parameters From Bindings
- Returning Parameters
- MarkupExtension Property Attributes
- Receiving Literal Parameters
- Receiving Parameters From Bindings
- Returning Parameters
- MarkupExtension Property Attributes
# How To Use Resources | Avalonia Docs
- How-To Guides
- Styles and Resources
- How To Use Resources
## 👉 How To Use Resources
You will often need to standardise graphical fundamentals such as (but not limited to) brushes and colors in your applications. You can define these as resources at various levels in your Avalonia UI application, as well as in files that can be included as required.
Resources are always defined inside a resource dictionary. This means that each resource has a key attribute.
The level of a resource dictionary defines the scope of the resources in it: resources are available in the file where they are defined, and below. So you can tailor the scope of resources by choosing where to locate a resource dictionary.
### Declaring Resources​
For example, you may want brush colors to be standardized across the whole application. In this case you can declare a resource dictionary in the application XAML App.axaml file, like this
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.App"> <Application.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </Application.Resources></Application>
```
Alternatively, you may want a set of resources to apply only to a specific window or user control. In this case you will define a resource dictionary in the window or user control file. For example:
```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.MyUserControl"> <UserControl.Resources>  <SolidColorBrush x:Key="Warning">LightYellow</SolidColorBrush> </UserControl.Resources></UserControl>
```
In fact you can define resources at control level if required:
```bash
<Window xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.MainWindow"> <StackPanel>  <StackPanel.Resources>   <SolidColorBrush x:Key="Warning">PaleGoldenRod</SolidColorBrush>  </StackPanel.Resources> </StackPanel></Window>
```
You can also declare resources to be specific to a style.
```bash
<Style Selector="TextBlock.warning"> <Style.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </Style.Resources> <Setter ... /></Style>
```
Keep in mind, this resource is not visible outside of the this specific style block, meaning it won't make every TextBlock with a "warning" class aware of this resource outside of the Style block.
It is also possible to define resources for specific theme variants: Dark, Light or custom. From the example below, BackgroundBrush and ForegroundBrush will have different values depending on the current theme variant set by the system or application. For more information about theme variants please read Theme Variants page.
`BackgroundBrush` `ForegroundBrush` ```bash
<ResourceDictionary>  <ResourceDictionary.ThemeDictionaries>    <ResourceDictionary x:Key='Light'>      <SolidColorBrush x:Key='BackgroundBrush'>White</SolidColorBrush>      <SolidColorBrush x:Key='ForegroundBrush'>Black</SolidColorBrush>    </ResourceDictionary>    <ResourceDictionary x:Key='Dark'>      <SolidColorBrush x:Key='BackgroundBrush'>Black</SolidColorBrush>      <SolidColorBrush x:Key='ForegroundBrush'>White</SolidColorBrush>    </ResourceDictionary>  </ResourceDictionary.ThemeDictionaries></ResourceDictionary>
```
### Resource Dictionary Files​
You can improve the organisation of your Avalonia UI application project by defining resource dictionaries in their own files. This makes resource definitions easy to locate and maintain.
Resources located in a resource dictionary file are accessible to the entire application.
To add a resource dictionary file, follow this procedure:
- Right-click your project at the location where you want the new file created.
- Click Add, then New Item.
- Click Avalonia in the list on the left:
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (8) (1) (2).png)
- Click Resource Dictionary (Avalonia).
- Type the file name you want to use.
- Click Add.
After the resource file is created you have to correctly include it into your application. See Include and Merge Resources section.
You can now add the resources you want to define in the position indicated. It looks like this:
```bash
<ResourceDictionary xmlns="https://github.com/avaloniaui"          xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <!-- Add Resources Here --></ResourceDictionary>
```
### Using Resources​
You can use a resource from a resources dictionary that is in scope using the {DynamicResource} mark-up extension.
`{DynamicResource}` For example, to use a resource directly on the background attribute of a border element, use the following XAML :
```bash
<Border Background="{DynamicResource Warning}"> Look out!</Border>
```
#### Static Resource​
Alternatively you can choose to use the StaticResource mark-up extension. For example:
`StaticResource` ```bash
<Border Background="{StaticResource Warning}"> Look out!</Border>
```
A static resource is different in that it will not respond to changes in the resource made in code (at runtime). Once loaded a static cannot be altered.
The benefit of using a static resource is that it has less work to do so it will be slightly faster to load, and it uses slightly less memory.
### Resource Priority​
Avalonia UI resolves what resource to use by searching upwards in the logical control tree from the level of a DynamicResource or StaticResource mark-up, looking for the resource key.
`DynamicResource` `StaticResource` This means that resources with the same key have priority based on their proximity to the resource mark-up being resolved. Resource definitions further up the logical control tree are therefore effectively 'overridden' by those that are closer. For example, consider this XAML:
```bash
<UserControl ... > <UserControl.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </UserControl.Resources> <StackPanel>  <StackPanel.Resources>   <SolidColorBrush x:Key="Warning">Orange</SolidColorBrush>  </StackPanel.Resources>  <Border Background="{DynamicResource Warning}">   Look out!  </Border> </StackPanel></UserControl>
```
Here the border control is using the resource with the key 'Warning'. This is defined twice - once at the level of the enclosing stack panel, and again at user control level. Avalonia UI will determine that the border background should be be orange because its parent stack panel is first in a search upwards in the logical control tree from the border itself.
### Include and Merge Resources​
Resources can be included from a resource dictionary file, and merged with the resources defined in another file (even if there are not any).
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (1) (4).png)
In case, if you would like to merge resource dictionary on the whole application level, you have to declare a resource dictionary in the in the Application.Resources section of application XAML App.axaml file, like this
```bash
<Application.Resources> <ResourceDictionary>  <ResourceDictionary.MergedDictionaries>   <MergeResourceInclude Source="/Assets/AppResources.axaml" />  </ResourceDictionary.MergedDictionaries> </ResourceDictionary></Application.Resources>
```
You can also merge resource dictionary to declare merged resources to be specific to a style.
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (1) (3).png)
This means that you can implement styles in one file, and use resources defined in another. This keeps your styling consistent, and your application solution well organised and easy to maintain.
To include the resources dictionary from a file in a styles file, add the following XAML:
```bash
<Styles.Resources>  <ResourceDictionary>   <ResourceDictionary.MergedDictionaries>    <ResourceInclude Source="/Assets/AppResources.axaml"/>   </ResourceDictionary.MergedDictionaries>  </ResourceDictionary> </Styles.Resources>
```
In the above examples, the resources file AppResources.axaml is located in the /Assets project folder. You can then define the styles using the resources, for example:
`AppResources.axaml` `/Assets` ```bash
<Style Selector="Button.btn-info">  <Setter Property="Background" Value="{StaticResource InfoColor}"/></Style>
```
Where the resource InfoColor is defined as a SolidColorBrush in the imported file.
`InfoColor` `SolidColorBrush` Note that the resource has been referenced using StaticResource because it must not change - the requirement here is to keep the styling consistent.
`StaticResource` ### Merged Resources Priority​
As you saw previously, resources are resolved by searching up the logical control tree from the point of mark-up until a resource with the requested key is found.
However the presence of styles and merged dictionaries defined at the various levels of an application, introduces extra priority rules as follows:
- Control resources -> Merged dictionaries
- Style resources -> Merged dictionaries
- App resources -> Merged dictionaries
For example, in the theoretical application below, the search for a resource used on the border control (at the bottom) will follow the order indicated in square [] brackets:
`[]` ```bash
Application |- Resources [11]   |- Merged dictionary [12]   |- Merged dictionary [13] |- Styles   |- Resources [14]     |- Merged dictionary [15]     |- Merged dictionary [16]Window |- Resources [6]   |- Merged dictionary [7] |- Styles   |- Resources [8]     |- Merged dictionary [9]     |- Merged dictionary [10] |- StackPanel   |- Resources [1]     |- Merged dictionary [2]     |- Merged dictionary [3]   |- Styles     |- Resources [4]       |- Merged dictionary [5]   |- Border
```
Starting at the border, the first resources searched are any defined in the parent (stack panel) control. After that any merged dictionaries at the same level are considered - in the sequence that they appear in the XAML.
The search then moves on to search any styles defined in the parent (stack panel) control, followed by any merged dictionaries at that level.
The search moves upwards in the logical control tree, behaving at each level in a similar manner. It finally reaches application-level resources and styles.
### Consuming Resources from code​
Avalonia provides different options to access Resources from code.
ResourceNode in the below samples can be any node that supports Resource, like Application.Current, Window, UserControl, ...
`ResourceNode` `Resource` `Application.Current` `Window` `UserControl` - ResourceNode.Resources["TheKey"]: This will directly access the underlying Dictionary. Be aware: Merged Dictionaries and parents will not be scanned.
- ResourceNode.TryGetResource: This function will try to get a specific resource and return true if successful, otherwise false. Merged dictionaries will be scanned, but it will not follow the logical tree.
- ResourceNode.TryFindResource:  This extension method will try to get a specific resource and return true if successful, otherwise false. Merged dictionaries and the logical tree will be scanned as well.
- ResourceNode.GetResourceObservable: This will return an IObservable which can be used to observe changes on the resource. For example you could bind to it.
`Dictionary` `true` `false` `true` `false` `IObservable` ```bash
// In this sample we have defined the resource in App.axaml and we want to look up the value in the MainWindow constructor.////  </Application.Resources>//     <x:String x:Key="TheKey">HelloWorld</x:String>//  </Application.Resources>public MainWindow(){  InitializeComponent();  // found1 = false | result1 = null  var found1 = this.TryGetResource("TheKey", this.ActualThemeVariant, out var result1);  // found2 = true | result2 = "Hello World"   var found2 = this.TryFindResource("TheKey", this.ActualThemeVariant, out var result2);  // Bind the resource to a TextBlock from code behind  myTextBlock.Bind(TextBlock.TextProperty, Resources.GetResourceObservable("TheKey"));  // This will update myTextBlock.Text via the bound observable  this.Resources["TheKey"] = "Hello from code behind"; }
```
- Declaring Resources
- Resource Dictionary Files
- Using ResourcesStatic Resource
- Static Resource
- Resource Priority
- Include and Merge Resources
- Merged Resources Priority
- Consuming Resources from code
- Static Resource
# How To Use Resources | Avalonia Docs
- How-To Guides
- Styles and Resources
- How To Use Resources
## 👉 How To Use Resources
You will often need to standardise graphical fundamentals such as (but not limited to) brushes and colors in your applications. You can define these as resources at various levels in your Avalonia UI application, as well as in files that can be included as required.
Resources are always defined inside a resource dictionary. This means that each resource has a key attribute.
The level of a resource dictionary defines the scope of the resources in it: resources are available in the file where they are defined, and below. So you can tailor the scope of resources by choosing where to locate a resource dictionary.
### Declaring Resources​
For example, you may want brush colors to be standardized across the whole application. In this case you can declare a resource dictionary in the application XAML App.axaml file, like this
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.App"> <Application.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </Application.Resources></Application>
```
Alternatively, you may want a set of resources to apply only to a specific window or user control. In this case you will define a resource dictionary in the window or user control file. For example:
```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.MyUserControl"> <UserControl.Resources>  <SolidColorBrush x:Key="Warning">LightYellow</SolidColorBrush> </UserControl.Resources></UserControl>
```
In fact you can define resources at control level if required:
```bash
<Window xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="MyApp.MainWindow"> <StackPanel>  <StackPanel.Resources>   <SolidColorBrush x:Key="Warning">PaleGoldenRod</SolidColorBrush>  </StackPanel.Resources> </StackPanel></Window>
```
You can also declare resources to be specific to a style.
```bash
<Style Selector="TextBlock.warning"> <Style.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </Style.Resources> <Setter ... /></Style>
```
Keep in mind, this resource is not visible outside of the this specific style block, meaning it won't make every TextBlock with a "warning" class aware of this resource outside of the Style block.
It is also possible to define resources for specific theme variants: Dark, Light or custom. From the example below, BackgroundBrush and ForegroundBrush will have different values depending on the current theme variant set by the system or application. For more information about theme variants please read Theme Variants page.
`BackgroundBrush` `ForegroundBrush` ```bash
<ResourceDictionary>  <ResourceDictionary.ThemeDictionaries>    <ResourceDictionary x:Key='Light'>      <SolidColorBrush x:Key='BackgroundBrush'>White</SolidColorBrush>      <SolidColorBrush x:Key='ForegroundBrush'>Black</SolidColorBrush>    </ResourceDictionary>    <ResourceDictionary x:Key='Dark'>      <SolidColorBrush x:Key='BackgroundBrush'>Black</SolidColorBrush>      <SolidColorBrush x:Key='ForegroundBrush'>White</SolidColorBrush>    </ResourceDictionary>  </ResourceDictionary.ThemeDictionaries></ResourceDictionary>
```
### Resource Dictionary Files​
You can improve the organisation of your Avalonia UI application project by defining resource dictionaries in their own files. This makes resource definitions easy to locate and maintain.
Resources located in a resource dictionary file are accessible to the entire application.
To add a resource dictionary file, follow this procedure:
- Right-click your project at the location where you want the new file created.
- Click Add, then New Item.
- Click Avalonia in the list on the left:
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (8) (1) (2).png)
- Click Resource Dictionary (Avalonia).
- Type the file name you want to use.
- Click Add.
After the resource file is created you have to correctly include it into your application. See Include and Merge Resources section.
You can now add the resources you want to define in the position indicated. It looks like this:
```bash
<ResourceDictionary xmlns="https://github.com/avaloniaui"          xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <!-- Add Resources Here --></ResourceDictionary>
```
### Using Resources​
You can use a resource from a resources dictionary that is in scope using the {DynamicResource} mark-up extension.
`{DynamicResource}` For example, to use a resource directly on the background attribute of a border element, use the following XAML :
```bash
<Border Background="{DynamicResource Warning}"> Look out!</Border>
```
#### Static Resource​
Alternatively you can choose to use the StaticResource mark-up extension. For example:
`StaticResource` ```bash
<Border Background="{StaticResource Warning}"> Look out!</Border>
```
A static resource is different in that it will not respond to changes in the resource made in code (at runtime). Once loaded a static cannot be altered.
The benefit of using a static resource is that it has less work to do so it will be slightly faster to load, and it uses slightly less memory.
### Resource Priority​
Avalonia UI resolves what resource to use by searching upwards in the logical control tree from the level of a DynamicResource or StaticResource mark-up, looking for the resource key.
`DynamicResource` `StaticResource` This means that resources with the same key have priority based on their proximity to the resource mark-up being resolved. Resource definitions further up the logical control tree are therefore effectively 'overridden' by those that are closer. For example, consider this XAML:
```bash
<UserControl ... > <UserControl.Resources>  <SolidColorBrush x:Key="Warning">Yellow</SolidColorBrush> </UserControl.Resources> <StackPanel>  <StackPanel.Resources>   <SolidColorBrush x:Key="Warning">Orange</SolidColorBrush>  </StackPanel.Resources>  <Border Background="{DynamicResource Warning}">   Look out!  </Border> </StackPanel></UserControl>
```
Here the border control is using the resource with the key 'Warning'. This is defined twice - once at the level of the enclosing stack panel, and again at user control level. Avalonia UI will determine that the border background should be be orange because its parent stack panel is first in a search upwards in the logical control tree from the border itself.
### Include and Merge Resources​
Resources can be included from a resource dictionary file, and merged with the resources defined in another file (even if there are not any).
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (1) (4).png)
In case, if you would like to merge resource dictionary on the whole application level, you have to declare a resource dictionary in the in the Application.Resources section of application XAML App.axaml file, like this
```bash
<Application.Resources> <ResourceDictionary>  <ResourceDictionary.MergedDictionaries>   <MergeResourceInclude Source="/Assets/AppResources.axaml" />  </ResourceDictionary.MergedDictionaries> </ResourceDictionary></Application.Resources>
```
You can also merge resource dictionary to declare merged resources to be specific to a style.
![](https://docs.avaloniaui.net/img/gitbook-import/assets/image (1) (3).png)
This means that you can implement styles in one file, and use resources defined in another. This keeps your styling consistent, and your application solution well organised and easy to maintain.
To include the resources dictionary from a file in a styles file, add the following XAML:
```bash
<Styles.Resources>  <ResourceDictionary>   <ResourceDictionary.MergedDictionaries>    <ResourceInclude Source="/Assets/AppResources.axaml"/>   </ResourceDictionary.MergedDictionaries>  </ResourceDictionary> </Styles.Resources>
```
In the above examples, the resources file AppResources.axaml is located in the /Assets project folder. You can then define the styles using the resources, for example:
`AppResources.axaml` `/Assets` ```bash
<Style Selector="Button.btn-info">  <Setter Property="Background" Value="{StaticResource InfoColor}"/></Style>
```
Where the resource InfoColor is defined as a SolidColorBrush in the imported file.
`InfoColor` `SolidColorBrush` Note that the resource has been referenced using StaticResource because it must not change - the requirement here is to keep the styling consistent.
`StaticResource` ### Merged Resources Priority​
As you saw previously, resources are resolved by searching up the logical control tree from the point of mark-up until a resource with the requested key is found.
However the presence of styles and merged dictionaries defined at the various levels of an application, introduces extra priority rules as follows:
- Control resources -> Merged dictionaries
- Style resources -> Merged dictionaries
- App resources -> Merged dictionaries
For example, in the theoretical application below, the search for a resource used on the border control (at the bottom) will follow the order indicated in square [] brackets:
`[]` ```bash
Application |- Resources [11]   |- Merged dictionary [12]   |- Merged dictionary [13] |- Styles   |- Resources [14]     |- Merged dictionary [15]     |- Merged dictionary [16]Window |- Resources [6]   |- Merged dictionary [7] |- Styles   |- Resources [8]     |- Merged dictionary [9]     |- Merged dictionary [10] |- StackPanel   |- Resources [1]     |- Merged dictionary [2]     |- Merged dictionary [3]   |- Styles     |- Resources [4]       |- Merged dictionary [5]   |- Border
```
Starting at the border, the first resources searched are any defined in the parent (stack panel) control. After that any merged dictionaries at the same level are considered - in the sequence that they appear in the XAML.
The search then moves on to search any styles defined in the parent (stack panel) control, followed by any merged dictionaries at that level.
The search moves upwards in the logical control tree, behaving at each level in a similar manner. It finally reaches application-level resources and styles.
### Consuming Resources from code​
Avalonia provides different options to access Resources from code.
ResourceNode in the below samples can be any node that supports Resource, like Application.Current, Window, UserControl, ...
`ResourceNode` `Resource` `Application.Current` `Window` `UserControl` - ResourceNode.Resources["TheKey"]: This will directly access the underlying Dictionary. Be aware: Merged Dictionaries and parents will not be scanned.
- ResourceNode.TryGetResource: This function will try to get a specific resource and return true if successful, otherwise false. Merged dictionaries will be scanned, but it will not follow the logical tree.
- ResourceNode.TryFindResource:  This extension method will try to get a specific resource and return true if successful, otherwise false. Merged dictionaries and the logical tree will be scanned as well.
- ResourceNode.GetResourceObservable: This will return an IObservable which can be used to observe changes on the resource. For example you could bind to it.
`Dictionary` `true` `false` `true` `false` `IObservable` ```bash
// In this sample we have defined the resource in App.axaml and we want to look up the value in the MainWindow constructor.////  </Application.Resources>//     <x:String x:Key="TheKey">HelloWorld</x:String>//  </Application.Resources>public MainWindow(){  InitializeComponent();  // found1 = false | result1 = null  var found1 = this.TryGetResource("TheKey", this.ActualThemeVariant, out var result1);  // found2 = true | result2 = "Hello World"   var found2 = this.TryFindResource("TheKey", this.ActualThemeVariant, out var result2);  // Bind the resource to a TextBlock from code behind  myTextBlock.Bind(TextBlock.TextProperty, Resources.GetResourceObservable("TheKey"));  // This will update myTextBlock.Text via the bound observable  this.Resources["TheKey"] = "Hello from code behind"; }
```
- Declaring Resources
- Resource Dictionary Files
- Using ResourcesStatic Resource
- Static Resource
- Resource Priority
- Include and Merge Resources
- Merged Resources Priority
- Consuming Resources from code
- Static Resource
# Compiled Bindings | Avalonia Docs
- Basics
- Data
- Data Binding
- Compiled Bindings
## Compiled Bindings
Bindings defined in the XAML are using reflection in order to find and access the requested property in your ViewModel. In Avalonia you can also use compiled bindings, which has some benefits:
`ViewModel` - If you use compiled bindings and the property you bind to is not found, you will get a compile-time error. Hence you get a much better debugging experience.
- Reflection is known to be slow (see this article on codeproject.com). Using compiled bindings can therefore improve the performance of your application.
### Enable and disable compiled bindings​
Depending on the template that was used to create the Avalonia project, compiled bindings may or may not be enabled by default. You can check this in the project file.
#### Enable and disable globally​
If you want your application to use compiled bindings globally by default, you can add
```bash
<AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
```
to your project file. You will still need to provide x:DataType for the objects you want to bind but you don't need to to set x:CompileBindings="[True|False]" for each UserControl or Window.
`x:DataType` `x:CompileBindings="[True|False]"` `UserControl` `Window` #### Enable and disable per UserControl or Window​
To enable compiled bindings, you will need to define the DataType of the object you want to bind to first. In DataTemplates there is a property DataType, for all other elements you can set it via x:DataType. Most likely you will set x:DataType in your root node, for example in a Window or an UserControl. You can also specify the DataType in the Binding directly.
`DataType` `DataTemplates` `DataType` `x:DataType` `x:DataType` `Window` `UserControl` `DataType` `Binding` You can now enable or disable compiled bindings by setting x:CompileBindings="[True|False]". All child nodes will inherit this property, so you can enable it in your root node and disable it for a specific child, if needed.
`x:CompileBindings="[True|False]"` ```bash
<!-- Set DataType and enable compiled bindings --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel"       x:CompileBindings="True">  <StackPanel>    <TextBlock Text="Last name:" />    <TextBox Text="{Binding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{Binding GivenName}" />    <TextBlock Text="E-Mail:" />    <!-- Set DataType inside the Binding-markup -->    <TextBox Text="{Binding MailAddress, DataType={x:Type vm:MyViewModel}}" />    <Button Content="Send an E-Mail"        Command="{Binding SendEmailCommand}" />  </StackPanel></UserControl>
```
### CompiledBinding-Markup​
If you don't want to enable compiled bindings for all child nodes, you can also use the CompiledBinding-markup. You still need to define the DataType, but you can omit x:CompileBindings="True".
`CompiledBinding` `DataType` `x:CompileBindings="True"` ```bash
<!-- Set DataType --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel">  <StackPanel>    <TextBlock Text="Last name:" />    <!-- use CompiledBinding markup for your binding -->    <TextBox Text="{CompiledBinding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{CompiledBinding GivenName}" />    <TextBlock Text="E-Mail:" />    <TextBox Text="{CompiledBinding MailAddress}" />    <!-- This command will use ReflectionBinding, as it's default -->    <Button Content="Send an E-Mail"        Command="{Binding SendEmailCommand}" />  </StackPanel></UserControl>
```
### ReflectionBinding-Markup​
If you have compiled bindings enabled in the root node (via x:CompileBindings="True") and you either don't want to use compiled binding at a certain position, you can use the ReflectionBinding-markup.
`x:CompileBindings="True"` `ReflectionBinding` ```bash
<!-- Set DataType --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel"       x:CompileBindings="True">  <StackPanel>    <TextBlock Text="Last name:" />    <TextBox Text="{Binding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{Binding GivenName}" />    <TextBlock Text="E-Mail:" />    <TextBox Text="{Binding MailAddress}" />    <!-- We use ReflectionBinding instead -->    <Button Content="Send an E-Mail"        Command="{ReflectionBinding SendEmailCommand}" />  </StackPanel></UserControl>
```
### Type casting​
In some cases the target type of the binding expression cannot be automatically evaluated. In such cases you must provide an explicit type cast in the binding expression.
```bash
<ItemsRepeater ItemsSource="{Binding MyItems}"><ItemsRepeater.ItemTemplate>  <DataTemplate>  <StackPanel Orientation="Horizontal">    <TextBlock Text="{Binding DisplayName}"/>    <Grid>    <Button Command="{Binding $parent[ItemsRepeater].((vm:MyUserControlViewModel)DataContext).DoItCommand}"        CommandParameter="{Binding ItemId}"/>    </Grid>  </StackPanel>  </DataTemplate></ItemsRepeater.ItemTemplate></ItemsRepeater>
```
In this case, the button command shall not be bound to the item's DataContext but to a command that is defined in the DataContextof the ItemsRepeater. The single item will be identified using a CommandParameter bound to the item's DataContext. Therefore, you must specify the type of the "parent" DataContext via cast expression ((vm:MyUserControlViewModel)DataContext).
`DataContext` `DataContext` `ItemsRepeater` `CommandParameter` `DataContext` `DataContext` `((vm:MyUserControlViewModel)DataContext)` - Enable and disable compiled bindingsEnable and disable globallyEnable and disable per UserControl or Window
- Enable and disable globally
- Enable and disable per UserControl or Window
- CompiledBinding-Markup
- ReflectionBinding-Markup
- Type casting
- Enable and disable globally
- Enable and disable per UserControl or Window
# Data Binding Syntax | Avalonia Docs
- Basics
- Data
- Data Binding
- Data Binding Syntax
## Data Binding Syntax
Avalonia supports creating data bindings in XAML and code. Data bindings in XAML are typically created with the Binding MarkupExtension described by this document. To create data bindings in code, see here.
`Binding` `MarkupExtension` ### Data Binding MarkupExtension​
The Binding MarkupExtension uses the keyword Binding in combination with optional parameters to define the data source and other options as shown by the following example:
`Binding` `MarkupExtension` `Binding` ```bash
<SomeControl SomeProperty="{Binding Path, Mode=ModeValue, StringFormat=Pattern}" />
```
`Path` `Mode` `Priority` `Source` `Path` `ElementName` `Control` `Source` `RelativeSource` `Control` `Source` `StringFormat` `Converter` `IValueConverter` `ConverterParameter` `Converter` `FallbackValue` `TargetNullValue` `UpdateSourceTrigger` These parameters must be known and set at the time of binding creation. They are CLR properties that cannot be set and updated by additional bindings.
### Data Binding Path​
The first parameter specified is usually the Path. This is the name of a property in the Source (DataContext by default) that Avalonia locates when creating the binding.
`Path` `Source` `DataContext` You can omit Path= when it is the first parameter. The following two bindings are equivalent:
`Path=` ```bash
<TextBlock Text="{Binding Name}"/><TextBlock Text="{Binding Path=Name}"/>
```
The binding path can be a single property or a subproperty chain. For example, if the data source has a Student property and the object returned by that property has a property Name, then you can bind to the student's name using syntax like this:
`Student` `Name` ```bash
<TextBlock Text="{Binding Student.Name}"/>
```
If the data source can be indexed (such as an array or list), then you can add the index to the binding path like this:
```bash
<TextBlock Text="{Binding Students[0].Name}"/>
```
### Empty Binding Path​
You can specify data bindings without a Path. This binds to the DataContext of the Control itself (where the binding is defined). These two syntaxes are equivalent:
`Path` `DataContext` `Control` ```bash
<TextBlock Text="{Binding}" /><TextBlock Text="{Binding .}" />
```
### Data Binding Mode​
You can change the direction(s) data is synchronized by specifying the Mode.
`Mode` For example:
```bash
<TextBlock Text="{Binding Name, Mode=OneTime}" />
```
The available binding modes are:
`OneWay` `TwoWay` `OneTime` `OneWayToSource` `Default` When no Mode is specified, the Default is used. For a control property that does not change value due to user interaction, the default mode is generally OneWay. For a control property that does change value due to user input, the default mode is usually TwoWay.
`Mode` `Default` `OneWay` `TwoWay` For example, the default mode for a TextBlock.Text property is OneWay, and the default mode for a TextBox.Text property is TwoWay.
`TextBlock.Text` `OneWay` `TextBox.Text` `TwoWay` ### Data Binding Sources​
The Source specifies the root object instance that the Path is relative to. By default, this is the DataContext of the containing Control. The most common scenario involves binding to another control using ElementName or RelativeSource parameters or with their shorthand syntax as part of the Path (#controlName and $parent[ControlType] respectively).
`Source` `Path` `DataContext` `Control` `ElementName` `RelativeSource` `Path` `#controlName` `$parent[ControlType]` ```bash
<TextBox Name="input" /><TextBlock Text="{Binding Text, ElementName=input}" /><TextBlock Text="{Binding #input.Text}" /><TextBlock Text="{Binding Title,   RelativeSource={RelativeSource FindAncestor, AncestorType=Window}}" /><TextBlock Text="{Binding $parent[Window].Title}" />
```
For more details on how to bind to controls, see here
### Converting Bound Values​
Bindings offer multiple approaches to convert or substitute the value supplied by a data binding into a type or value that is more appropriate for the target property.
#### String Formatting​
You can apply a pattern to a OneWay binding to format the bound source property as text via the StringFormat parameter which uses string.Format internally.
`OneWay` `StringFormat` `string.Format` The pattern index is zero-based and must be inside curly braces. When the curly braces are at the beginning of the pattern, even when also inside single quotes, they must be escaped. Escaping is done by adding an empty pair of curly braces at the front of the pattern or a backslash on each brace.
```bash
<TextBlock Text="{Binding FloatProperty, StringFormat={}{0:0.0}}" />
```
Alternatively, you can use backslashes to escape the curly brackets needed for the pattern. For example:
```bash
<TextBlock Text="{Binding FloatProperty, StringFormat=\{0:0.0\}}" />
```
However, if your pattern does not start with a zero, you do not need the escape. Also, if you have whitespace in your pattern, you must surround it with single quotes. For example:
```bash
<TextBlock Text="{Binding Animals.Count, StringFormat='I have {0} animals.'}" />
```
Notice that this means that if your pattern starts with the value that you are binding, then you do need the escape. For example:
```bash
<TextBlock Text="{Binding Animals.Count,   StringFormat='{}{0} animals live in the farm.'}" />
```
#### String Formatting with Multiple Parameters​
MultiBinding can be used to format a string that requires multiple bound parameters. The example below formats multiple numeric inputs as a single string to be displayed.
`MultiBinding` ```bash
<StackPanel Spacing="8"> <NumericUpDown x:Name="red" Minimum="0" Maximum="255" Value="0" FormatString="{}{0:0.}" Foreground="Red" /> <NumericUpDown x:Name="green" Minimum="0" Maximum="255" Value="0" FormatString="{}{0:0.}" Foreground="Green" /> <NumericUpDown x:Name="blue" Minimum="0" Maximum="255" Value="0" FormatString="{}{0:0.}" Foreground="Blue" /> <TextBlock>  <TextBlock.Text>   <MultiBinding StringFormat="(r: {0:0.}, g: {1:0.}, b: {2:0.})">    <Binding Path="Value" ElementName="red" />    <Binding Path="Value" ElementName="green" />    <Binding Path="Value" ElementName="blue" />   </MultiBinding>  </TextBlock.Text> </TextBlock></StackPanel>
```
FormatString is used internally by NumericUpDown to change how its value is displayed. Here, because RGB colors are integers, we should not display the decimal portion so 0. is supplied as a custom numeric format specifier that .NET understands.
`FormatString` `NumericUpDown` `0.` If the values for the inputs are red = 100, green = 80, and blue = 255, then the text displayed will be (r: 100, g: 80, b: 255).
`red = 100` `green = 80` `blue = 255` `(r: 100, g: 80, b: 255)` An alternative is to use an InlineCollection of Run elements each with their own single parameter binding. This allows visual customization of each segment. See the example here
`InlineCollection` `Run` #### Built-in Conversions​
Avalonia has a range of built-in data binding converters. These include:
- Null-testing converters
- Boolean operation converters
For a listing of Avalonia built-in data binding converters, see the reference here.
#### Custom Conversions​
If the built-in converters do not meet your requirements, then you can create a custom converter by implementing IValueConverter.
`IValueConverter` For guidance on how to create a custom converter, see here.
#### FallbackValue​
FallbackValue is used when the property binding cannot be made or when a converter returns AvaloniaProperty.UnsetValue.
`FallbackValue` `AvaloniaProperty.UnsetValue` A common use case is when a parent property in a subproperty binding is null. If Student is null below, the FallbackValue will be used:
`null` `Student` `null` `FallbackValue` ```bash
<TextBlock Text="{Binding Student.Name, FallbackValue=Cannot find name}"/>
```
ReflectionBinding can bind to arbitrary types without regard to compile-time safety. When the binding cannot be made, FallbackValue may be useful to substitute a value.
`ReflectionBinding` `FallbackValue` #### TargetNullValue​
When a binding to a property is successfully created and the property value is null, TargetNullValue may be used to supply a specific value.
`null` `TargetNullValue` ```bash
<StackPanel>  <NumericUpDown x:Name="number" Value="200" />  <TextBlock Text="{Binding #number.Value, TargetNullValue=Value is null}" /></StackPanel>
```
### UpdateSourceTrigger v11.1​
Controls like TextBox will synchronize their Text binding to the source property on every keystroke by default. In some use cases, this may trigger a long-running task or undesirable validation. UpdateSourceTrigger allows bindings to specify when synchronization should happen.
`TextBox` `Text` `UpdateSourceTrigger` `Default` `PropertyChanged` `PropertyChanged` `LostFocus` `Explicit` `BindingExpressionBase.UpdateSource()` ```bash
<StackPanel>  <TextBox Text="{Binding #propertyChanged.Text}" />  <TextBlock Name="propertyChanged" />  <TextBox Text="{Binding #lostFocus.Text, UpdateSourceTrigger=LostFocus}" />  <TextBlock Name="lostFocus" /></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/updatesourcetrigger-0a62ca1e7ba02043656486d2d57ccf95.gif)
- Data Binding MarkupExtension
- Data Binding Path
- Empty Binding Path
- Data Binding Mode
- Data Binding Sources
- Converting Bound ValuesString FormattingString Formatting with Multiple ParametersBuilt-in ConversionsCustom ConversionsFallbackValueTargetNullValue
- String Formatting
- String Formatting with Multiple Parameters
- Built-in Conversions
- Custom Conversions
- FallbackValue
- TargetNullValue
- UpdateSourceTrigger
- String Formatting
- String Formatting with Multiple Parameters
- Built-in Conversions
- Custom Conversions
- FallbackValue
- TargetNullValue
# TextBlock | Avalonia Docs
- Reference
- Controls Reference
- TextBlock
## TextBlock
The TextBlock is a read-only label for the display of text. It can display multiple lines, and features full control over the font used.
`TextBlock` ### Useful Properties​
You will probably use these properties most often:
`Bold` `Italic` `Underline` `Strikethrough` `Baseline` `Overline` `xml:space="preserve"` `TextBlock` ### Example​
This example demonstrates using multiple TextBlock controls to show a heading, single line containing extra space, and multi-line displays.
`TextBlock` ```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5" FontSize="18" FontWeight="Bold">Heading</TextBlock> <TextBlock Margin="0 5" FontStyle="Italic" xml:space="preserve">This is a single line.</TextBlock> <TextBlock Margin="0 5" xml:space="preserve">This is a multi-line displaythat has returns in it.The text block respects the line breaksas set out in XAML.</TextBlock></StackPanel>
```
The styling works in the preview pane:
### Inlines​
Text inlines allow diverse formatting of text and controls inside of a single TextBlock. While TextBlock.Text is routinely used to display a single uniformly formatted text, its child Content allows for a collection of inlines.
`TextBlock` `TextBlock.Text` `Content` #### Run​
The Run inline represents a contiguous run of uniformly formatted text.
`Run` ```bash
<Style Selector="Run.activity">	<Setter Property="Foreground" Value="#C469EE" />	<Setter Property="FontStyle" Value="Italic" />	<Setter Property="TextDecorations" Value="Underline" /></Style><TextBlock>	<Run Text="Your name is" />	<Run FontSize="24" FontWeight="Bold" Foreground="Orange" Text="{Binding Name}" />	<Run Text="and your favorite activity is" />	<Run Classes="activity" Text="{Binding Activity}" /></TextBlock>
```
#### LineBreak​
The LineBreak inline forces a line break.
`LineBreak` ```bash
<TextBlock>  This is the first line and<LineBreak />here comes the second</TextBlock>
```
#### Span​
The Span inline allows grouping of inlines, including non-text inlines. While Span can apply its own text formatting, there are a few predefined formatting inlines derived from Span: Bold, Italic, and Underline. Users may also derive from Span to create their own formatting instead of using styles.
`Span` `Span` `Span` `Bold` `Italic` `Underline` `Span` ```bash
<TextBlock>	This text is <Span Foreground="Green"> green with <Bold>bold sections,</Bold>	<Italic>italic <Span Foreground="Red">red</Span> sections,</Italic>	some	<Run FontSize="24"> enlarged font runs,</Run>	and</Span>	back to the original formatting</TextBlock>
```
#### InlineUIContainer​
The InlineUIContainer allows any Control to be included as an inline.
`InlineUIContainer` `Control` ```bash
<TextBlock ClipToBounds="False" FontSize="32" TextWrapping="Wrap">  🚀 This <Span BaselineAlignment="TextTop">example</Span> shows the <Bold>power</Bold> of  <InlineUIContainer BaselineAlignment="Baseline">    <Image Width="32" Height="32" VerticalAlignment="Top" Source="/Assets/avalonia-logo.ico" />  </InlineUIContainer>  in creating rich text displays with  <InlineUIContainer>    <Button Padding="0,8,0,0">      <TextBlock ClipToBounds="False" FontSize="24" Text="👍👍🏼👍🏽👍🏾👍🏿" />    </Button>  </InlineUIContainer>  inline controls 📈</TextBlock>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TextBlock.cs
`TextBlock.cs` - Useful Properties
- Example
- InlinesRunLineBreakSpanInlineUIContainer
- Run
- LineBreak
- Span
- InlineUIContainer
- More Information
- Run
- LineBreak
- Span
- InlineUIContainer
# Compiled Bindings | Avalonia Docs
- Basics
- Data
- Data Binding
- Compiled Bindings
## Compiled Bindings
Bindings defined in the XAML are using reflection in order to find and access the requested property in your ViewModel. In Avalonia you can also use compiled bindings, which has some benefits:
`ViewModel` - If you use compiled bindings and the property you bind to is not found, you will get a compile-time error. Hence you get a much better debugging experience.
- Reflection is known to be slow (see this article on codeproject.com). Using compiled bindings can therefore improve the performance of your application.
### Enable and disable compiled bindings​
Depending on the template that was used to create the Avalonia project, compiled bindings may or may not be enabled by default. You can check this in the project file.
#### Enable and disable globally​
If you want your application to use compiled bindings globally by default, you can add
```bash
<AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
```
to your project file. You will still need to provide x:DataType for the objects you want to bind but you don't need to to set x:CompileBindings="[True|False]" for each UserControl or Window.
`x:DataType` `x:CompileBindings="[True|False]"` `UserControl` `Window` #### Enable and disable per UserControl or Window​
To enable compiled bindings, you will need to define the DataType of the object you want to bind to first. In DataTemplates there is a property DataType, for all other elements you can set it via x:DataType. Most likely you will set x:DataType in your root node, for example in a Window or an UserControl. You can also specify the DataType in the Binding directly.
`DataType` `DataTemplates` `DataType` `x:DataType` `x:DataType` `Window` `UserControl` `DataType` `Binding` You can now enable or disable compiled bindings by setting x:CompileBindings="[True|False]". All child nodes will inherit this property, so you can enable it in your root node and disable it for a specific child, if needed.
`x:CompileBindings="[True|False]"` ```bash
<!-- Set DataType and enable compiled bindings --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel"       x:CompileBindings="True">  <StackPanel>    <TextBlock Text="Last name:" />    <TextBox Text="{Binding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{Binding GivenName}" />    <TextBlock Text="E-Mail:" />    <!-- Set DataType inside the Binding-markup -->    <TextBox Text="{Binding MailAddress, DataType={x:Type vm:MyViewModel}}" />    <Button Content="Send an E-Mail"        Command="{Binding SendEmailCommand}" />  </StackPanel></UserControl>
```
### CompiledBinding-Markup​
If you don't want to enable compiled bindings for all child nodes, you can also use the CompiledBinding-markup. You still need to define the DataType, but you can omit x:CompileBindings="True".
`CompiledBinding` `DataType` `x:CompileBindings="True"` ```bash
<!-- Set DataType --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel">  <StackPanel>    <TextBlock Text="Last name:" />    <!-- use CompiledBinding markup for your binding -->    <TextBox Text="{CompiledBinding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{CompiledBinding GivenName}" />    <TextBlock Text="E-Mail:" />    <TextBox Text="{CompiledBinding MailAddress}" />    <!-- This command will use ReflectionBinding, as it's default -->    <Button Content="Send an E-Mail"        Command="{Binding SendEmailCommand}" />  </StackPanel></UserControl>
```
### ReflectionBinding-Markup​
If you have compiled bindings enabled in the root node (via x:CompileBindings="True") and you either don't want to use compiled binding at a certain position, you can use the ReflectionBinding-markup.
`x:CompileBindings="True"` `ReflectionBinding` ```bash
<!-- Set DataType --><UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:vm="using:MyApp.ViewModels"       x:DataType="vm:MyViewModel"       x:CompileBindings="True">  <StackPanel>    <TextBlock Text="Last name:" />    <TextBox Text="{Binding LastName}" />    <TextBlock Text="Given name:" />    <TextBox Text="{Binding GivenName}" />    <TextBlock Text="E-Mail:" />    <TextBox Text="{Binding MailAddress}" />    <!-- We use ReflectionBinding instead -->    <Button Content="Send an E-Mail"        Command="{ReflectionBinding SendEmailCommand}" />  </StackPanel></UserControl>
```
### Type casting​
In some cases the target type of the binding expression cannot be automatically evaluated. In such cases you must provide an explicit type cast in the binding expression.
```bash
<ItemsRepeater ItemsSource="{Binding MyItems}"><ItemsRepeater.ItemTemplate>  <DataTemplate>  <StackPanel Orientation="Horizontal">    <TextBlock Text="{Binding DisplayName}"/>    <Grid>    <Button Command="{Binding $parent[ItemsRepeater].((vm:MyUserControlViewModel)DataContext).DoItCommand}"        CommandParameter="{Binding ItemId}"/>    </Grid>  </StackPanel>  </DataTemplate></ItemsRepeater.ItemTemplate></ItemsRepeater>
```
In this case, the button command shall not be bound to the item's DataContext but to a command that is defined in the DataContextof the ItemsRepeater. The single item will be identified using a CommandParameter bound to the item's DataContext. Therefore, you must specify the type of the "parent" DataContext via cast expression ((vm:MyUserControlViewModel)DataContext).
`DataContext` `DataContext` `ItemsRepeater` `CommandParameter` `DataContext` `DataContext` `((vm:MyUserControlViewModel)DataContext)` - Enable and disable compiled bindingsEnable and disable globallyEnable and disable per UserControl or Window
- Enable and disable globally
- Enable and disable per UserControl or Window
- CompiledBinding-Markup
- ReflectionBinding-Markup
- Type casting
- Enable and disable globally
- Enable and disable per UserControl or Window
# How To Create Templated Controls | Avalonia Docs
- How-To Guides
- Custom Controls
- How To Create Templated Controls
## How To Create Templated Controls
### Data Binding​
When you're creating a control template and you want to bind to the templated parent you can use:
```bash
<TextBlock Name="tb" Text="{TemplateBinding Caption}"/><!-- Which is the same as --><TextBlock Name="tb" Text="{Binding Caption, RelativeSource={RelativeSource TemplatedParent}}"/>
```
Although the two syntaxes shown here are equivalent in most cases, there are some differences:
- TemplateBinding accepts only a single property rather than a property path, so if you want to bind using a property path you must use the second syntax: <!-- This WON'T work as TemplateBinding only accepts single properties --><TextBlock Name="tb" Text="{TemplateBinding Caption.Length}"/><!-- Instead this syntax must be used in this case --><TextBlock Name="tb" Text="{Binding Caption.Length, RelativeSource={RelativeSource TemplatedParent}}"/>
- A TemplateBinding only supports OneWay mode for performance reasons (this is the same as WPF). This means a TemplateBinding is actually equivalent to {Binding RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}. If TwoWay binding is required in a control template, the full syntax is needed as shown below. Note that Binding will also use the default binding mode unlike TemplateBinding. {Binding RelativeSource={RelativeSource TemplatedParent}, Mode=TwoWay}
- TemplateBinding can only be used on IStyledElement.
TemplateBinding accepts only a single property rather than a property path, so if you want to bind using a property path you must use the second syntax:
`TemplateBinding` ```bash
<!-- This WON'T work as TemplateBinding only accepts single properties --><TextBlock Name="tb" Text="{TemplateBinding Caption.Length}"/><!-- Instead this syntax must be used in this case --><TextBlock Name="tb" Text="{Binding Caption.Length, RelativeSource={RelativeSource TemplatedParent}}"/>
```
A TemplateBinding only supports OneWay mode for performance reasons (this is the same as WPF). This means a TemplateBinding is actually equivalent to {Binding RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}. If TwoWay binding is required in a control template, the full syntax is needed as shown below. Note that Binding will also use the default binding mode unlike TemplateBinding.
`TemplateBinding` `OneWay` `TemplateBinding` `{Binding RelativeSource={RelativeSource TemplatedParent}, Mode=OneWay}` `TwoWay` `Binding` `TemplateBinding` ```bash
{Binding RelativeSource={RelativeSource TemplatedParent}, Mode=TwoWay}
```
TemplateBinding can only be used on IStyledElement.
`TemplateBinding` `IStyledElement` ```bash
<!-- This WON'T work as GeometryDrawing is not a IStyledElement. --><GeometryDrawing Brush="{TemplateBinding Foreground}"/><!-- Instead this syntax must be used in this case. --><GeometryDrawing Brush="{Binding Foreground, RelativeSource={RelativeSource TemplatedParent}}"/>
```
- Data Binding
# Platform-Specific XAML | Avalonia Docs
- How-To Guides
- Platforms
- Platform-Specific Code
- Platform-Specific XAML
## Platform-Specific XAML
### OnPlatform Markup Extension​
#### Overview​
The OnPlatform markup extension in Avalonia allows developers to specify different values for a property based on the operating system on which the application is running. This is particularly useful for creating cross-platform applications that need to adapt their UI or behavior according to the platform.
#### Basic usage in markup extension syntax​
You can specify values for each platform and a default value that will be used if no specific platform match is found:
```bash
<TextBlock Text="{OnPlatform Default='Unknown', Windows='Im Windows', macOS='Im macOS', Linux='Im Linux'}"/>
```
Alternatively, you can use constructor syntax to define the default value directly, skipping Default keyword. Platform-specific properties still need to be defined:
`Default` ```bash
<TextBlock Text="{OnPlatform 'Hello World', Android='Im Android'}"/>
```
You can use this markup extension with any other type, not only strings:
```bash
<Border Height="{OnPlatform 10, Windows=50.5}"/>
```
#### Specifying Type Arguments​
You can use custom TypeArguments to explicitly specify the type for the values:
```bash
<TextBlock Tag="{OnPlatform '0, 0, 0, 0', Windows='10, 10, 10, 10', x:TypeArguments=Thickness}"/>
```
In this sample above, Tag property has type of object, so compiler doesn't have enough information to parse input strings. Without specifying TypeArguments, property will have value of string on all platforms. But since we have TypeArguments here, compiler will parse them as Thickness values.
`Tag` `object` `string` `TypeArguments` `Thickness` #### Nested Markup Extensions​
The OnPlatform extension supports nesting other markup extensions within it:
```bash
<Border Background="{OnPlatform Default={StaticResource DefaultBrush}, Windows={StaticResource WindowsBrush}}"/>
```
#### XML Syntax​
OnPlatform can also be used in XML syntax for defining property values:
```bash
<StackPanel>  <OnPlatform>    <OnPlatform.Default>      <ToggleButton Content="Hello World" />    </OnPlatform.Default>    <OnPlatform.iOS>      <ToggleSwitch Content="Hello iOS" />    </OnPlatform.Windows>  </OnPlatform></StackPanel>
```
Note, in this sample, OnPlatform is a child of StackPanel. But in runtime only single actual control will be created (ToggleButton or ToggleSwitch) and added to the StackPanel.
`OnPlatform` `StackPanel` `ToggleButton` `ToggleSwitch` #### Complex Property Setters​
Similarly to the previous sample, OnPlatform can be part of complex property setters within a ResourceDictionary or other dictionaries or collections:
```bash
<ResourceDictionary>  <OnPlatform x:Key="MyBrush">    <OnPlatform.Default>      <SolidColorBrush Color="Blue" />    </OnPlatform.Default>    <OnPlatform.iOS>      <SolidColorBrush Color="Yellow" />    </OnPlatform.Windows>  </OnPlatform></ResourceDictionary>
```
#### XML Combining Syntax​
To avoid branches duplication, it is possible to define multiple platforms in a single branch. Another useful example would be including platform-specific styles:
```bash
<Application.Styles>  <!-- Always included -->  <FluentTheme />  <!-- Only one branch is executed in runtime -->  <OnPlatform>    <!-- if (Android || iOS) -->    <On Options="Android, iOS">      <StyleInclude Source="/Styles/Mobile.axaml" />    </On>    <!-- else -->    <On Options="Default">      <StyleInclude Source="/Styles/Default.axaml" />    </On>  </OnPlatform></Application.Styles>
```
#### Additional details​
OnPlatform markup extension works in a similar way to how switch-case works in C# code. Compiler will generate branches for all possible values, but only one branch will be executed at runtime depending on the condition.
`OnPlatform` It is also useful to remember that if an application is built with a specific Runtime Identifier and with Trimming Enabled, OnPlatform extension will have its branches trimmed only to those that are possible. For example, if OnPlatform had branches for Windows and macOS, but was built for Windows only, other branches will be removed, which also reduces application size.
`OnPlatform` `OnPlatform` ### OnFormFactor Markup Extension​
The OnFormFactor markup extension functions similarly to the OnPlatform and has the same general syntax. The main difference is that it allows defining values not per platform, but per device form factor, such as Desktop and Mobile:
`OnFormFactor` `OnPlatform` ```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <TextBlock Text="{OnFormFactor 'Default value', Mobile='Im Mobile', Desktop='Im Desktop'}"/></UserControl>
```
OnFormFactor doesn't have any compile-time trimming optimizations, as form factor cannot be known in compile time. None of these markup extensions are dynamic; once a value is set, it will not be changed.
`OnFormFactor` - OnPlatform Markup ExtensionOverviewBasic usage in markup extension syntaxSpecifying Type ArgumentsNested Markup ExtensionsXML SyntaxComplex Property SettersXML Combining SyntaxAdditional details
- Overview
- Basic usage in markup extension syntax
- Specifying Type Arguments
- Nested Markup Extensions
- XML Syntax
- Complex Property Setters
- XML Combining Syntax
- Additional details
- OnFormFactor Markup Extension
- Overview
- Basic usage in markup extension syntax
- Specifying Type Arguments
- Nested Markup Extensions
- XML Syntax
- Complex Property Setters
- XML Combining Syntax
- Additional details
# Android | Avalonia Docs
- How-To Guides
- Platforms
- Android
## Android
# Build and run your Application on a physical device | Avalonia Docs
- How-To Guides
- Platforms
- Android
- Build and run your Application on a physical device
## Build and run your Application on a physical device
To deploy and run the Application on a real Android device, make sure of the following:
- Have the Android version on the device match the supported or target versions in AndroidManifest.xml (if no versions are specified, assume that target version is latest, supported by Xamarin/MAUI),
- Connect the device to development machine and enable USB Debugging in developer settings,
- If default connection mode is "battery charging only", switch to MTP or another mode (otherwise ADB won't connect to the device),
- Have matching Android SDK installed to the target SDK version in AndroidManifest.xml,
Deployment is done via running the dotnet run command (if using console), or via the following setup (if using Visual Studio Code):
`dotnet run` tasks.json:
```bash
{	"version": "2.0.0",	"tasks": [		{			"label": "build-android",			"command": "dotnet",			"type": "process",			"args": [				"build",				"--no-restore",				"${workspaceFolder}/<ProjectName>.csproj",				"-p:TargetFramework=net6.0-android",				"-p:Configuration=Debug"			],			"problemMatcher": "$msCompile"		}	]}
```
where <ProjectName> is your Android-specific Avalonia project name.
`<ProjectName>`
# Build and run your Application on a Simulator | Avalonia Docs
- How-To Guides
- Platforms
- Android
- Build and run your Application on a Simulator
## Build and run your Application on a Simulator
Please ensure you have followed the guide Building Cross-Platform Applications.
Assuming you have created a project called HelloWorld. Enter the directory HelloWorld.Android from the command line.
`HelloWorld` `HelloWorld.Android` To build the project for Android run the following command.
```bash
dotnet build
```
To run the project in a simulator, run the following command.
```bash
dotnet run
```
# Building Cross-Platform Applications | Avalonia Docs
- How-To Guides
- Building Cross Platform Applications
## Building Cross-Platform Applications
This guide introduces Avalonia and outlines how to architect a cross-platform application to maximize code re-use and deliver a high-quality UI experience across all major platforms: Windows, Linux, macOS, iOS, Android and WebAssembly.
Unlike the Xamarin.Forms and MAUI approach, which tends to yield applications with a lowest-common-denominator feature-set and a generic-looking user interface, Avalonia UI encourages leveraging its drawn UI capabilities. It allows developers to write their data storage and business logic code once, while offering a responsive and high-performing UI across all platforms. This document discusses a general architectural approach to achieve this goal.
Here is a summary of the key points for creating Avalonia cross-platform apps:
- Use .NET - Develop your apps in C#, F# or VB.NET. Existing code written with .NET can be seamlessly ported to Windows, Linux, macOS, iOS, Android and WebAssembly using Avalonia.
- Utilize the MVVM design pattern - Develop your application’s User Interface using the Model/View/ViewModel pattern. This approach promotes a clear separation between the "Model” and the "View", with the "ViewModel" acting as an intermediary. This ensures that your UI logic remains agnostic of the underlying platform, thereby promoting code reuse and maintainability.
- Leverage Avalonia's drawing capabilities - Avalonia doesn't rely on native UI controls, instead, it operates similarly to Flutter, drawing the entire UI. This not only ensures a consistent look and feel across all platforms but also offers an unparalleled level of customization, allowing you to tailor the UI to your exact needs.
- Balance between core and platform-specific code - The key to achieving high code reuse is striking the right balance between platform-agnostic core code and platform-specific code. The core code comprises everything that does not interact directly with the underlying operating system.
`Model/View/ViewModel`
# Configure debugging in Visual Studio Code (Linux) | Avalonia Docs
- How-To Guides
- Platforms
- Android
- Configure debugging in Visual Studio Code (Linux)
## Configure debugging in Visual Studio Code (Linux)
For debugging Avalonia-based Android projects on Linux (using Visual Studio Code), follow the steps:
- Make sure to install the "Mono Debug" extension from here.
- Configure your launch.json file to include the following entries (for deploy + debug, and attach respectively):
Make sure to install the "Mono Debug" extension from here.
Configure your launch.json file to include the following entries (for deploy + debug, and attach respectively):
`launch.json` ```bash
{	"version": "0.2.0",	"configurations": [		{			"name": "Debug - Android",			"type": "mono",			"preLaunchTask": "run-debug-android",			"request": "attach",   			"address": "localhost",   			"port": 10000		},		{			"name": "Attach - Android",			"type": "mono",			"request": "attach",			"address": "localhost",			"port": 10000		}	]}
```
where port value can be arbitrary (make sure it's not used already by other applications or OS).
`port` - Add a new entry to tasks.json for deploying to Android (device or emulator) with enabled Mono debug server:
`tasks.json` ```bash
{	"version": "2.0.0",	"tasks": [		/* ... */		{			"label": "run-debug-android",			"command": "dotnet",			"type": "shell",			"args": [				"build",				"--no-restore",				"-t:Run",				"${workspaceFolder}/<ProjectName>.Android.csproj",				"-p:TargetFramework=net6.0-android",				"-p:Configuration=Debug",				"-p:AndroidAttachDebugger=true",				"-p:AndroidSdbHostPort=10000"			],			"problemMatcher": "$msCompile"		}	]}
```
where <ProjectName> is your Android-specific Avalonia project name.
`<ProjectName>` Make sure that the value of port variable in launch.json matches the one of AndroidSdbHostPort in tasks.json, otherwise the debugger won't be able to connect.
`port` `launch.json` `AndroidSdbHostPort` `tasks.json` After the setup, you can run the Debug - Android task via the Debug panel. Dotnet runtime will build and deploy the app, and Mono debugger will connect to the open port on the device, with all standard debugging functionality available.
`Debug - Android`
# How To Set Up an Android Dev Environment | Avalonia Docs
- How-To Guides
- Platforms
- Android
- How To Set Up an Android Dev Environment
## How To Set Up an Android Dev Environment
This guide shows you how to set up your development environment for work on a mobile Android application.
Follow these steps to install the tools you will need, using the CLI:
- Check that you have installed a compatible version of the .NET SDK. The lowest version that works with Avalonia UI is 6.0.2.00.
You can see the versions of the .NET SDK here.
- You may need to uninstall an old version of the Android Workload. To do this, type the following command:
```bash
dotnet workload uninstall android
```
- Install the Android Workload. To do this, type the following command:
```bash
dotnet workload install android
```
You may need to run the above commands with sudo.
### Install the Android SDK​
There are several ways to install the Android SDK. Choose the one that matches your development environment.
If you have Visual Studio or Visual Studio for Mac then follow the guide found here.
If you use JetBrains Rider then follow the guide here.
Alternatively you can install the Android command line tools from here.
This toolset has a command line based SDK manager that can be used to install the SDK. On successfully installing the Android SDK, add the path to the sdk to your PATH environment variable, directly in bash or in your profile's .bashrc file on Linux.
```bash
export ANDROID_HOME=/path/to/sdkexport PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
```
You can also directly specify the Android SDK location in the dotnet commands when you build, run or deploy the dotnet Android project, by setting the AndroidSdkDirectory variable in the command:
`dotnet` `AndroidSdkDirectory` ```bash
dotnet build ... /p:AndroidSdkDirectory=/path/to/sdk
```
Ensure you've installed the JDK 11 or above using your platform's package manager. This is already done if set up using Visual Studio or JetBrains Rider as stated above.
There is also a tool in development called MAUI Check that can install all the required SDKs and tools for you automatically:
```bash
dotnet tool install -g Redth.Net.Maui.Checkmaui-check
```
With the above Android development environment setup, you will be able to build Android applications, and run them in a simulator on your platform.
- Install the Android SDK
# Embed Native Views | Avalonia Docs
- How-To Guides
- Platforms
- Android
- Embed Native Views
## Embed Native Views
In Avalonia UI, you can use the native control host feature on Android by creating an instance of AndroidViewControlHandle from an Android view.
`AndroidViewControlHandle` This documentation is based on the following example.
We have a class named EmbedSampleAndroid implementing the INativeDemoControl interface. This class contains a method CreateControl which demonstrates how to use native control host.
`EmbedSampleAndroid` `INativeDemoControl` `CreateControl` ```bash
public interface INativeDemoControl  {    /// <param name="isSecond">Used to specify which control should be displayed as a demo</param>    /// <param name="parent"></param>    /// <param name="createDefault"></param>    IPlatformHandle CreateControl(bool isSecond, IPlatformHandle parent, Func<IPlatformHandle> createDefault);  }public class EmbedSampleAndroid : INativeDemoControl{  public IPlatformHandle CreateControl(bool isSecond, IPlatformHandle parent, Func<IPlatformHandle> createDefault)  {    var parentContext = (parent as AndroidViewControlHandle)?.View.Context      ?? global::Android.App.Application.Context;    if (isSecond)    {      var webView = new global::Android.Webkit.WebView(parentContext);      webView.LoadUrl("https://www.android.com/");      return new AndroidViewControlHandle(webView);    }    else    {      var button = new global::Android.Widget.Button(parentContext) { Text = "Hello world" };      var clickCount = 0;      button.Click += (sender, args) =>      {        clickCount++;        button.Text = $"Click count {clickCount}";      };      return new AndroidViewControlHandle(button);    }  }}
```
In this method, CreateControl, the parent object is cast to AndroidViewControlHandle to get the View's Context. If this fails, the global application context is used.
`CreateControl` `parent` `AndroidViewControlHandle` `View` The isSecond parameter is used to decide which control to create. If it's true, a WebView is created, navigates to "https://www.android.com/", and its instance is wrapped in an AndroidViewControlHandle which is then returned.
`isSecond` `true` `WebView` `AndroidViewControlHandle` If isSecond is false, a Button is created with the text "Hello world". The button's Click event is wired up to an event handler that increases the clickCount and updates the button's text to display the number of clicks. The Button instance is also wrapped in an AndroidViewControlHandle and returned.
`isSecond` `false` `Click` `clickCount` `Button` `AndroidViewControlHandle`
# How To Develop For Mobile iOS | Avalonia Docs
- How-To Guides
- Platforms
- iOS
- How To Develop For Mobile iOS
## 👉 How To Develop For Mobile iOS
In this section we describe how to setup you machine for iOS development. Then, if you have a Mac, how to run it on a simulator or an actual iPhone or iPad.
Due to Apple's policies it is unfortunately not possible to run the iOS simulators or test on an iPhone or iPad without a genuine Apple device running macOS and Xcode.
We hope this might change in the future, if you do not have access to a Mac, a workaround is to run your application in a Window sized appropriately. Or follow the guides on Android.
You should always test on a real device before releasing.
Before getting started ensure you have followed the guide Building Cross Platform Applications.
# How To Set Up Your Developer Environment for iOS | Avalonia Docs
- How-To Guides
- Platforms
- iOS
- How To Set Up Your Developer Environment for iOS
## How To Set Up Your Developer Environment for iOS
#### Prerequisites​
On a Mac you will need to have the latest version of macOS and Xcode installed.
#### Install the SDK​
First it is very important to install the correct dotnet SDK. At the time of writing, the lowest sdk version that works is 6.0.200.
#### Install the Workload​
```bash
dotnet workload install ios
```
You may need to run the command with sudo You may also need to uninstall old versions. dotnet workload remove ios
`sudo` `dotnet workload remove ios` This will allow you to build applications for iOS on any platform. However you will only be able to test and run them if you have access to actual macOS hardware with Xcode installed.
- Prerequisites
- Install the SDK
- Install the Workload
# How to Build and Run on iPhone or iPad | Avalonia Docs
- How-To Guides
- Platforms
- iOS
- How to Build and Run on iPhone or iPad
## How to Build and Run on iPhone or iPad
In order to allow dotnet to sideload your application to your iphone or ipad you must first use Xcode to provision your device.
Before continuing follow this guide to create a free Apple developer signing certificate.
This has to be done by creating an Xcode app project that has the same bundle identifier that you will use in your application.
`bundle identifier` - Open Xcode
![](https://docs.avaloniaui.net/assets/images/ios-open-xcode-1c49fde1205a8ff8c2cb1e43775fc13f.png)
- Select Create a new Xcode project
![](https://docs.avaloniaui.net/assets/images/ios-create-xcode-project-474e17ecf43f2ddf6fbd23c33d07d286.png)
- Select iOS and App and click Next.
![](https://docs.avaloniaui.net/assets/images/ios-select-project-options-4082fbedab9f7db32d0b7029e475ea63.png)
- Type in a name for your project and Organisation. Keep all the rest of the information the same.
- Choose a directory to save the project. You will not need to keep the project so don't worry too much about where.
- In the status bar at the top click on the "Any device (arm64)"
Type in a name for your project and Organisation. Keep all the rest of the information the same.
Choose a directory to save the project. You will not need to keep the project so don't worry too much about where.
In the status bar at the top click on the "Any device (arm64)"
![](https://docs.avaloniaui.net/assets/images/ios-select-any-device-0135446be2c0ac9fc7d3feaca1c22c2f.png)
- At the bottom of the list click "Add Additional Simulators..."
![](https://docs.avaloniaui.net/assets/images/ios-add-additional-simulators-97eb8491c7c1dd11d1e32102c52d8bce.png)
- Click on devices and connect your iPhone or iPad with the USB cable. Xcode will start to provision your phone for development.
![](https://docs.avaloniaui.net/assets/images/ios-provision-phone-a367e72c22e1a4962c1b22d700eb5098.png)
- Select you iPhone or iPad from the device list.
- Click the play button and the app will be installed and run on your phone.
If successful you may return to your IDE of choice and open the info.plist file from the iOS project.
`info.plist` - Change the bundle identifier to the same as the one you choose in Xcode in step 3.
![](https://docs.avaloniaui.net/assets/images/ios-change-bundle-identifier-c0d93661cb59d5e9a56158f7c4c6c494.png)
- Now edit the .iOS.csproj file.
`.iOS.csproj` ```bash
<RuntimeIdentifier>ios-arm64</RuntimeIdentifier><CodesignKey>Apple Development: dan@walms.co.uk (3L323F7VSS)</CodesignKey>
```
Change the RuntimeIdentifier from iossimulator-x64 to ios-arm64
`RuntimeIdentifier` `iossimulator-x64` `ios-arm64` You will need to reverse this step if you wish to run in the simulator in future.
`You will need to reverse this step if you wish to run in the simulator in future.` Add a <CodesignKey> tag.
`<CodesignKey>` To find the value for this open the application KeyChain Access. In the search box search for development.
`KeyChain Access` ![](https://docs.avaloniaui.net/assets/images/ios-cert-790baf9aadf2e82e51515efcfbeac0ca.png)
Set the value exactly as the bold text at the top of the window on your selected development certificate.
Apple Development: dan@walms.co.uk (3L323F7VSS) in this case.
`Apple Development: dan@walms.co.uk (3L323F7VSS)` After this you can run and debug your application on the iPhone or iPad like any normal
# How To Build and Run on the iOS Simulator | Avalonia Docs
- How-To Guides
- Platforms
- iOS
- How To Build and Run on the iOS Simulator
## How To Build and Run on the iOS Simulator
Please ensure you have followed the guide Building Cross-Platform Applications.
Assuming you have created a project called HelloWorld. Enter the directory HelloWorld.iOS from the command line.
`HelloWorld` `HelloWorld.iOS` To build the project for iOS run the following command.
```bash
dotnet build
```
To run the project in a simulator, run the following command.
```bash
dotnet run
```
![Application running on iPad simulator](https://docs.avaloniaui.net/assets/images/run-ios-simulator-609d04653bac6d05d131b9039a449c81.png)
If you use JetBrains Rider or Visual Studio for Mac you can open the solution and run, build and debug your program inside the simulator.
`JetBrains Rider` `Visual Studio for Mac` Dependent on the .NET version and the iOS Simulator version it may require Rosetta 2 to be installed on Apple Silicon Macs. To install Rosetta 2, you can use the following command in the terminal:
`Dependent on the .NET version and the iOS Simulator version it may require Rosetta 2 to be installed on Apple Silicon Macs. To install Rosetta 2, you can use the following command in the terminal:` ```bash
/usr/sbin/softwareupdate --install-rosetta
```
# Host Avalonia controls in Windows Forms | Avalonia Docs
- How-To Guides
- Platforms
- Windows
- Host Avalonia controls in Windows Forms
## Host Avalonia controls in Windows Forms
Avalonia controls can be hosted in Windows Forms applications. This enables a step-by-step migration of existing Windows Forms applications to Avalonia.
### Overview​
An exemplary Windows Forms application with Avalonia controls requires at least two projects:
- YourApp Cross platform library where you put your Avalonia controls
- YourApp.WinForms Your existing Windows Forms application
- YourApp.Desktop (optional) Executable Avalonia application, required only for the Visual Studio Avalonia designer
`YourApp` `YourApp.WinForms` `YourApp.Desktop` As Windows Forms is only supported on Microsoft Windows, adding Avalonia controls to your app will not make it cross platform.
### Step-by-step instructions​
These instruction assume that you use Visual Studio 2022 with the Avalonia extension. You can adjust the steps and leave out the YourApp.Desktop project if you are using VS Code or Rider.
`YourApp.Desktop` - Create both Avalonia projects In Visual Studio add a new project to your solution Choose Avalonia C# Project Select at least Desktop as target platforms Click Create You should now have a YourApp and a YourApp.Desktop project in your solution
- In Visual Studio add a new project to your solution
- Choose Avalonia C# Project
- Select at least Desktop as target platforms
- Click Create
- You should now have a YourApp and a YourApp.Desktop project in your solution
- Add references to your existing Windows Forms project A package reference to Avalonia.Desktop A package reference to Avalonia.Win32.Interoperability A project reference to YourApp.csproj
- A package reference to Avalonia.Desktop
- A package reference to Avalonia.Win32.Interoperability
- A project reference to YourApp.csproj
- Add the following lines in your Program.cs before you call Application.Run()
- In Visual Studio add a new project to your solution
- Choose Avalonia C# Project
- Select at least Desktop as target platforms
- Click Create
- You should now have a YourApp and a YourApp.Desktop project in your solution
`YourApp` `YourApp.Desktop` - A package reference to Avalonia.Desktop
- A package reference to Avalonia.Win32.Interoperability
- A project reference to YourApp.csproj
`Avalonia.Desktop` `Avalonia.Win32.Interoperability` `YourApp.csproj` `Program.cs` `Application.Run()` ```bash
AppBuilder.Configure<App>()  .UsePlatformDetect()  .SetupWithoutStarting();
```
- Add an WinFormsAvaloniaControlHost control from the Toolbox
- Add the following line to your form's constructor after InitializeComponent()
`WinFormsAvaloniaControlHost` `InitializeComponent()` ```bash
winFormsAvaloniaControlHost1.Content = new MainView { DataContext = new MainViewModel() };
```
Now you should see Avalonia's default main view Welcome to Avalonia in your Windows Forms application.
You cannot use ReactiveUI for your Windows Forms and Avalonia controls at the same time.
If you want to use it for Avalonia you must register ReactiveUI at the AppBuilder with .UseReactiveUI() in Program.cs. Do not include a reference to ReactiveUI.WinForms otherwise interactions will not work (see #16478).
`AppBuilder` `.UseReactiveUI()` `Program.cs` `ReactiveUI.WinForms` - Overview
- Step-by-step instructions
# Running on Raspberry Pi | Avalonia Docs
- How-To Guides
- Platforms
- Raspberry PI
- Running on Raspberry Pi
## Running on Raspberry Pi
#### Step 1​
Flash 8GB SD Card with Raspbian Stretch (2018-11-13). balenaEtcher is a nice tool for that.
`balenaEtcher` Plug in the card and start the Raspberry Pi.
`Raspberry Pi` You can follow this guide, next steps are summarized below.
#### Step 2​
- Install curl, libunwind8, gettext and apt-transport-https. The curl and apt-transport-https often are up-to-date.
`curl` `libunwind8` `gettext` `apt-transport-https` `curl` `apt-transport-https` ```bash
sudo apt-get install curl libunwind8 gettext apt-transport-https
```
- Download tar-ball.
```bash
curl -sSL -o dotnet.tar.gz https://dotnetcli.blob.core.windows.net/dotnet/Runtime/release/2.0.0/dotnet-runtime-latest-linux-arm.tar.gz
```
- Unpack tarball to /opt/dotnet.
`/opt/dotnet` ```bash
sudo mkdir -p /opt/dotnet && sudo tar zxf dotnet.tar.gz -C /opt/dotnet
```
- Link dotnet binary.
`dotnet` ```bash
sudo ln -s /opt/dotnet/dotnet /usr/local/bin
```
Alternative: You can login as superuser (run "sudo su")
```bash
apt-get -y install curl libunwind8 gettext apt-transport-httpscurl -sSL -o dotnet.tar.gz https://dotnetcli.blob.core.windows.net/dotnet/Runtime/release/2.0.0/dotnet-runtime-latest-linux-arm.tar.gzmkdir -p /opt/dotnet && sudo tar zxf dotnet.tar.gz -C /opt/dotnetln -s /opt/dotnet/dotnet /usr/local/bin
```
Note: Take care of line endings of the script. It should use LF instead of CR LF. Save the script as .sh file and run it on the Raspberry Pi with bash filename.sh.
`LF` `CR LF` `.sh` `Raspberry Pi` `filename.sh` #### Step 3​
- To run an Avalonia application on Raspberry Pi you need to use this nuGet package:
`Avalonia` `Raspberry Pi` SkiaSharp.NativeAssets.Linux
It includes the libSkiaSharp.so.
`libSkiaSharp.so` - Now publish the app with the following command:
```bash
dotnet publish -r linux-arm -f netcoreapp2.0
```
- Copy publish directory to the Raspberry Pi and run it with dotnet publish/ApplicationName.dll
`Raspberry Pi` `dotnet publish/ApplicationName.dll` - Step 1
- Step 2
- Step 3
# Running on Raspberry Pi with Raspbian Lite | Avalonia Docs
- How-To Guides
- Platforms
- Raspberry PI
- Running on Raspberry Pi with Raspbian Lite
## Running on Raspberry Pi with Raspbian Lite
This tutorial shows you how to run your Avalonia app on a Raspberry Pi with Raspbian Lite via DRM.
#### Step 1 - Setup the Raspberry Pi​
First step is to setup your Raspberry Pi.
##### 1.1 Download the Raspbian lite operation system image.​
You can download the Raspbian lite operating system image from the official Raspberry Pi website. Link to Raspberry Pi Operating system images
##### 1.1 Prepare Raspberry for flashing​
The installation of Raspberry Lite is a bit different depending on the model.
Raspberry Pi 4 b For the Pi 4 b you need a SD Card on which the operating system will be installed. Insert the SD card into your computer. You can now go directly to step 1.2.
Raspberry CM4 Since the CM4 is designed for embedded applications you still need an IO board. For this there is the official Compute Module 4 IO board or alternatively many other boards like the SourceKit PiTray mini.
To prepare the EMMC memory for mounting follow these steps.
##### 1.2 Flashing the operating system​
- Download the Etcher image writing utility and install it.
- Open Etcher and select from your hard drive the .zip file you downloaded in step 1.1.
- Select the mass storage (SD card or CM4 EMMC) you wish to write your image to.
- Review your selections and click 'Flash!' to begin writing data. Once flashing is complete, create a new empty file named ssh (with no extension, e.q with touch ssh) in the boot drive of the Raspberry. This will ensure that the SSH daemon is enabled once the Raspberry Pi has started and you can logon over the network.
- Only for Cm4 add the following to /boot/config.txt to enable the Usb 2.0 ports
`touch ssh` `/boot/config.txt` ```bash
dtoverlay=dwc2,dr_mode=host
```
- Start up your Raspberry and login. Raspberry Pi 4 b: Put the SD card into the Raspberry and plug in power supply CM 4: On CM4 IO Board unplug the power supply, remove J2 jumper, plug in power supply again
##### 1.3 Install missing libraries​
Some libraries required to run a Avalonia app via DRM on raspbian lite:
```bash
sudo apt updatesudo apt upgradesudo rebootsudo apt-get install libgbm1 libgl1-mesa-dri libegl1-mesa libinput10
```
##### 1.4 Verify DRM (optional)​
You can test your installation with a simple but useful tool called kmscube.
```bash
sudo apt-get install kmscubesudo kmscube
```
You should see the spinning cube on your Raspberry pi screen now:\
![](https://docs.avaloniaui.net/assets/images/raspbian-lite-drm-kmscube-1c4946e5a6cb9e9f3278de5148ef53d2.gif)
#### Step 2 - Prepare Avalonia App​
2.1 Create new Avalonia App (Core or MVVM App) We called it AvaloniaRaspbianLiteDrm in this tutorial.
2.2 Add package Avalonia.LinuxFrameBuffer
```bash
dotnet add package Avalonia.LinuxFramebuffer
```
2.3 Create MainView When we work via FrameBuffer there are no windows, so we need a separate view (UserControl) which will be our toplevel control. This view is the counterpart to the normal window.
MainView will be our app base in which we develop our UI:
`MainView` ```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:d="http://schemas.microsoft.com/expression/blend/2008"       xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"       mc:Ignorable="d"       d:DesignWidth="800"       d:DesignHeight="450"       x:Class="AvaloniaRaspbianLiteDrm.MainView">  <StackPanel HorizontalAlignment="Center"        VerticalAlignment="Center"        Margin="30"        Spacing="30">    <TextBlock FontSize="25">      Welcome to Avalonia! The best XAML framework ever ♥    </TextBlock>    <Slider />  </StackPanel></UserControl>
```
Now create a new UserControl with name MainSingleView and host the MainView:
`MainSingleView` `MainView` ```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:d="http://schemas.microsoft.com/expression/blend/2008"       xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"       xmlns:avaloniaRaspbianLiteDrm="clr-namespace:AvaloniaRaspbianLiteDrm"       mc:Ignorable="d"       d:DesignWidth="800"       d:DesignHeight="450"       x:Class="AvaloniaRaspbianLiteDrm.MainSingleView">  <avaloniaRaspbianLiteDrm:MainView /></UserControl>
```
Also change the MainWindow.axaml to host the MainView inside:
`MainWindow.axaml` `MainView` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    xmlns:avaloniaRaspbianLiteDrm="clr-namespace:AvaloniaRaspbianLiteDrm"    mc:Ignorable="d"    d:DesignWidth="800"    d:DesignHeight="450"    x:Class="AvaloniaRaspbianLiteDrm.MainWindow"    Title="AvaloniaRaspbianLiteDrm">  <avaloniaRaspbianLiteDrm:MainView /></Window>
```
So as you see the MainView is hosted in booth MainSingleView and MainWindow. This makes it easier for development to run the app also on desktop and on the Raspberry
`MainSingleView` `MainWindow` 2.3 Prepare Program.cs Next we need to prepare the Program.cs to enable the DRM usage. Change the Main void to the following:
`Program.cs` ```bash
public static int Main(string[] args){  var builder = BuildAvaloniaApp();  if (args.Contains("--drm"))  {    SilenceConsole();    // By default, Avalonia will try to detect output card automatically.    // But you can specify one, for example "/dev/dri/card1".    return builder.StartLinuxDrm(args: args, card: null, scaling: 1.0);  }  return builder.StartWithClassicDesktopLifetime(args);}private static void SilenceConsole(){  new Thread(() =>    {      Console.CursorVisible = false;      while (true)        Console.ReadKey(true);    })    { IsBackground = true }.Start();}
```
SilenceConsole() captures the console input and hide it. Otherwise you will see the console cursor blinking on the screen.
`SilenceConsole()` 2.4 Prepare App.axaml.cs Next we need to set the MainView for the ISingleViewApplicationLifetime for the DRM usage.
`ISingleViewApplicationLifetime` Change the OnFrameworkInitializationCompleted() in App.axaml.cs:
`OnFrameworkInitializationCompleted()` `App.axaml.cs` ```bash
public override void OnFrameworkInitializationCompleted(){  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)    desktop.MainWindow = new MainWindow();  else if (ApplicationLifetime is ISingleViewApplicationLifetime singleView)    singleView.MainView = new MainSingleView();  base.OnFrameworkInitializationCompleted();}
```
2.5 Run and test on desktop Now you can run/debug your app on desktop as usual. When you start your app you should see this:\
![](https://docs.avaloniaui.net/assets/images/raspbian-lite-drm-desktop-809525d0eda47c7ae3ee061cd4358c5b.jpg)
#### Step 3 - Deploy and run on Raspberry​
3.1 Publish app
```bash
dotnet publish -c Release -o publish -r linux-arm -p:PublishReadyToRun=true -p:PublishSingleFile=true -p:PublishTrimmed=true --self-contained true -p:IncludeNativeLibrariesForSelfExtract=true
```
3.2 Copy app to Raspberry Copy the files from /publish directory of your project to your Raspberry. You can do this via scp <source> <destination> or use a app like CyberDuck or via Usb stick.
`/publish` `scp <source> <destination>` 3.3 Run app on Raspberry First we need to change the permission to executable.
```bash
sudo chmod +x /path/to/app/AvaloniaRaspbianLiteDrm
```
Now you can run the app with the following:
```bash
sudo ./path/to/app/AvaloniaRaspbianLiteDrm --drm
```
You should see the app running on your Raspberry Pi now:
![](https://docs.avaloniaui.net/assets/images/raspbian-lite-drm-run-on-raspberry-1b337bdf6c316dd299db9f6e8d811934.jpg)
If you have a touch display installed, try to slide the slider control :)
- Step 1 - Setup the Raspberry Pi
- Step 2 - Prepare Avalonia App
- Step 3 - Deploy and run on Raspberry
# Web Assembly | Avalonia Docs
- How-To Guides
- Platforms
- Web Assembly
## 👉 Web Assembly
Run in the browser with WebAssembly
- Install wasm-tools workload tools. See dotnet documentation.
`wasm-tools` ```bash
dotnet workload install wasm-tools
```
If you are running net8.0-browser application on .NET 9 SDK, you should install wasm-tools-net8 workload instead. If you have an older .NET SDK, it might ask you to install other workloads like wasm-experimental as well.
`net8.0-browser` `wasm-tools-net8` `wasm-experimental` - Install or update the dotnet templates to the latest version.
```bash
dotnet new install avalonia.templates
```
- Create a new directory for the project.
```bash
mkdir BrowserTestcd BrowserTest
```
- Generate a new project that supports running in the browser. To lookup the available templates via dotnet new list see dotnet documentation.
`dotnet new list` ```bash
dotnet new avalonia.xplat
```
- In the console output you will see HTTP and HTTPS links to open the app. In order to run, simply do the following:
```bash
cd BrowserTest.Browserdotnet run# Output:# App url: http://127.0.0.1:53576/# App url: https://127.0.0.1:53577/# Debug at url: http://127.0.0.1:53576/_framework/debug# Debug at url: https://127.0.0.1:53577/_framework/debug
```
#### Deployment​
In the BrowserTest.Browser directory, run:
`BrowserTest.Browser` ```bash
dotnet publish
```
After project was published, .NET SDK creates an app bundle directory with index.html file and compiled application files. With latest .NET 9 SDK, this directory is located at bin/Release/net9.0-browser/publish/wwwroot. If your project targets "net8.0-browser", use net8.0-browser directory. Now you can serve your app from this directory using your favorite web server (such as Azure Static Web Apps).
`index.html` `bin/Release/net9.0-browser/publish/wwwroot` `net8.0-browser` On older .NET SDK versions, app bundle was located in different directory: bin/Release/net8.0-browser/browser-wasm/AppBundle (search for AppBundle).
`bin/Release/net8.0-browser/browser-wasm/AppBundle` `AppBundle` Currently using dotnet publish with the -o or --output flag does not produce the AppBundle folder in the output directory. (See this issue.) You'll still have to grab it out of the bin directory at the path specified by the publish output.
`dotnet publish` `-o` `--output` `bin` ##### Testing AppBundle locally​
You can serve your wasm app from this directly using the dotnet-serve tool as follows:
```bash
dotnet tool install --global dotnet-servedotnet serve -d:bin/Release/net9.0-browser/publish/wwwroot# Output: # Starting server, serving bin/Release/net9.0-browser/publish/wwwroot# Listening on any IP:#  http://localhost:49875
```
### Interop​
It is possible to call JavaScript code from the Avalonia Web application. Avalonia app is compatible with standard [JSImport]/[JSExport] interop from Microsoft. You can find more information on their documentation.
### Legacy Blazor backend​
Starting from Avalonia 11.0 Avalonia.Browser package relies on build-in .NET interop with better stability and performance. Legacy Blazor backend is still available for compatibility and can be referenced using Avalonia.Browser.Blazor package.
### Troubleshooting​
If you have not performed the step to install required workloads, you might encounter errors when running the app in your browser later (e.g. System.DllNotFoundException: libSkiaSharp) and you will need to rebuild again before the app will run.
`System.DllNotFoundException: libSkiaSharp` Keep in mind, that WebAssembly in general as a technology is limited. .NET Multithreading is not supported by any browser and is only available starting .NET 8. Any normal app also has to comply with Browser sandboxing mechanism. And while Avalonia does its best to keep performance high, any WebAssembly GUI apps in some cases might be slow or with older browsers.
- Deployment
- Interop
- Legacy Blazor backend
- Troubleshooting
# macOS Development | Avalonia Docs
- How-To Guides
- Platforms
- macOS Development
## macOS Development
Getting started developing for the macOS
### Native code​
The native macOS code is located at native/Avalonia.Native/src/OSX. Open the Avalonia.Native.OSX.xcodeproj project in Xcode.
`native/Avalonia.Native/src/OSX` `Avalonia.Native.OSX.xcodeproj` You can make changes in Xcode and compile using Cmd+B. You will then need to point your Avalonia application to the modified dynlib. The path can be found by clicking on the dylib in Xcode’s project navigator under Products.
You then specify this path in your AppBuilder using:
```bash
.With(new AvaloniaNativePlatformOptions{   AvaloniaNativeLibraryPath = “[Path to your dylib]”, })
```
If you're running on an Apple Silicon Mac and targeting .NET 5 and lower then you'll need to switch to rosetta by selecting "My Mac (Rosetta)" in the toolbar.
#### Bundling Dev Code​
In certain situations you need to run an Avalonia sample application as an app bundle. One of these situations is testing macOS Accessibility - Xcode's Accessibility Inspector fails to recognise the application otherwise.
A solution to this is to change the sample's output path to resemble an app bundle. You can do this by modifying the output path in the csproj, e.g.:
```bash
<OutputPath>bin\$(Configuration)\$(Platform)\ControlCatalog.NetCore.app/Contents/MacOS</OutputPath><AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath><UseAppHost>true</UseAppHost>
```
And in the Contents output directory place a valid Info.plist file. An example for ControlCatalog.NetCore is:
`Contents` `Info.plist` ```bash
<?xml version="1.0" encoding="utf-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"> <dict>  <key>CFBundleName</key>  <string>ControlCatalog.NetCore</string>  <key>CFBundleDisplayName</key>  <string>ControlCatalog.NetCore</string>  <key>CFBundleIdentifier</key>  <string>ControlCatalog.NetCore</string>  <key>CFBundleVersion</key>  <string>0.10.999</string>  <key>CFBundlePackageType</key>  <string>AAPL</string>  <key>CFBundleSignature</key>  <string>????</string>  <key>CFBundleExecutable</key>  <string>ControlCatalog.NetCore</string>  <key>CFBundleIconFile</key>  <string>ControlCatalog.NetCore.icns</string>  <key>CFBundleShortVersionString</key>  <string>0.1</string>  <key>NSPrincipalClass</key>  <string>NSApplication</string>  <key>NSHighResolutionCapable</key>  <true /> </dict></plist>
```
If you're using Rider < 2021.1 then you'll need to run the application from the command line, not the IDE (see https://youtrack.jetbrains.com/issue/RIDER-53892).
- Native codeBundling Dev Code
- Bundling Dev Code
# Platform-Specific XAML | Avalonia Docs
- How-To Guides
- Platforms
- Platform-Specific Code
- Platform-Specific XAML
## Platform-Specific XAML
### OnPlatform Markup Extension​
#### Overview​
The OnPlatform markup extension in Avalonia allows developers to specify different values for a property based on the operating system on which the application is running. This is particularly useful for creating cross-platform applications that need to adapt their UI or behavior according to the platform.
#### Basic usage in markup extension syntax​
You can specify values for each platform and a default value that will be used if no specific platform match is found:
```bash
<TextBlock Text="{OnPlatform Default='Unknown', Windows='Im Windows', macOS='Im macOS', Linux='Im Linux'}"/>
```
Alternatively, you can use constructor syntax to define the default value directly, skipping Default keyword. Platform-specific properties still need to be defined:
`Default` ```bash
<TextBlock Text="{OnPlatform 'Hello World', Android='Im Android'}"/>
```
You can use this markup extension with any other type, not only strings:
```bash
<Border Height="{OnPlatform 10, Windows=50.5}"/>
```
#### Specifying Type Arguments​
You can use custom TypeArguments to explicitly specify the type for the values:
```bash
<TextBlock Tag="{OnPlatform '0, 0, 0, 0', Windows='10, 10, 10, 10', x:TypeArguments=Thickness}"/>
```
In this sample above, Tag property has type of object, so compiler doesn't have enough information to parse input strings. Without specifying TypeArguments, property will have value of string on all platforms. But since we have TypeArguments here, compiler will parse them as Thickness values.
`Tag` `object` `string` `TypeArguments` `Thickness` #### Nested Markup Extensions​
The OnPlatform extension supports nesting other markup extensions within it:
```bash
<Border Background="{OnPlatform Default={StaticResource DefaultBrush}, Windows={StaticResource WindowsBrush}}"/>
```
#### XML Syntax​
OnPlatform can also be used in XML syntax for defining property values:
```bash
<StackPanel>  <OnPlatform>    <OnPlatform.Default>      <ToggleButton Content="Hello World" />    </OnPlatform.Default>    <OnPlatform.iOS>      <ToggleSwitch Content="Hello iOS" />    </OnPlatform.Windows>  </OnPlatform></StackPanel>
```
Note, in this sample, OnPlatform is a child of StackPanel. But in runtime only single actual control will be created (ToggleButton or ToggleSwitch) and added to the StackPanel.
`OnPlatform` `StackPanel` `ToggleButton` `ToggleSwitch` #### Complex Property Setters​
Similarly to the previous sample, OnPlatform can be part of complex property setters within a ResourceDictionary or other dictionaries or collections:
```bash
<ResourceDictionary>  <OnPlatform x:Key="MyBrush">    <OnPlatform.Default>      <SolidColorBrush Color="Blue" />    </OnPlatform.Default>    <OnPlatform.iOS>      <SolidColorBrush Color="Yellow" />    </OnPlatform.Windows>  </OnPlatform></ResourceDictionary>
```
#### XML Combining Syntax​
To avoid branches duplication, it is possible to define multiple platforms in a single branch. Another useful example would be including platform-specific styles:
```bash
<Application.Styles>  <!-- Always included -->  <FluentTheme />  <!-- Only one branch is executed in runtime -->  <OnPlatform>    <!-- if (Android || iOS) -->    <On Options="Android, iOS">      <StyleInclude Source="/Styles/Mobile.axaml" />    </On>    <!-- else -->    <On Options="Default">      <StyleInclude Source="/Styles/Default.axaml" />    </On>  </OnPlatform></Application.Styles>
```
#### Additional details​
OnPlatform markup extension works in a similar way to how switch-case works in C# code. Compiler will generate branches for all possible values, but only one branch will be executed at runtime depending on the condition.
`OnPlatform` It is also useful to remember that if an application is built with a specific Runtime Identifier and with Trimming Enabled, OnPlatform extension will have its branches trimmed only to those that are possible. For example, if OnPlatform had branches for Windows and macOS, but was built for Windows only, other branches will be removed, which also reduces application size.
`OnPlatform` `OnPlatform` ### OnFormFactor Markup Extension​
The OnFormFactor markup extension functions similarly to the OnPlatform and has the same general syntax. The main difference is that it allows defining values not per platform, but per device form factor, such as Desktop and Mobile:
`OnFormFactor` `OnPlatform` ```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <TextBlock Text="{OnFormFactor 'Default value', Mobile='Im Mobile', Desktop='Im Desktop'}"/></UserControl>
```
OnFormFactor doesn't have any compile-time trimming optimizations, as form factor cannot be known in compile time. None of these markup extensions are dynamic; once a value is set, it will not be changed.
`OnFormFactor` - OnPlatform Markup ExtensionOverviewBasic usage in markup extension syntaxSpecifying Type ArgumentsNested Markup ExtensionsXML SyntaxComplex Property SettersXML Combining SyntaxAdditional details
- Overview
- Basic usage in markup extension syntax
- Specifying Type Arguments
- Nested Markup Extensions
- XML Syntax
- Complex Property Setters
- XML Combining Syntax
- Additional details
- OnFormFactor Markup Extension
- Overview
- Basic usage in markup extension syntax
- Specifying Type Arguments
- Nested Markup Extensions
- XML Syntax
- Complex Property Setters
- XML Combining Syntax
- Additional details
# Platform-Specific XAML | Avalonia Docs
- How-To Guides
- Platforms
- Platform-Specific Code
- Platform-Specific XAML
## Platform-Specific XAML
### OnPlatform Markup Extension​
#### Overview​
The OnPlatform markup extension in Avalonia allows developers to specify different values for a property based on the operating system on which the application is running. This is particularly useful for creating cross-platform applications that need to adapt their UI or behavior according to the platform.
#### Basic usage in markup extension syntax​
You can specify values for each platform and a default value that will be used if no specific platform match is found:
```bash
<TextBlock Text="{OnPlatform Default='Unknown', Windows='Im Windows', macOS='Im macOS', Linux='Im Linux'}"/>
```
Alternatively, you can use constructor syntax to define the default value directly, skipping Default keyword. Platform-specific properties still need to be defined:
`Default` ```bash
<TextBlock Text="{OnPlatform 'Hello World', Android='Im Android'}"/>
```
You can use this markup extension with any other type, not only strings:
```bash
<Border Height="{OnPlatform 10, Windows=50.5}"/>
```
#### Specifying Type Arguments​
You can use custom TypeArguments to explicitly specify the type for the values:
```bash
<TextBlock Tag="{OnPlatform '0, 0, 0, 0', Windows='10, 10, 10, 10', x:TypeArguments=Thickness}"/>
```
In this sample above, Tag property has type of object, so compiler doesn't have enough information to parse input strings. Without specifying TypeArguments, property will have value of string on all platforms. But since we have TypeArguments here, compiler will parse them as Thickness values.
`Tag` `object` `string` `TypeArguments` `Thickness` #### Nested Markup Extensions​
The OnPlatform extension supports nesting other markup extensions within it:
```bash
<Border Background="{OnPlatform Default={StaticResource DefaultBrush}, Windows={StaticResource WindowsBrush}}"/>
```
#### XML Syntax​
OnPlatform can also be used in XML syntax for defining property values:
```bash
<StackPanel>  <OnPlatform>    <OnPlatform.Default>      <ToggleButton Content="Hello World" />    </OnPlatform.Default>    <OnPlatform.iOS>      <ToggleSwitch Content="Hello iOS" />    </OnPlatform.Windows>  </OnPlatform></StackPanel>
```
Note, in this sample, OnPlatform is a child of StackPanel. But in runtime only single actual control will be created (ToggleButton or ToggleSwitch) and added to the StackPanel.
`OnPlatform` `StackPanel` `ToggleButton` `ToggleSwitch` #### Complex Property Setters​
Similarly to the previous sample, OnPlatform can be part of complex property setters within a ResourceDictionary or other dictionaries or collections:
```bash
<ResourceDictionary>  <OnPlatform x:Key="MyBrush">    <OnPlatform.Default>      <SolidColorBrush Color="Blue" />    </OnPlatform.Default>    <OnPlatform.iOS>      <SolidColorBrush Color="Yellow" />    </OnPlatform.Windows>  </OnPlatform></ResourceDictionary>
```
#### XML Combining Syntax​
To avoid branches duplication, it is possible to define multiple platforms in a single branch. Another useful example would be including platform-specific styles:
```bash
<Application.Styles>  <!-- Always included -->  <FluentTheme />  <!-- Only one branch is executed in runtime -->  <OnPlatform>    <!-- if (Android || iOS) -->    <On Options="Android, iOS">      <StyleInclude Source="/Styles/Mobile.axaml" />    </On>    <!-- else -->    <On Options="Default">      <StyleInclude Source="/Styles/Default.axaml" />    </On>  </OnPlatform></Application.Styles>
```
#### Additional details​
OnPlatform markup extension works in a similar way to how switch-case works in C# code. Compiler will generate branches for all possible values, but only one branch will be executed at runtime depending on the condition.
`OnPlatform` It is also useful to remember that if an application is built with a specific Runtime Identifier and with Trimming Enabled, OnPlatform extension will have its branches trimmed only to those that are possible. For example, if OnPlatform had branches for Windows and macOS, but was built for Windows only, other branches will be removed, which also reduces application size.
`OnPlatform` `OnPlatform` ### OnFormFactor Markup Extension​
The OnFormFactor markup extension functions similarly to the OnPlatform and has the same general syntax. The main difference is that it allows defining values not per platform, but per device form factor, such as Desktop and Mobile:
`OnFormFactor` `OnPlatform` ```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <TextBlock Text="{OnFormFactor 'Default value', Mobile='Im Mobile', Desktop='Im Desktop'}"/></UserControl>
```
OnFormFactor doesn't have any compile-time trimming optimizations, as form factor cannot be known in compile time. None of these markup extensions are dynamic; once a value is set, it will not be changed.
`OnFormFactor` - OnPlatform Markup ExtensionOverviewBasic usage in markup extension syntaxSpecifying Type ArgumentsNested Markup ExtensionsXML SyntaxComplex Property SettersXML Combining SyntaxAdditional details
- Overview
- Basic usage in markup extension syntax
- Specifying Type Arguments
- Nested Markup Extensions
- XML Syntax
- Complex Property Setters
- XML Combining Syntax
- Additional details
- OnFormFactor Markup Extension
- Overview
- Basic usage in markup extension syntax
- Specifying Type Arguments
- Nested Markup Extensions
- XML Syntax
- Complex Property Setters
- XML Combining Syntax
- Additional details
# Avalonia UI and MVVM | Avalonia Docs
- Deep Dives
- The MVVM Pattern
- Avalonia UI and MVVM
## Avalonia UI and MVVM
On this page you will learn how the MVVM pattern is realised when used with Avalonia UI.
### Views and View Models​
When you use the MVVM pattern with Avalonia UI, you implement a view with an AXAML file, attached to a corresponding code-behind file, and a view model with a plain-old code class file.
In Avalonia UI, a view is implemented as a composition of UI elements in a window or a user control (both AXAML files with code-behind). The UI elements in a composition can be a mixture of Avalonia UI built-in controls, user controls and (more advanced) controls of your own design and implementation.
For a full list of the Avalonia UI built-in controls, see the reference section here.
To learn more about the concept of UI composition, see here.
To learn how to design and implement your own controls, see here.
### Data Binding​
Data binding is the key technology that allows an Avalonia UI MVVM application to separate views from view models. You can visualise the view to view model relationship as two layers connected by the data bindings:
![](https://docs.avaloniaui.net/assets/images/mvvm-22304837aa64469743c8084694f0238e.png)
Notice how some of the data bindings are represented by a two way arrow and others by a single-headed arrow. For example, the name and address inputs are two ways - you want both changes in the view model to be notified to the view, and for inputs to the view to be updated on the view model.
The buttons however have one-direction commands, issued by the view and acted out by the view model.
Notice how the view model class is not dependent on the view layer, or how it will be rendered on the target platform by Avalonia UI. Because the view model class is independent, it can be unit tested like any other code.
When you use the MVVM pattern in practice, you will use a corresponding view model for each view, and the view model class contains all the application logic for the view.
### The MVVM Model​
The model is the other part of the MVVM pattern. Models are much less precisely defined in the pattern as they represent 'the rest of the architecture'. This is often data storage or other services.
The important principle for you to maintain is separation. You should implement the relationship between view model and model using some form of the Dependency Injection (DI) pattern.
### ReactiveUI​
There are a number of frameworks designed to help write applications using the MVVM pattern.
In the following pages, you will learn about the ReactiveUI framework which is one of the most popular and is supported by one of the Avalonia UI packages.
- Views and View Models
- Data Binding
- The MVVM Model
- ReactiveUI
# Reactive View Model | Avalonia Docs
- Deep Dives
- ReactiveUI
- Reactive View Model
## Reactive View Model
This page describes how you can use the ReactiveUI ReactiveObject as the basis of your view model to implement MVVM binding with Avalonia UI.
`ReactiveObject` ReactiveUI provides the ReactiveObject as a base class for view models. It implements a notification of property changes and observables to monitor object changes.
`ReactiveObject` For the detailed ReactiveUI documentation for ReactiveObject, see here.
`ReactiveObject` Once you have installed and configured ReactiveUI, you can base your view models on the class:
```bash
public class ViewModelBase : ReactiveObject{}
```
If you have used the Avalonia MVVM Application solution template, then you will find this base class already added to the project /ViewModels folder.
For example, you can implement a simple view model like this:
```bash
public class MyViewModel : ViewModelBase{  private string _description = string.Empty;  public string Description  {   get => _description;   set => this.RaiseAndSetIfChanged(ref _description, value);  }}
```
### Notify the View of Changes​
Avalonia UI uses the underlying ReactiveObject to Notify changes in the view model back to the view using any bindings defined in the XAML. For example, if you are binding the Avalonia UI text input control like this:
`ReactiveObject` ```bash
<TextBox AcceptsReturn="True"     Text="{Binding Description}"     Watermark="Enter a description"/>
```
Any change to the view model description property is achieved using the set accessor and a change is raised causing Avalonia UI to display the new value on the UI.
`set` ### Update the View Model from Input​
When Avalonia UI uses the binding to Update the view model, the set accessor ensures that any parts of the view model that depend on the description property can also react to the change if necessary.
`set` On the next page, you will learn how a reactive command acts as a special case of the view model update.
- Notify the View of Changes
- Update the View Model from Input
# Command Update | Avalonia Docs
- Deep Dives
- ReactiveUI
- Command Update
## Command Update
This page introduces how you can use Avalonia UI binding to initiate changes on a view model from controls like buttons that have a Command attribute.
`Command` For example, you can use this view model with an action defined in the method ButtonAction:
`ButtonAction` ```bash
public class MainWindowViewModel : ViewModelBase{  private string _greeting = "Welcome to Avalonia!";  public string Greeting  {    get => _greeting;    set => this.RaiseAndSetIfChanged(ref _greeting, value);  }  public void ButtonAction()  {    Greeting = "Another greeting from Avalonia";  }}
```
Then in the corresponding XAML define two controls:
```bash
<TextBlock Text="{Binding Greeting}" /><Button Command="{Binding ButtonAction}" >Change It</Button>
```
This means that when the user clicks the button, Avalonia UI updates the view model by calling the ButtonAction method. This changes the Greeting property using the setter, so in turn the new greeting text is notified back to the text control on the UI.
`ButtonAction` `Greeting`
# Reactive Command | Avalonia Docs
- Deep Dives
- ReactiveUI
- Reactive Command
## Reactive Command
On this page you will learn how to use the ReactiveUI ReactiveCommand and an ObservableObject created in code, to implement the UI principle of revealed functionality.
`ReactiveCommand` `ObservableObject` ### Revealed Functionality​
This is a very important principle that ensures that a user is properly guided through your UI because features and functions only become available (or even visible) once they are valid.
As a simple example: an input requires at least 8 characters before a button can be clicked, so it is proper UI practice to keep the button disabled until valid input has been made.
### Reactive Command​
As a starting point, you can create a simple view like this:
```bash
<StackPanel Margin="20"> <TextBlock Margin="0 5" >User Name</TextBlock> <TextBox Text="{Binding UserName}"/> <Button Margin="0 20" Command="{Binding SubmitCommand}">Submit</Button></StackPanel>
```
You can add a corresponding view model like this:
```bash
public class MainWindowViewModel : ViewModelBase{  private string _userName = string.Empty;  public string UserName  {    get { return _userName; }    set { this.RaiseAndSetIfChanged(ref _userName, value); }  }  public ReactiveCommand<Unit, Unit> SubmitCommand { get; }  public MainWindowViewModel()  {    SubmitCommand = ReactiveCommand.Create(() =>     {      Debug.WriteLine("The submit command was run.");    });   }}
```
This view model does not yet perform revealed functionality. The SubmitCommand is declared with no parameter, and no result (void). The synchronous action parameter of the Create method is where you implement what happens when the command is run (when the user clicks the button). The example above just reports the action in the debug window.
`SubmitCommand` `Create` ### Can Execute?​
When you use ReactiveUI to implement revealed functionality, you create an observable object that indicates whether your command can execute or not.
For example, you can add this code to the above view model constructor (public MainWindowViewModel()) to create an observable object to validate the view model:
`public MainWindowViewModel()` ```bash
IObservable<bool> isInputValid = this.WhenAnyValue(        x => x.UserName,        x => !string.IsNullOrWhiteSpace(x) && x.Length > 7        );
```
The observable object monitors the value of the UserName property and runs the validation function whenever it changes. The observable object is created by the WhenAnyValue function of the ReactiveObject that underlies the view model (see the previous page here).
`UserName` `WhenAnyValue` `ReactiveObject` Next add the observable object to the Create method. This second parameter is the canExecute argument for the method.
`Create` `canExecute` ```bash
SubmitCommand = ReactiveCommand.Create(() => {  Debug.WriteLine("The submit command was run.");}, isInputValid);
```
Now you will see that the button only becomes enabled once you have entered 8 characters.
- Revealed Functionality
- Reactive Command
- Can Execute?
# View Activation | Avalonia Docs
- Deep Dives
- ReactiveUI
- View Activation
## View Activation
For the WhenActivated ReactiveUI feature to work, you need to use custom base classes from the Avalonia.ReactiveUI package, such as ReactiveWindow<TViewModel> or ReactiveUserControl<TViewModel>. Of course, you can also implement the IViewFor<TViewModel> interface by hand in your class, but make sure you store the ViewModel in an AvaloniaProperty.
`Avalonia.ReactiveUI` `ReactiveWindow<TViewModel>` `ReactiveUserControl<TViewModel>` `IViewFor<TViewModel>` `ViewModel` `AvaloniaProperty` #### Activation Example​
ViewModel.cs
This view model implements the IActivatableViewModel interface. When the corresponding view gets attached to the visual tree, the code inside the WhenActivated block will get called. When the corresponding view gets detached from the visual tree, the composite disposable will be disposed. ReactiveObject is the base class for view model classes, and it implements INotifyPropertyChanged.
`IActivatableViewModel` `ReactiveObject` `INotifyPropertyChanged` ```bash
public class ViewModel : ReactiveObject, IActivatableViewModel{  public ViewModelActivator Activator { get; }  public ViewModel()  {    Activator = new ViewModelActivator();    this.WhenActivated((CompositeDisposable disposables) =>    {      /* handle activation */      Disposable        .Create(() => { /* handle deactivation */ })        .DisposeWith(disposables);    });  }}
```
View.xaml
This is the UI for the view model you see above.
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    Background="#f0f0f0" FontFamily="Ubuntu"    MinHeight="590" MinWidth="750"> <TextBlock Text="Hello, world!" /></Window>
```
View.xaml.cs
This is the code-behind for the View.xaml file you see above. Remember to always put a call to WhenActivated into your View constructor, otherwise ReactiveUI won't be able to determine when the view model gets activated.
`View.xaml` `WhenActivated` ```bash
public class View : ReactiveWindow<ViewModel>{  public View()  {    // ViewModel's WhenActivated block will also get called.    this.WhenActivated(disposables => { /* Handle view activation etc. */ });    AvaloniaXamlLoader.Load(this);  }}
```
#### Code-Behind ReactiveUI Bindings​
```bash
public class View : ReactiveWindow<ViewModel>{  // Assume the Button control has the Name="ExampleButton" attribute defined in XAML.  public View()  {    this.WhenActivated(disposables =>     {      // Bind the 'ExampleCommand' to 'ExampleButton' defined above.      this.BindCommand(ViewModel, x => x.ExampleCommand, x => x.ExampleButton)        .DisposeWith(disposables);    });    AvaloniaXamlLoader.Load(this);  }}
```
- Activation Example
- Code-Behind ReactiveUI Bindings
# Routing | Avalonia Docs
- Deep Dives
- ReactiveUI
- Routing
## Routing
ReactiveUI routing consists of an IScreen that contains current RoutingState, several IRoutableViewModels, and a platform-specific XAML control called RoutedViewHost. RoutingState manages the view model navigation stack and allows view models to navigate to other view models. IScreen is the root of a navigation stack; despite the name, its views don't have to occupy the whole screen. RoutedViewHost monitors an instance of RoutingState, responding to any changes in the navigation stack by creating and embedding the appropriate view.
`RoutingState` `IScreen` `RoutedViewHost` `RoutingState` ### Routing Example​
Create a new empty project from Avalonia templates. To use those, clone the avalonia-dotnet-templates repository, install the templates and create a new project named RoutingExample based on avalonia.app template. Install Avalonia.ReactiveUI package into the project.
`RoutingExample` `avalonia.app` `Avalonia.ReactiveUI` ```bash
git clone https://github.com/AvaloniaUI/avalonia-dotnet-templatesdotnet new --install ./avalonia-dotnet-templatesdotnet new avalonia.app -o RoutingExamplecd ./RoutingExampledotnet add package Avalonia.ReactiveUI
```
FirstViewModel.cs
First, create routable view models and corresponding views. We derive routable view models from the IRoutableViewModel interface from ReactiveUI namespace, and from ReactiveObject as well. ReactiveObject is the base class for view model classes, and it implements INotifyPropertyChanged.
`IRoutableViewModel` `ReactiveUI` `ReactiveObject` `ReactiveObject` `INotifyPropertyChanged` ```bash
namespace RoutingExample{  public class FirstViewModel : ReactiveObject, IRoutableViewModel  {    // Reference to IScreen that owns the routable view model.    public IScreen HostScreen { get; }    // Unique identifier for the routable view model.    public string UrlPathSegment { get; } = Guid.NewGuid().ToString().Substring(0, 5);    public FirstViewModel(IScreen screen) => HostScreen = screen;  }}
```
FirstView.xaml
```bash
<UserControl xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="RoutingExample.FirstView">  <StackPanel HorizontalAlignment="Center"        VerticalAlignment="Center">    <TextBlock Text="Hi, I'm the first view!" />    <TextBlock Text="{Binding UrlPathSegment}" />  </StackPanel></UserControl>
```
FirstView.xaml.cs
If we need to handle view model activation and deactivation, then we add a call to WhenActivated to the view. Generally, a rule of thumb is to always add WhenActivated to your views, see Activation docs for more info.
```bash
namespace RoutingExample{  public class FirstView : ReactiveUserControl<FirstViewModel>  {    public FirstView()    {      this.WhenActivated(disposables => { });      AvaloniaXamlLoader.Load(this);    }  }}
```
MainWindowViewModel.cs
Then, create a view model implementing the IScreen interface. It contains current RoutingState that manages the navigation stack. RoutingState also contains helper commands allowing you to navigate back and forward.
`IScreen` `RoutingState` `RoutingState` Actually, you can use as many IScreens as you need in your application. Despite the name, it doesn't have to occupy the whole screen. You can use nested routing, place IScreens side-by-side, etc.
`IScreen` `IScreen` ```bash
namespace RoutingExample{  public class MainWindowViewModel : ReactiveObject, IScreen  {    // The Router associated with this Screen.    // Required by the IScreen interface.    public RoutingState Router { get; } = new RoutingState();    // The command that navigates a user to first view model.    public ReactiveCommand<Unit, IRoutableViewModel> GoNext { get; }    // The command that navigates a user back.    public ReactiveCommand<Unit, IRoutableViewModel> GoBack => Router.NavigateBack;    public MainWindowViewModel()    {      // Manage the routing state. Use the Router.Navigate.Execute      // command to navigate to different view models.       //      // Note, that the Navigate.Execute method accepts an instance       // of a view model, this allows you to pass parameters to       // your view models, or to reuse existing view models.      //      GoNext = ReactiveCommand.CreateFromObservable(        () => Router.Navigate.Execute(new FirstViewModel(this))      );    }  }}
```
MainWindow.xaml
Now we need to place the RoutedViewHost XAML control to our main view. It will resolve and embed appropriate views for the view models based on the supplied IViewLocator implementation and the passed Router instance of type RoutingState. Note, that you need to import rxui namespace for RoutedViewHost to work. Additionally, you can override animations that are played when RoutedViewHost changes a view — simply override RoutedViewHost.PageTransition property in XAML.
`RoutedViewHost` `IViewLocator` `Router` `RoutingState` `rxui` `RoutedViewHost` `RoutedViewHost` `RoutedViewHost.PageTransition` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:rxui="http://reactiveui.net"    xmlns:app="clr-namespace:RoutingExample"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="RoutingExample.MainWindow"    Title="RoutingExample">  <Grid>    <Grid.RowDefinitions>      <RowDefinition Height="*" />      <RowDefinition Height="Auto" />    </Grid.RowDefinitions>    <rxui:RoutedViewHost Grid.Row="0" Router="{Binding Router}">      <rxui:RoutedViewHost.DefaultContent>        <TextBlock Text="Default content"              HorizontalAlignment="Center"              VerticalAlignment="Center" />      </rxui:RoutedViewHost.DefaultContent>      <rxui:RoutedViewHost.ViewLocator>        <!-- See AppViewLocator.cs section below -->        <app:AppViewLocator />      </rxui:RoutedViewHost.ViewLocator>    </rxui:RoutedViewHost>    <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="15">      <StackPanel.Styles>        <Style Selector="StackPanel > :is(Control)">          <Setter Property="Margin" Value="2"/>        </Style>        <Style Selector="StackPanel > TextBlock">          <Setter Property="VerticalAlignment" Value="Center"/>        </Style>      </StackPanel.Styles>      <Button Content="Go next" Command="{Binding GoNext}" />      <Button Content="Go back" Command="{Binding GoBack}" />      <TextBlock Text="{Binding Router.NavigationStack.Count}" />    </StackPanel>  </Grid></Window>
```
To disable the animations, simply set the RoutedViewHost.PageTransition property to {x:Null}, like so:
`RoutedViewHost.PageTransition` `{x:Null}` ```bash
<rxui:RoutedViewHost Grid.Row="0" Router="{Binding Router}" PageTransition="{x:Null}">  <rxui:RoutedViewHost.DefaultContent>    <TextBlock Text="Default content"          HorizontalAlignment="Center"          VerticalAlignment="Center" />  </rxui:RoutedViewHost.DefaultContent></rxui:RoutedViewHost>
```
AppViewLocator.cs
The AppViewLocator that we are passing to the RoutedViewHost control declared in the MainWindow.xaml markup shown above is responsible for resolving a View based on the type of the ViewModel. The IScreen.Router instance of type RoutingState determines which ViewModel should be currently shown. See View Location for details. The simplest possible IViewLocator implementation based on pattern matching might look like this:
`AppViewLocator` `RoutedViewHost` `MainWindow.xaml` `IScreen.Router` `RoutingState` `IViewLocator` ```bash
namespace RoutingExample{  public class AppViewLocator : ReactiveUI.IViewLocator  {    public IViewFor ResolveView<T>(T viewModel, string contract = null) => viewModel switch    {      FirstViewModel context => new FirstView { DataContext = context },      _ => throw new ArgumentOutOfRangeException(nameof(viewModel))    };  }}
```
MainWindow.xaml.cs
Here is the code-behind for MainWindow.xaml declared above.
`MainWindow.xaml` ```bash
namespace RoutingExample{  public class MainWindow : ReactiveWindow<MainWindowViewModel>  {    public MainWindow()    {      this.WhenActivated(disposables => { });      AvaloniaXamlLoader.Load(this);    }  }}
```
App.axaml.cs
Make sure you initialize the DataContext of your root view in App.axaml.cs
`DataContext` `App.axaml.cs` ```bash
public override void OnFrameworkInitializationCompleted(){  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)  {    desktop.MainWindow = new MainWindow    {      DataContext = new MainWindowViewModel(),    };  }  base.OnFrameworkInitializationCompleted();}
```
Finally, add .UseReactiveUI() to your AppBuilder:
`.UseReactiveUI()` `AppBuilder` ```bash
namespace RoutingExample{  public static class Program  {    public static void Main(string[] args)    {      BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);    }    public static AppBuilder BuildAvaloniaApp() =>      AppBuilder.Configure<App>()        .UseReactiveUI()        .UsePlatformDetect()        .LogToDebug();  }}
```
Now, you can run the app and see routing in action!
```bash
dotnet run --framework netcoreapp2.1
```
![](https://docs.avaloniaui.net/assets/images/reactiveui-routing-179bf70ff56b868579bd671057ad0375.gif)
- Routing Example
# Data Persistence | Avalonia Docs
- Deep Dives
- ReactiveUI
- Data Persistence
## Data Persistence
For better UX, your app should be capable of saving state to the disk when the app is suspending and of restoring state when the app is resuming. ReactiveUI provides facilities allowing you to persist application state by serializing the view model tree when the app is shutting down or suspending. In this tutorial we are going to look through the capabilities of ReactiveUI that help us manage the state which outlives the process.
#### Annotating The ViewModel​
View model serialization is a tricky business. We have to decide, which properties of the view model to save on application shutdown and which ones to recreate. Taking our typical search screen view model, we definitely want to save and restore the search query, so we annotate the public property with the [DataMember] attribute. We don't want to save the state of the commands to the disk, so we mark the command with the [IgnoreDataMember] attribute. These attributes are available in the standard library, but one can easily use other annotations, for example, [JsonProperty] or [JsonIgnore].
`[DataMember]` `[IgnoreDataMember]` `[JsonProperty]` `[JsonIgnore]` ```bash
[DataContract]public class MainViewModel : ReactiveObject{  private string _searchQuery;  public MainViewModel()   {    var canSearch = this      .WhenAnyValue(x => x.SearchQuery)      .Select(query => !string.IsNullOrWhiteSpace(query));        Search = ReactiveCommand.CreateFromTask(      () => Task.Delay(1000), // a long-running operation      canSearch);  }  [IgnoreDataMember]  public ReactiveCommand<Unit, Unit> Search { get; }    [DataMember]  public string SearchQuery   {    get => _searchQuery;    set => this.RaiseAndSetIfChanged(ref _searchQuery, value);  }}
```
There is no need to save the state of a reactive command which implements the ICommand interface. ReactiveCommand<TIn, TOut> class is typically initialized in the constructor, its CanExecute indicator usually fully depends on view model properties and gets recalculated each time any of those properties change.
`ICommand` `ReactiveCommand<TIn, TOut>` `CanExecute` #### Creating The View​
Next, we modify the MainWindow class to follow the standard ReactiveUI pattern.
`MainWindow` ```bash
public class MainWindow : ReactiveWindow<MainViewModel>{  public MainWindow()  {    AvaloniaXamlLoader.Load(this);    this.WhenActivated(disposable => { });  }}
```
The XAML of our ReactiveWindow will look like as follows:
`ReactiveWindow` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    x:Class="ReactiveUI.Samples.Suspension.MainWindow"    Title="ReactiveUI.Samples.Suspension">  <TextBox Text="{Binding SearchQuery, Mode=TwoWay}"       Watermark="Place, enter the search query"       Margin="20" /></Window>
```
#### Creating The Suspension Driver​
Here we provide the implementation that uses Newtonsoft.Json and saves the application state to a plain text file.
`Newtonsoft.Json` ```bash
public class NewtonsoftJsonSuspensionDriver : ISuspensionDriver{  private readonly string _file;  private readonly JsonSerializerSettings _settings = new JsonSerializerSettings  {    TypeNameHandling = TypeNameHandling.All  };  public NewtonsoftJsonSuspensionDriver(string file) => _file = file;  public IObservable<Unit> InvalidateState()  {    if (File.Exists(_file))       File.Delete(_file);    return Observable.Return(Unit.Default);  }  public IObservable<object> LoadState()  {    var lines = File.ReadAllText(_file);    var state = JsonConvert.DeserializeObject<object>(lines, _settings);    return Observable.Return(state);  }  public IObservable<Unit> SaveState(object state)  {    var lines = JsonConvert.SerializeObject(state, _settings);    File.WriteAllText(_file, lines);    return Observable.Return(Unit.Default);  }}
```
#### Wiring The Things Together​
On the final step, we initialize the AutoSuspendHelper, following the new Avalonia lifetimes pattern. In the App.xaml.cs file we create an override for the OnFrameworkInitializationCompleted method and initialize the variables required for the suspension feature to work fine.
`AutoSuspendHelper` `App.xaml.cs` `OnFrameworkInitializationCompleted` ```bash
public class App : Application{  public override void Initialize() => AvaloniaXamlLoader.Load(this);  public override void OnFrameworkInitializationCompleted()  {    // Create the AutoSuspendHelper.    var suspension = new AutoSuspendHelper(ApplicationLifetime);    RxApp.SuspensionHost.CreateNewAppState = () => new MainViewModel();    RxApp.SuspensionHost.SetupDefaultSuspendResume(new NewtonsoftJsonSuspensionDriver("appstate.json"));    suspension.OnFrameworkInitializationCompleted();    // Load the saved view model state.    var state = RxApp.SuspensionHost.GetAppState<MainViewModel>();    new MainWindow {DataContext = state}.Show();    base.OnFrameworkInitializationCompleted();  }}
```
In the Program.cs file, we add a call to .UseReactiveUI() to the app builder.
`Program.cs` `.UseReactiveUI()` ```bash
internal static class Program{  public static void Main(string[] args) => BuildAvaloniaApp()    .StartWithClassicDesktopLifetime(args);  public static AppBuilder BuildAvaloniaApp()    => AppBuilder.Configure<App>()      .UsePlatformDetect()      .UseReactiveUI()      .LogToDebug();}
```
Now, we can run the app. If we type some text into the TextBox, it will be present there even if we close the app instance and launch a new one. The state is saved to the appstate.json file which is placed near the program executable.
`TextBox` `appstate.json` ```bash
# If you are targeting .NET Core 3, then use# netcoreapp3.0 as the CLI argument.dotnet run --framework netcoreapp2.1
```
See the "Saving Routing State to the Disk in a Cross-Platform .NET Core GUI App with ReactiveUI and Avalonia" blog post to explore how to combine the data persistence feature with ReactiveUI routing and dependency injection. See also the source code of the sample app in the ReactiveUI.Samples repository.
- Annotating The ViewModel
- Creating The View
- Creating The Suspension Driver
- Wiring The Things Together
# Binding to Sorted/Filtered Data | Avalonia Docs
- Deep Dives
- ReactiveUI
- Binding to Sorted/Filtered Data
## Binding to Sorted/Filtered Data
A common UI task that applications need to do is display sorted and/or filtered 'views' of data. In Avalonia this can be accomplished by connecting a SourceCache<TObject, TKey> or a SourceList<T> to a ReadOnlyObservableCollection<T> and binding to that collection
`SourceCache<TObject, TKey>` `SourceList<T>` `ReadOnlyObservableCollection<T>` ### Creating a Source Cache​
SourceCache<TObject, TKey> or SourceList<T> come from Dynamic Data in ReactiveUI Example:
`SourceCache<TObject, TKey>` `SourceList<T>` ```bash
// (x => x.Id) property that serves as the unique key for the cacheprivate SourceCache<TestViewModel, Guid> _sourceCache = new (x => x.Id);
```
Then the _sourceCache can be populated through the AddOrUpdate method
`_sourceCache` `AddOrUpdate` ### Creating Sorted Or Filtered Views​
Next the ReadOnlyObservableCollection<T> can be bound to the filtered or sorted _sourceCache. The sorting/filtering is done similarly to Linq.
`ReadOnlyObservableCollection<T>` `_sourceCache` ```bash
private readonly ReadOnlyObservableCollection<TestViewModel> _testViewModels;public ReadOnlyObservableCollection<TestViewModel> TestViewModels => _testViewModels;...public MainWindowViewModel(){  // Populate the source cache via _sourceCache.AddOrUpdate  ...  _sourceCache.Connect()    // Sort Ascending on the OrderIndex property    .Sort(SortExpressionComparer<TestViewModel>.Ascending(t => t.OrderIndex))    .Filter(x => x.Id.ToString().EndsWith('1'))    // Bind to our ReadOnlyObservableCollection<T>    .Bind(out _testViewModels)    // Subscribe for changes    .Subscribe();}
```
### Binding​
Now that the _sourceCache is created and populated and the ReadOnlyObservableCollection<T> is created and bound we can go into our view and bind exactly the way we normally would with an ObservableCollection<T>
`_sourceCache` `ReadOnlyObservableCollection<T>` `ObservableCollection<T>` ```bash
<Design.DataContext>  <vm:MainWindowViewModel/></Design.DataContext><TreeView ItemsSource="{Binding TestViewModels}">  <TreeView.DataTemplates>    !-- DataTemplate Definitions -->  </TreeView.DataTemplates> </TreeView>
```
- Creating a Source Cache
- Creating Sorted Or Filtered Views
- Binding
# SplitView | Avalonia Docs
- Reference
- Controls Reference
- SplitView
## SplitView
A SplitView presents a container with two parts: the main content zone and a side pane. The main content zone is always visible. The pane can be expanded and collapsed. The collapsed pane can be completely hidden, or left slightly open - with enough space to host some icon buttons for example.
`SplitView` ### Useful Properties​
You will probably use these properties most often:
`PanePlacement` `IsPaneOpen` `DisplayMode` `OpenPaneLength` `CompactPaneLength` The display mode property controls how the pane is drawn in its open and closed states. There are four options:
- Overlay The pane is completely hidden until opened. When open, the pane overlays the content area.
- Inline The pane is always visible, is a fixed width, and does not overlay the content area. The pane and content areas divide the available screen real estate, but if the container changes width, it is the content zone that resizes.
- Compact Overlay A narrow portion of the pane is always visible in this mode, which is just wide enough to show icons. The default closed pane width is 48px, which can be modified with the CompactPaneLengthproperty value. If the pane is opened, it will overlay the content area.
- Compact Inline A narrow portion of the pane is always visible in this mode, which is just wide enough to show icons. The default closed pane width is 48px, which can be modified with CompactPaneLength property value. If the pane is opened, it will reduce the size of the content zone.
Overlay
The pane is completely hidden until opened. When open, the pane overlays the content area.
Inline
The pane is always visible, is a fixed width, and does not overlay the content area. The pane and content areas divide the available screen real estate, but if the container changes width, it is the content zone that resizes.
Compact Overlay
A narrow portion of the pane is always visible in this mode, which is just wide enough to show icons. The default closed pane width is 48px, which can be modified with the CompactPaneLengthproperty value. If the pane is opened, it will overlay the content area.
`CompactPaneLength` Compact Inline
A narrow portion of the pane is always visible in this mode, which is just wide enough to show icons. The default closed pane width is 48px, which can be modified with CompactPaneLength property value. If the pane is opened, it will reduce the size of the content zone.
`CompactPaneLength` ### Example​
```bash
<SplitView IsPaneOpen="True"      DisplayMode="Inline"      OpenPaneLength="300">  <SplitView.Pane>    <TextBlock Text="Pane"          FontSize="24"          VerticalAlignment="Center"          HorizontalAlignment="Center"/>  </SplitView.Pane>  <Grid>    <TextBlock Text="Content"          FontSize="24"          VerticalAlignment="Center"          HorizontalAlignment="Center"/>  </Grid></SplitView>
```
The control looks like this, running on Windows:
### Compact Display Mode​
You can use the MVVM pattern with the split view control and one of the compact display mode settings to implement a 'tool pane' style UI. There is enough room on the pane when it is closed to display an icon button that opens the pane.
![](https://docs.avaloniaui.net/assets/images/splitview-expander-964f346a66edf6d720710fc30b8e0c9c.gif)
To learn how to use the split view control in this way, see the guide here.
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub SplitView.cs
`SplitView.cs` - Useful Properties
- Example
- Compact Display Mode
- More Information
# How To Show and Hide a Split View Pane with MVVM | Avalonia Docs
- How-To Guides
- Development Guides
- How To Show and Hide a Split View Pane with MVVM
## How To Show and Hide a Split View Pane with MVVM
Content in preparation.
You can use the MVVM pattern with the split view control to implement a 'tool pane' style UI.
This technique uses a complex binding path to locate the parent view model for the
TO DO
![](https://docs.avaloniaui.net/assets/images/splitview-expander-964f346a66edf6d720710fc30b8e0c9c.gif)
# StackPanel | Avalonia Docs
- Reference
- Controls Reference
- StackPanel
## StackPanel
The StackPanel arranges its child controls by stacking them horizontally or vertically. The stack panel is often used to arrange a small subsection of the UI on a page.
`StackPanel` Inside a stack panel, if the size property perpendicular to the stack on a child control is not set, the child control will stretch to fill the available space. For example in horizontal orientation, the height of child controls will stretch if not set.
In the direction of the stack, the stack panel will always expand to fit all the child controls.
### Useful Properties​
You will probably use these properties most often:
`Orientation` `Spacing` ### Example​
The following XAML shows how to create a vertical stack panel.
```bash
<StackPanel Width="200">  <Rectangle Fill="Red" Height="50"/>  <Rectangle Fill="Blue" Height="50"/>  <Rectangle Fill="Green" Height="100"/>  <Rectangle Fill="Orange" Height="50"/></StackPanel>
```
The result shows the child controls stretched to fit the width, and the overall height of the stack panel equal to the sum of the child control heights.
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub StackPanel.cs
`StackPanel.cs` - Useful Properties
- Example
- More Information
# TabControl | Avalonia Docs
- Reference
- Controls Reference
- TabControl
## TabControl
The TabControl allows you to sub-divide a view into tab items.
`TabControl` Each tab item has a header and a content zone. The headers are presented in a strip, in the sequence they occur in the XAML. When the user clicks on a tab header, its content becomes visible, and is placed below the tab strip in the content zone of the tab control.
You can compose the UI in both the header and content zones to suit the UI requirements of your Avalonia UI app.
If you only need the function of the tab headers part of this control, consider using the tab strip instead. See here.
### Examples​
This is simple tab example. The tab content is just some text:
```bash
<TabControl Margin="5"> <TabItem Header="Tab 1">  <TextBlock Margin="5">This is tab 1 content</TextBlock> </TabItem> <TabItem Header="Tab 2">  <TextBlock Margin="5">This is tab 2 content</TextBlock> </TabItem> <TabItem Header="Tab 3">  <TextBlock Margin="5">This is tab 3 content</TextBlock> </TabItem></TabControl>
```
The tab control even works in the preview pane!
![](https://docs.avaloniaui.net/assets/images/tabcontrol-navigation-d059c5196141926c09753ea98c022441.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TabControl.cs
`TabControl.cs` - Examples
- More Information
# TabStrip | Avalonia Docs
- Reference
- Controls Reference
- TabStrip
## TabStrip
Displays a strip of tab headers. You can use this control as a horizontal menu.
The tab strip is comprised <TabItem> elements. These are displayed in the sequence that they appear in the XAML.
`<TabItem>` ### Useful Property​
You will probably use this property most often:
`TabItem.Header` ### Example​
```bash
<TabStrip Margin="5"> <TabItem Header="Tab 1"/> <TabItem Header="Tab 2"/> <TabItem Header="Tab 3"/></TabStrip>
```
It looks like this running on Windows:
![](https://docs.avaloniaui.net/assets/images/tabstrip-navigation-befd2ff89a1e5b392bc7a81c550fccba.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub TabStrip.cs
`TabStrip.cs` - Useful Property
- Example
- More Information
# Flat Tree Data Grid | Avalonia Docs
- Reference
- Controls Reference
- TreeDataGrid
- Flat Tree Data Grid
## Flat Tree Data Grid
### Example​
In this example the view model contains an observable collection that is filled with data and then used to create a FlatTreeDataGridSource property to bind to the source of the tree data grid. The items of the grid are class Person.
`FlatTreeDataGridSource` `Person` ```bash
<TreeDataGrid Source="{Binding PersonSource}"/>
```
```bash
using Avalonia.Controls.Models.TreeDataGrid;using Avalonia.Controls;using AvaloniaControls.Models;using System.Collections.ObjectModel;using System.Linq;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    private ObservableCollection<Person> _people;    public FlatTreeDataGridSource<Person> PersonSource { get; }    public MainWindowViewModel()    {      _people = new ObservableCollection<Person>()      {        new Person ("Eleanor", "Pope", 32 ),        new Person ("Jeremy", "Navarro", 74 ),        new Person ( "Lailah ", "Velazquez", 16 ),        new Person ( "Jazmine", "Schroeder", 52 ),      };                   PersonSource = new FlatTreeDataGridSource<Person>(_people)      {        Columns =        {          new TextColumn<Person, string>            ("First Name", x => x.FirstName),          new TextColumn<Person, string>            ("Last Name", x => x.LastName),          new TextColumn<Person, int>            ("Age", x => x.Age),        },      };    }  }}
```
```bash
public class Person{  public string FirstName { get; set; }  public string LastName { get; set; }  public int Age { get; set; }  public Person(string firstName, string lastName, int age)  {    FirstName = firstName;    LastName = lastName;    Age = age;  }}
```
The data source also defines how to map the data model to rows and columns in the tree data grid. Because this example displays flat data, the data source is using a FlatTreeDataGridSource<Person> property on the view model.
`FlatTreeDataGridSource<Person>` There are three columns defined with the TextColumn class. Each takes a lambda to return the column value.
`TextColumn` ![](https://docs.avaloniaui.net/assets/images/treedatagrid-flat-997441018a88a452115c4b79edde0886.gif)
- Example
# Hierarchical Tree Data Grid | Avalonia Docs
- Reference
- Controls Reference
- TreeDataGrid
- Hierarchical Tree Data Grid
## Hierarchical Tree Data Grid
### Example​
In this example the view model contains an observable collection that is filled with data and then used to create a HierarchicalTreeDataGridSource property to bind on to the source of the tree data grid. The items of the grid are class Person.
`HierarchicalTreeDataGridSource` `Person` ```bash
<TreeDataGrid Source="{Binding PersonSource}"/>
```
```bash
using Avalonia.Controls.Models.TreeDataGrid;using Avalonia.Controls;using AvaloniaControls.Models;using System.Collections.ObjectModel;using System.Linq;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    private ObservableCollection<Person> _people;    public HierarchicalTreeDataGridSource<Person> PersonSource { get; }    public MainWindowViewModel()    {      _people = new ObservableCollection<Person>()      {        new Person        {          FirstName = "Eleanor",           LastName = "Pope",          Age = 32,          Children =          {            new Person            {               FirstName = "Marcel",               LastName = "Gutierrez",               Age = 4             },          }        },        new Person        {          FirstName = "Jeremy",          LastName = "Navarro",          Age = 74,          Children =          {            new Person            {              FirstName = "Jane",              LastName = "Navarro",              Age = 42 ,              Children =              {                new Person                 {                   FirstName = "Lailah ",                   LastName = "Velazquez",                   Age = 16                 }              }            },          }        },        new Person         {           FirstName = "Jazmine",           LastName = "Schroeder",           Age = 52         },      };      PersonSource = new HierarchicalTreeDataGridSource<Person>(_people)      {        Columns =        {          new HierarchicalExpanderColumn<Person>(            new TextColumn<Person, string>              ("First Name", x => x.FirstName),x => x.Children),          new TextColumn<Person, string>              ("Last Name", x => x.LastName),          new TextColumn<Person, int>("Age", x => x.Age),        },      };    }  }}
```
```bash
public class Person{  public string? FirstName { get; set; }  public string? LastName { get; set; }  public int Age { get; set; }  public ObservableCollection<Person> Children { get; } = new();}
```
The data source also defines how to map the data model to rows and columns in the tree data grid. Because this example displays hierarchical data, the data source is using a HierarchicalTreeDataGridSource<Person> property on the view model.
`HierarchicalTreeDataGridSource<Person>` There are three columns defined:
The first column is defined with a HierarchicalExpanderColumn surrounding. This element contains a TextColumn that takes a lambda to return the column value, and another that returns the children for the row. The column will display with a chevron button that expands or contracts the child rows (if any). The remaining columns are defined with TextColumn alone.
`HierarchicalExpanderColumn` `TextColumn` `TextColumn` ![](https://docs.avaloniaui.net/assets/images/treedatagrid-hierarchical-ff54b5616c1709c2ebd814afbbe6a2ef.gif)
- Example
# Creating in Code | Avalonia Docs
- Deep Dives
- Data Templates
- Creating in Code
## Creating in Code
Avalonia UI supports creating a data template in code. You can do this by using the FuncDataTemplate<T> class that supports the IDataTemplate interface.
`FuncDataTemplate<T>` `IDataTemplate` At its simplest you can create a data template by passing a lambda function that creates a control to the FuncDataTemplate<T> constructor, like this:
`FuncDataTemplate<T>` ```bash
var template = new FuncDataTemplate<Student>((value, namescope) =>  new TextBlock  {    [!TextBlock.TextProperty] = new Binding("FirstName"),  });
```
Which is equivalent to the XAML:
```bash
<DataTemplate DataType="{x:Type local:Student}">  <TextBlock Text="{Binding FirstName}"/></DataTemplate>
```
### More Examples​
Have a look at some more advanced uses of the FuncDataTemplate<T>class in the Avalonia UI sample project here.
`FuncDataTemplate<T>` - More Examples
# Taking More Control in Code | Avalonia Docs
- Deep Dives
- Data Templates
- Taking More Control in Code
## Taking More Control in Code
If you need take more control over a data template in code, you can write a class that implements the IDataTemplate interface yourself. This will allow you to present the properties of your bound data type in whatever way you require.
`IDataTemplate` To use the IDataTemplateinterface you must implement the following two members in your data template class:
`IDataTemplate` - public bool Match(object data) { ... } - implement this member to check whether the provided bound data matches your IDataTemplate or not. Return true if the bound data type matches, otherwise false.
- public Control Build(object param) { ... } - implement this member to build and return the control that will present your data.
`public bool Match(object data) { ... }` `IDataTemplate` `public Control Build(object param) { ... }` ### Example​
This is a simple implementation of the IDataTemplate interface to display some string data in a text block:
`IDataTemplate` ```bash
using Avalonia.Controls.Templates;...public class MyDataTemplate : IDataTemplate{  public Control Build(object param)  {    return new TextBlock() { Text = (string)param };  }  public bool Match(object data)  {    return data is string;  }}
```
You can now use the class MyDataTemplate in your view, like this:
`MyDataTemplate` ```bash
<!-- xmlns:dataTemplates="using:MyApp.DataTemplates" --><ContentControl Content="{Binding MyContent}">	<ContentControl.ContentTemplate>		<dataTemplates:MyDataTemplate />	</ContentControl.ContentTemplate></ContentControl>
```
### More Examples​
Have a look at some more advanced implementations of the IDataTemplate interface in the Avalonia UI sample project here.
`IDataTemplate` - Example
- More Examples
# Headless Platform | Avalonia Docs
- Deep Dives
- Headless Platform
## Headless Platform
### Introduction​
The headless platform in AvaloniaUI provides the capability to run Avalonia applications without a visible graphical user interface (GUI). This allows for testing and automation scenarios on systems that lack a graphical environment, such as servers or continuous integration/continuous deployment (CI/CD) environments.
By utilizing the headless platform, you can perform UI testing, execute application scenarios, and validate functionality in a headless environment, saving time and resources compared to manual testing.
### Getting Started​
While the Headless platform can be initialized without any dependencies, for convenience, we have created integration packages for common unit testing platforms:
- Headless Testing with XUnit
- Headless Testing with NUnit
- If you are using another platform or need more control: Manual setup of the Headless platform
### Simulating User Input​
As the headless platform doesn't have any real input, every event needs to be raised from the unit test. The Avalonia.Headless package is shipped with a number of helper methods that can be used:
##### Window.KeyPress(Key key, RawInputModifiers modifiers, PhysicalKey physicalKey, string? keySymbol)​
`Window.KeyPress(Key key, RawInputModifiers modifiers, PhysicalKey physicalKey, string? keySymbol)` ##### Window.KeyPressQwerty(PhysicalKey physicalKey, RawInputModifiers modifiers)​
`Window.KeyPressQwerty(PhysicalKey physicalKey, RawInputModifiers modifiers)` Simulates a keyboard press on the headless window/toplevel.
##### Window.KeyRelease(Key key, RawInputModifiers modifiers, PhysicalKey physicalKey, string? keySymbol)​
`Window.KeyRelease(Key key, RawInputModifiers modifiers, PhysicalKey physicalKey, string? keySymbol)` ##### Window.KeyReleaseQwerty(PhysicalKey physicalKey, RawInputModifiers modifiers)​
`Window.KeyReleaseQwerty(PhysicalKey physicalKey, RawInputModifiers modifiers)` Simulates a keyboard release on the headless window/toplevel.
##### Window.KeyTextInput(string text)​
`Window.KeyTextInput(string text)` Simulates a text input event on the headless window/toplevel.
This event is independent of KeyPress and KeyRelease. If you need to simulate text input to a TextBox or a similar control, please use KeyTextInput.
##### Window.MouseDown(Point point, MouseButton button, RawInputModifiers modifiers)​
`Window.MouseDown(Point point, MouseButton button, RawInputModifiers modifiers)` Simulates a mouse down event on the headless window/toplevel.
In the headless platform, there is a single mouse pointer. There are no helper methods for touch or pen input.
##### Window.MouseMove(Point point, MouseButton button, RawInputModifiers modifiers)​
`Window.MouseMove(Point point, MouseButton button, RawInputModifiers modifiers)` Simulates a mouse move event on the headless window/toplevel.
##### Window.MouseUp(Point point, MouseButton button, RawInputModifiers modifiers)​
`Window.MouseUp(Point point, MouseButton button, RawInputModifiers modifiers)` Simulates a mouse up event on the headless window/toplevel.
##### Window.MouseWheel(Point point, Vector delta, RawInputModifiers modifiers)​
`Window.MouseWheel(Point point, Vector delta, RawInputModifiers modifiers)` Simulates a mouse wheel event on the headless window/toplevel.
##### Window.DragDrop(Point point, RawDragEventType type, DataObject data, DragDropEffects effects, RawInputModifiers modifiers)​
`Window.DragDrop(Point point, RawDragEventType type, DataObject data, DragDropEffects effects, RawInputModifiers modifiers)` Simulates a drag and drop target event on the headless window/toplevel. This event simulates a user moving files from another app to the current app.
A simple button click test is a typical example where these methods can be used:
```bash
// Create window and button:var button = new Button{  HorizontalAlignment = HorizontalAlignment.Stretch,  VerticalAlignment = VerticalAlignment.Stretch};var window = new Window{  Width = 100,  Height = 100,  Content = button};// Subscribe to the button click event:var buttonClicked = false;button.Click += (_, _) => buttonClicked = true;// Show the window:window.Show();// Simulate mouse events with a click (mouse down + up):window.MouseDown(new Point(50, 50), MouseButton.Left);window.MouseUp(new Point(50, 50), MouseButton.Left);// Assert that the button was clicked:Assert.True(buttonClicked);
```
Just like in any other Avalonia application, it's also possible to raise events directly. For example, with button click button.RaiseEvent(new RoutedEventArgs(Button.ClickEvent)). This can be more convenient for most use cases but lacks some flexibility with input parameters. RaiseEvent will trigger the click event on the button but a bound command will not be executed. If you need to test a button command you can use button.Focus() together with window.KeyReleaseQwerty(PhysicalKey.Space, RawInputModifiers.None).
`button.RaiseEvent(new RoutedEventArgs(Button.ClickEvent))` `button.Focus()` `window.KeyReleaseQwerty(PhysicalKey.Space, RawInputModifiers.None)` ### Capturing the Last Rendered Frame​
By default, the Headless platform doesn't render anything and instead has a fake/headless drawing backend enabled. However, it is possible to enable the Skia renderer and use it to capture the last rendered frame, which can be compared with an expected image or used in another way.
To enable the Skia renderer, adjust the AppBuilder code as follows:
```bash
public static AppBuilder BuildAvaloniaApp() => AppBuilder.Configure<TestApplication>()  .UseSkia() // enable Skia renderer  .UseHeadless(new AvaloniaHeadlessPlatformOptions  {    UseHeadlessDrawing = false // disable headless drawing  });
```
With the real renderer enabled, you can use the Window.CaptureRenderedFrame helper method:
`Window.CaptureRenderedFrame` ```bash
var window = new Window{  Content = new TextBlock  {    Text = "Hello World"  }};window.Show();var frame = window.CaptureRenderedFrame();frame.Save("file.png");
```
The CaptureRenderedFrame method returns a WriteableBitmap, allowing you to lock it and read pixel data that can be compared in memory.
`CaptureRenderedFrame` ### Simulating User Delay​
In real UI applications, there is always some delay between user interactions, which gives the operating system time to run various tasks in the application. These tasks are often delayed and might include operations such as window resize, which on most platforms (including Headless), is asynchronous.
This delay can result in unexpected behavior when some operations have not yet executed.
Obvious solution would be to add Task.Delay between these operations, but a more efficient option in Avalonia would be to use the Dispatcher API, which allows flushing the jobs queue directly:
`Task.Delay` `Dispatcher` ```bash
var window = new Window();window.Show();window.Width = 100;window.Height = 100;Dispatcher.UIThread.RunJobs();Assert.AreEqual(new Size(100, 100), window.ClientSize);
```
Additionally, the headless platform provides a method to force the render timer to tick, which can be useful in some scenarios:
```bash
AvaloniaHeadlessPlatform.ForceRenderTimerTick();
```
All input helper methods and CaptureRenderedFrame internally use these user delay methods, so there is no need to run them twice!
`CaptureRenderedFrame` - Introduction
- Getting Started
- Simulating User Input
- Capturing the Last Rendered Frame
- Simulating User Delay
# Headless Testing with XUnit | Avalonia Docs
- Deep Dives
- Headless Platform
- Headless Testing with XUnit
## Headless Testing with XUnit
### Preparation​
This page assumes that XUnit project was already created. If not, please follow XUnit "Getting Started" and "Installation" here https://xunit.net/docs/getting-started/netfx/visual-studio.
### Install packages​
Aside from XUnit packages, we need to install two more packages:
- Avalonia.Headless.XUnit which also includes Avalonia.
- Avalonia.Themes.Fluent as even headless controls need a theme
Headless platform doesn't require any specific theme, and it is possible to swap FluentTheme with any other.
### Setup Application​
As in any other Avalonia app, an Application instance needs to be created, and themes need to be applied. When using the Headless platform, the setup is not much different from a regular Avalonia app and can mostly be reused.
`Application` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="Tests.App"> <Application.Styles>  <FluentTheme /> </Application.Styles></Application>
```
And the code:
```bash
using Avalonia;using Avalonia.Headless;public class App : Application{  public override void Initialize()  {    AvaloniaXamlLoader.Load(this);  }}
```
Usually, the BuildAvaloniaApp method is defined in the Program.cs file, but NUnit/XUnit tests don't have it, so it is defined in the App file instead.
`BuildAvaloniaApp` `App` ### Initialize XUnit Tests​
The [AvaloniaTestApplication] attribute wires the tests in the current project with the specific application. It needs to be defined once per project in any file.
`[AvaloniaTestApplication]` ```bash
[assembly: AvaloniaTestApplication(typeof(TestAppBuilder))]public class TestAppBuilder{  public static AppBuilder BuildAvaloniaApp() => AppBuilder.Configure<App>()    .UseHeadless(new AvaloniaHeadlessPlatformOptions());}
```
### Test Example​
```bash
[AvaloniaFact]public void Should_Type_Text_Into_TextBox(){  // Setup controls:  var textBox = new TextBox();  var window = new Window { Content = textBox };  // Open window:  window.Show();  // Focus text box:  textBox.Focus();  // Simulate text input:  window.KeyTextInput("Hello World");  // Assert:  Assert.Equal("Hello World", textBox.Text);}
```
Instead of the typical [Fact] attribute, we need to use [AvaloniaFact] as it sets up the UI thread. Similarly, instead of [Theory], there is a [AvaloniaTheory] attribute.
`[Fact]` `[AvaloniaFact]` `[Theory]` `[AvaloniaTheory]` - Preparation
- Install packages
- Setup Application
- Initialize XUnit Tests
- Test Example
# Headless Testing with NUnit | Avalonia Docs
- Deep Dives
- Headless Platform
- Headless Testing with NUnit
## Headless Testing with NUnit
### Preparation​
This page assumes that NUnit project was already created. If not, please follow NUnit "Getting Started" and "Installation" here https://docs.nunit.org/articles/nunit/getting-started/installation.html.
### Install packages​
Aside from NUnit packages, we need to install two more packages:
- Avalonia.Headless.NUnit which also includes Avalonia.
- Avalonia.Themes.Fluent as even headless controls need a theme
Headless platform doesn't require any specific theme, and it is possible to swap FluentTheme with any other.
### Setup Application​
As in any other Avalonia app, an Application instance needs to be created, and themes need to be applied. When using the Headless platform, the setup is not much different from a regular Avalonia app and can mostly be reused.
`Application` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="Tests.App"> <Application.Styles>  <FluentTheme /> </Application.Styles></Application>
```
And the code:
```bash
using Avalonia;using Avalonia.Headless;public class App : Application{  public override void Initialize()  {    AvaloniaXamlLoader.Load(this);  }}
```
Usually, the BuildAvaloniaApp method is defined in the Program.cs file, but NUnit/XUnit tests don't have it, so it is defined in the App file instead.
`BuildAvaloniaApp` `App` ### Initialize NUnit Tests​
The [AvaloniaTestApplication] attribute wires the tests in the current project with the specific application. It needs to be defined once per project in any file.
`[AvaloniaTestApplication]` ```bash
[assembly: AvaloniaTestApplication(typeof(TestAppBuilder))]public class TestAppBuilder{  public static AppBuilder BuildAvaloniaApp() => AppBuilder.Configure<App>()    .UseHeadless(new AvaloniaHeadlessPlatformOptions());}
```
### Test Example​
```bash
[AvaloniaTest]public void Should_Type_Text_Into_TextBox(){  // Setup controls:  var textBox = new TextBox();  var window = new Window { Content = textBox };  // Open window:  window.Show();  // Focus text box:  textBox.Focus();  // Simulate text input:  window.KeyTextInput("Hello World");  // Assert:  Assert.AreEqual("Hello World", textBox.Text);}
```
Instead of the typical [Test] attribute, we need to use [AvaloniaTest] as it sets up the UI thread. Similarly, instead of [Theory], there is a [AvaloniaTheory] attribute.
`[Test]` `[AvaloniaTest]` `[Theory]` `[AvaloniaTheory]` - Preparation
- Install packages
- Setup Application
- Initialize NUnit Tests
- Test Example
# Manual Setup of Headless Platform | Avalonia Docs
- Deep Dives
- Headless Platform
- Manual Setup of Headless Platform
## Manual Setup of Headless Platform
This page explains an advanced usage scenario with the Headless platform. We recommend using the XUnit or NUnit testing frameworks instead.
### Install Packages​
To set up the Headless platform, you need to install two packages:
- Avalonia.Headless, which also includes Avalonia.
- Avalonia.Themes.Fluent, as even headless controls need a theme.
The Headless platform doesn't require any specific theme, and it is possible to swap FluentTheme with any other.
### Setup Application​
As in any other Avalonia app, an Application instance needs to be created, and themes need to be applied. When using the Headless platform, the setup is not much different from a regular Avalonia app and can mostly be reused.
`Application` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="Tests.App"> <Application.Styles>  <FluentTheme /> </Application.Styles></Application>
```
And the code:
```bash
using Avalonia;using Avalonia.Headless;public class App : Application{  public override void Initialize()  {    AvaloniaXamlLoader.Load(this);  }}
```
### Run Headless Session​
```bash
using Avalonia.Controls;using Avalonia.Headless;// Start Headless session passing Application type.using var session = HeadlessUnitTestSession.StartNew(typeof(App));// Since the Headless session has its own thread internally, we need to dispatch actions there:await session.Dispatch(() =>{  // Setup controls:  var textBox = new TextBox();  var window = new Window { Content = textBox };  // Open window:  window.Show();  // Focus text box:  textBox.Focus();  // Simulate text input:  window.KeyTextInput("Hello World");  // Assert:  if (textBox.Text != "Hello World")  {    throw new Exception("Assert");  }}, CancellationToken.None);
```
- Install Packages
- Setup Application
- Run Headless Session
# Window | Avalonia Docs
- Reference
- Controls Reference
- Window
## Window
Window is a top-level ContentControl.
`Window` `ContentControl` You will not usually create instances of the Window class directly; instead the Window class is usually sub-classed for each type of window to be shown by an application. For information on how to create new window classes from templates see the quickstart.
`Window` `Window` #### Common Properties​
`Title` `Icon` `SizeToContent` `WindowState` #### Source code​
Window.cs
#### Show, hide and close a window​
You can show a window using the Show method:
`Show` ```bash
var window = new MyWindow();window.Show();
```
Windows can be closed using the Close method. This has the same effect as when a user clicks the window's close button:
`Close` ```bash
window.Close();// A closed window cannot be shown.window.Show();
```
Note that once a window has been closed, it cannot be shown again. If you want to re-show the window then you should use the Hide method:
`Hide` ```bash
window.Hide();// Window can now be shown again laterwindow.Show();
```
See also Prevent a window from closing
#### Show a window as a dialog​
You can show a window as a modal dialog by calling the ShowDialog method. ShowDialog requires an owner window to be passed:
`ShowDialog` `ShowDialog` ```bash
// Here we assume this code is executed from our current Window class and "this" object is a Window.// Alternatively you can get global MainWindow from Application.ApplicationLifetime casted to IClassicDesktopStyleApplicationLifetime.var ownerWindow = this;var window = new MyWindow();window.ShowDialog(ownerWindow);
```
The ShowDialog method will return immediately. If you want to wait for the dialog to be closed, you can await the call:
`ShowDialog` `await` ```bash
var window = new MyWindow();await window.ShowDialog(ownerWindow);
```
Dialogs can return a result by calling the Close method with an object. This result can then be read by the caller of ShowDialog. For example:
`Close` `ShowDialog` ```bash
public class MyDialog : Window{  public MyDialog()  {    InitializeComponent();  }  private void OkButton_Click(object sender, EventArgs e)  {    Close("OK Clicked!");  }}
```
```bash
var dialog = new MyDialog();// The result is a string so call `ShowDialog<string>`.var result = await dialog.ShowDialog<string>(ownerWindow);
```
#### Prevent a window from closing​
A window can be prevented from closing by handling the Closing event and setting e.Cancel = true:
`Closing` `e.Cancel = true` ```bash
window.Closing += (s, e) =>{  e.Cancel = true;};
```
You could also hide the window instead. This allows the window to be re-shown after the user clicks the close button:
```bash
window.Closing += (s, e) =>{  ((Window)s).Hide();  e.Cancel = true;};
```
### Additional Resources​
- The Main Window
- Common Properties
- Source code
- Show, hide and close a window
- Show a window as a dialog
- Prevent a window from closing
- Additional Resources
# Starting with the CLI | Avalonia Docs
## Starting with the CLI
If you build your projects with the .NET CLI, then follow the procedures here to install the Avalonia UI templates and create your first application.
### Install Avalonia UI Templates​
To install the Avalonia UI templates, run the following command:
```bash
dotnet new install Avalonia.Templates
```
Note: For .NET 6.0 and earlier, you must use --install instead.
`--install` ### Create a new Application​
Once the templates are installed, you can create a new Avalonia UI application by running the following command:
```bash
dotnet new avalonia.app -o MyApp
```
This will create a new folder called MyApp containing your application files. To run the application, navigate to the MyApp folder and run:
`MyApp` `MyApp` ```bash
cd MyAppdotnet run
```
That is all there is to it! Your Avalonia UI application is now up and running. Next you can open the MyApp folder to start improving and building your application further.
`MyApp` - Install Avalonia UI Templates
- Create a new Application
# Window | Avalonia Docs
- Reference
- Controls Reference
- Window
## Window
Window is a top-level ContentControl.
`Window` `ContentControl` You will not usually create instances of the Window class directly; instead the Window class is usually sub-classed for each type of window to be shown by an application. For information on how to create new window classes from templates see the quickstart.
`Window` `Window` #### Common Properties​
`Title` `Icon` `SizeToContent` `WindowState` #### Source code​
Window.cs
#### Show, hide and close a window​
You can show a window using the Show method:
`Show` ```bash
var window = new MyWindow();window.Show();
```
Windows can be closed using the Close method. This has the same effect as when a user clicks the window's close button:
`Close` ```bash
window.Close();// A closed window cannot be shown.window.Show();
```
Note that once a window has been closed, it cannot be shown again. If you want to re-show the window then you should use the Hide method:
`Hide` ```bash
window.Hide();// Window can now be shown again laterwindow.Show();
```
See also Prevent a window from closing
#### Show a window as a dialog​
You can show a window as a modal dialog by calling the ShowDialog method. ShowDialog requires an owner window to be passed:
`ShowDialog` `ShowDialog` ```bash
// Here we assume this code is executed from our current Window class and "this" object is a Window.// Alternatively you can get global MainWindow from Application.ApplicationLifetime casted to IClassicDesktopStyleApplicationLifetime.var ownerWindow = this;var window = new MyWindow();window.ShowDialog(ownerWindow);
```
The ShowDialog method will return immediately. If you want to wait for the dialog to be closed, you can await the call:
`ShowDialog` `await` ```bash
var window = new MyWindow();await window.ShowDialog(ownerWindow);
```
Dialogs can return a result by calling the Close method with an object. This result can then be read by the caller of ShowDialog. For example:
`Close` `ShowDialog` ```bash
public class MyDialog : Window{  public MyDialog()  {    InitializeComponent();  }  private void OkButton_Click(object sender, EventArgs e)  {    Close("OK Clicked!");  }}
```
```bash
var dialog = new MyDialog();// The result is a string so call `ShowDialog<string>`.var result = await dialog.ShowDialog<string>(ownerWindow);
```
#### Prevent a window from closing​
A window can be prevented from closing by handling the Closing event and setting e.Cancel = true:
`Closing` `e.Cancel = true` ```bash
window.Closing += (s, e) =>{  e.Cancel = true;};
```
You could also hide the window instead. This allows the window to be re-shown after the user clicks the close button:
```bash
window.Closing += (s, e) =>{  ((Window)s).Hide();  e.Cancel = true;};
```
### Additional Resources​
- The Main Window
- Common Properties
- Source code
- Show, hide and close a window
- Show a window as a dialog
- Prevent a window from closing
- Additional Resources
# The Main Window | Avalonia Docs
- Get Started
- Test Drive
- The Main Window
## The Main Window
You can now start your tour of an Avalonia project. We'll start with the main application window. Open the MainWindow.axaml file.
In Avalonia, XAML files have the extension .axaml (and not .xaml). This represents 'Avalonia XAML' and the file extension was introduced for technical reasons.
### What is Happening?​
In the MainWindow.axaml XAML file, the <Window>...</Window> XAML tag represents an Avalonia window. Like other Avalonia controls; the window will be drawn on the target platform with 4 layout zones: margin, border, padding and content.
`<Window>...</Window>` ### The MainWindow Content​
Inside the Windows Content, you will see a <TextBlock>...</TextBlock> XAML tag. This represents a TextBlock control which draws Text to the screen. The Text property of the TextBlock is bound to the Greeting property of the MainViewModel class.
`<TextBlock>...</TextBlock>` `TextBlock` `Text` `Text` `TextBlock` The class name may appear as either:
- MainViewModel
- MainWindowViewModel
`MainViewModel` `MainWindowViewModel` Check which template your project uses to confirm the correct name.
```bash
<TextBlock Text="{Binding Greeting}" HorizontalAlignment="Center" VerticalAlignment="Center"/>
```
You can change the text in the file MainWindowViewModel.cs to see the change reflected in the user interface.
```bash
namespace GetStartedApp.ViewModels;public class MainWindowViewModel : ViewModelBase{  public string Greeting => "Welcome to Avalonia! This is my added text.";}
```
![Application running](https://docs.avaloniaui.net/img/get-started/test-drive/main-window-app-running-light.png)
![Application running](https://docs.avaloniaui.net/img/get-started/test-drive/main-window-app-running-dark.png)
For more information about the concept of control layout zones, see here.
### The XAML Previewer​
If you're using an IDE with one of our IDE Extensions installed, such as Rider, Visual Studio or Visual Studio Code, you can see live changes to your XAML code in the previewer view.
The XAML Previewer create an instance of your app in a special authoring mode, known as design mode. When your app runs in design mode, it can execute special logic that enables coordination with the visual designer. Design.IsDesignMode
`Design.IsDesignMode` - Rider
- Visual Studio
Navigate to the MainWindow.axaml file and click the Split View button at the top right of the editor window.
![Rider Avalonia Previewer Controls](https://docs.avaloniaui.net/img/get-started/test-drive/rider-previewer-controls-light.png)
![Rider Avalonia Previewer Controls](https://docs.avaloniaui.net/img/get-started/test-drive/rider-previewer-controls-dark.png)
![Rider with the Avalonia XAML Previewer Open](https://docs.avaloniaui.net/img/get-started/test-drive/rider-previewer-light.png)
![Rider with the Avalonia XAML Previewer Open](https://docs.avaloniaui.net/img/get-started/test-drive/rider-previewer-dark.png)
- Build the project.
![Avalonia XAML Previewer](https://docs.avaloniaui.net/img/get-started/test-drive/rider-preview-pane-light.png)
![Avalonia XAML Previewer](https://docs.avaloniaui.net/img/get-started/test-drive/rider-preview-pane-dark.png)
Navigate to the MainView.axaml file and click the Split View button at the top of the editor window.
![](https://docs.avaloniaui.net/assets/images/vs-previewer-9159a45a8ce7d1dd72574cc9ac17e914.png)
There may be a red exclamation icon (top left) and the message The designer is loading.... This indicates that the project must be built before the preview pane will respond.
- Build the project.
- Scroll the preview pane to the left to view the preview outline and the text displayed in the top left corner.
- Remove the binding {Binding Greeting} and change the text <TextBlock Text="my text" />
`{Binding Greeting}` `<TextBlock Text="my text" />` You will see the new text in the preview pane change as you type. This is an example of the Avalonia design-time preview behaviour that will help you develop user interface presentation accurately and quickly.
- Run the project to see your new text also appear at runtime.
On the next page, you will add a simple Button to the window.
`Button` - What is Happening?
- The MainWindow Content
- The XAML Previewer
# Create and Run a Project | Avalonia Docs
- Get Started
- Test Drive
- Create and Run a Project
## Create and Run a Project
### Create the Project​
To get started, we're going to use the MVVM Avalonia template: Avalonia MVVM Application (or avalonia.mvvm in the CLI).
`Avalonia MVVM Application` `avalonia.mvvm` - Rider
- Visual Studio
- Visual Studio Code
- Command Line
- On the Rider startup screen, select New Solution to bring up the New Solution Wizard. If you have installed the Avalonia Templates, then you will see three options. Avalonia .NET App: A template for desktop apps (Windows, macOS & Linux) that uses code-behind rather than MVVM. Avalonia .NET MVVM App: A template for desktop apps (Windows, macOS & Linux) that uses MVVM (by default with RxUI). Avalonia Cross-Platform Application: A template for all supported platforms (Windows, macOS, Linux, iOS, Android and WASM). This template requires additional workloads.
- Avalonia .NET App: A template for desktop apps (Windows, macOS & Linux) that uses code-behind rather than MVVM.
- Avalonia .NET MVVM App: A template for desktop apps (Windows, macOS & Linux) that uses MVVM (by default with RxUI).
- Avalonia Cross-Platform Application: A template for all supported platforms (Windows, macOS, Linux, iOS, Android and WASM). This template requires additional workloads.
- In the sidebar, scroll down and select Avalonia .NET MVVM App
- Type GetStartedApp in the Solution Name field
- Click Create
On the Rider startup screen, select New Solution to bring up the New Solution Wizard. If you have installed the Avalonia Templates, then you will see three options.
`New Solution` - Avalonia .NET App: A template for desktop apps (Windows, macOS & Linux) that uses code-behind rather than MVVM.
- Avalonia .NET MVVM App: A template for desktop apps (Windows, macOS & Linux) that uses MVVM (by default with RxUI).
- Avalonia Cross-Platform Application: A template for all supported platforms (Windows, macOS, Linux, iOS, Android and WASM). This template requires additional workloads.
In the sidebar, scroll down and select Avalonia .NET MVVM App
`Avalonia .NET MVVM App` ![Create Avalonia Solution with JetBrains Rider](https://docs.avaloniaui.net/img/get-started/test-drive/rider-new-solution-light.png)
![Create Avalonia Solution with JetBrains Rider](https://docs.avaloniaui.net/img/get-started/test-drive/rider-new-solution-dark.png)
Type GetStartedApp in the Solution Name field
`GetStartedApp` Click Create
The template will create a new solution and project.
![Create Avalonia Solution with JetBrains Rider](https://docs.avaloniaui.net/img/get-started/test-drive/rider-solution-light.png)
![Create Avalonia Solution with JetBrains Rider](https://docs.avaloniaui.net/img/get-started/test-drive/rider-solution-dark.png)
- In Visual Studio, click Create a new project.
- Type Avalonia in the search box.
- Click Avalonia Application then click Next.
`Avalonia` ![image](https://docs.avaloniaui.net/assets/images/vs-find-avalonia-template-screenshot-90d796497463c1577a936de6c9d76052.png)
- Name the project GetStartedApp, and click Create.
- The next screen allows selecting the platforms you wish to target: click Desktop then click Next.
- The next screen allows selecting a design pattern: click ReactiveUI then click Create.
Name the project GetStartedApp, and click Create.
`GetStartedApp` The next screen allows selecting the platforms you wish to target: click Desktop then click Next.
The next screen allows selecting a design pattern: click ReactiveUI then click Create.
The template will create a new solution and two new projects. GetStartedApp is the main project that is shared between each platform. GetStartedApp.Desktop is the platform-specific project for the desktop platform.
`GetStartedApp` `GetStartedApp.Desktop` - Bring up the Command Palette using ⇧ ⌘ P and then type ".NET" and find and select the .NET: New Project command.
`⇧ ⌘ P` ![image](https://docs.avaloniaui.net/assets/images/vscode-command-new-project-548d8b7ea82dda4230ee863529d743e4.png)
- After selecting the command, you'll need to choose the project template. Choose Avalonia MVVM app.
![image](https://docs.avaloniaui.net/assets/images/vscode-select-project-template-21d23089fbd6d9d842143ed5efd452de.png)
- Name the project GetStartedApp, and press enter.
`GetStartedApp` ![image](https://docs.avaloniaui.net/assets/images/vscode-name-new-project-349022c657b45822720cbd6e0b478121.png)
- You'll need to provide a path for where the project should be created. Do this, and then press Create project
![image](https://docs.avaloniaui.net/assets/images/vscode-create-project-c5188f9f8da1eae1610ef05a080ca903.png)
Run the command:
```bash
dotnet new avalonia.mvvm -o GetStartedApp
```
This will create a new folder called GetStartedApp containing the new project.
`GetStartedApp` ### Run the Project​
We're now ready to run the project!
- Rider
- Visual Studio
- Visual Studio Code
- Command Line
Press the Run button in the Rider toolbar:
Right-click on the GetStartedApp.Desktop project and select Set as Startup Project.
`GetStartedApp.Desktop` Hit F5 to run the project.
`F5` - Hit F5 to run the project and Select C# as the debugger
`F5` `C#` ![image](https://docs.avaloniaui.net/assets/images/vscode-select-csharp-9e228d6dfcd6e84bcdec305ba7073b4b.png)
- Select C#: GetStartedApp Demo to launch the application with the debugger connected.
![image](https://docs.avaloniaui.net/assets/images/vscode-launch-app-7c1bda04fde8938cd375191a72b3b6c2.png)
Go into the GetStartedApp directory and run:
`GetStartedApp` ```bash
dotnet run
```
The solution will build and run.
You should now be running your first Avalonia application!
![Application running](https://docs.avaloniaui.net/img/get-started/test-drive/main-window-app-running-light.png)
![Application running](https://docs.avaloniaui.net/img/get-started/test-drive/main-window-app-running-dark.png)
- Create the Project
- Run the Project
# Add a Control | Avalonia Docs
- Get Started
- Test Drive
- Add a Control
## Add a Control
So far, the main window of your application displays only a text string. On this page, you will learn how to add some of the built-in controls that are part of Avalonia.
### Button​
Avalonia contains a built-in control that creates a button. Follow this procedure to replace the text string currently in the Window's content zone with a button control.
`Window` - Stop the app if it is running.
- Locate the highlighted line of XAML in the MainWindow.xaml file.
`MainWindow.xaml` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:vm="using:GetStartedApp.ViewModels"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="450"    x:Class="GetStartedApp.Views.MainWindow"    x:DataType="vm:MainWindowViewModel"    Icon="/Assets/avalonia-logo.ico"    Title="GetStartedApp">  <Design.DataContext>    <!-- This only sets the DataContext for the previewer in an IDE,       to set the actual DataContext for runtime, set the DataContext property in code (look at App.axaml.cs) -->    <vm:MainWindowViewModel/>  </Design.DataContext>  <TextBlock Text="{Binding Greeting}" HorizontalAlignment="Center" VerticalAlignment="Center"/>  </Window>
```
- Replace the entire line with the following:
```bash
<Button>Calculate</Button>
```
- Your XAML should now look like this:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:vm="using:GetStartedApp.ViewModels"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="450"    x:Class="GetStartedApp.Views.MainWindow"    x:DataType="vm:MainWindowViewModel"    Icon="/Assets/avalonia-logo.ico"    Title="GetStartedApp">  <Design.DataContext>    <!-- This only sets the DataContext for the previewer in an IDE,       to set the actual DataContext for runtime, set the DataContext property in code (look at App.axaml.cs) -->    <vm:MainWindowViewModel/>  </Design.DataContext>    <Button>Calculate</Button>  </Window>
```
If you're using the previewer, you will see the button appear in the preview pane as soon as the XAML is valid. You can also try hovering and clicking the Button to see it change appearance in different states.
`Button` - Run the app to confirm that the presentation and behaviour of the button is the same at runtime.
### Control Attributes​
XAML uses XML attributes to specify presentation and behavior for controls. These attributes can set properties, call methods, and call event handlers in the controls created by the XAML.
For example, the Button is currently positioned hard against the left edge of the Window. This is a result of the default value (left) of its HorizontalAlignment property. Follow this procedure to set the HorizontalAlignment to centered instead.
`Button` `Window` `HorizontalAlignment` `HorizontalAlignment` - Add a new attribute to the Button tag as follows:
```bash
<Button HorizontalAlignment="Center">Calculate</Button>
```
If you're using an IDE, notice how the Avalonia code completion guides you as you add attributes to the XAML.
The Button should now move to the center of the window content zone. Horizontally because of the change and vertically because of the Button's default.
`Button` For full information about the complete range of Avalonia UI built-in controls, and their attributes, see the reference section here.
On the next page, you will learn how to create a more complex layout.
- Button
- Control Attributes
# Controls Reference | Avalonia Docs
- Reference
- Controls Reference
## Built-in Controls
Avalonia provides following groups of built-in controls:
# WrapPanel | Avalonia Docs
- Reference
- Controls Reference
- WrapPanel
## WrapPanel
The WrapPanel uses a default arrangement of (multiple) child elements is in sequence from left to right, while they fit in the width. It starts a new line when there is no space left (including any margins and borders).
`WrapPanel` When the orientation property is set to vertical, the arrangement is top to bottom with a new column started when there is no more height remaining.
### Useful Properties​
You will probably use these properties most often:
### Examples​
```bash
<WrapPanel>  <Rectangle Fill="Navy" Width="100" Height="100" Margin="20"/>  <Rectangle Fill="Yellow" Width="100" Height="100" Margin="20"/>  <Rectangle Fill="Green" Width="100" Height="100" Margin="20"/>  <Rectangle Fill="Red" Width="100" Height="100" Margin="20"/>  <Rectangle Fill="Purple" Width="100" Height="100" Margin="20"/></WrapPanel>
```
```bash
<WrapPanel Orientation="Vertical">  <Rectangle Fill="Navy" Width="100" Height="100" Margin="20"/>  <Rectangle Fill="Yellow" Width="100" Height="100" Margin="20"/>  <Rectangle Fill="Green" Width="100" Height="100" Margin="20"/>  <Rectangle Fill="Red" Width="100" Height="100" Margin="20"/>  <Rectangle Fill="Purple" Width="100" Height="100" Margin="20"/></WrapPanel>
```
#### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub WrapPanel.cs
`WrapPanel.cs` - Useful Properties
- ExamplesMore Information
- More Information
# Gestures | Avalonia Docs
- Reference
- Gestures
## Gestures
Avalonia UI provides following gesture recognizers:
- PinchGestureRecognizer
- PullGestureRecognizer
- ScrollGestureRecognizer
### ​
#### ​
### ​
# PinchGestureRecognizer | Avalonia Docs
- Reference
- Gestures
- PinchGestureRecognizer
## PinchGestureRecognizer
A gesture recognizer that tracks a pinch gesture. A pinch gesture occurs when two pointer contacts are brought towards each other, or away from each other. This is useful in controls that implements a pinch to zoom interaction.
### Using a PinchGestureRecognizer​
A PinchGestureRecognizer can be attached to a control using the control's GestureRecognizers property.
`GestureRecognizers` ```bash
<Image Stretch="UniformToFill"    Margin="5"    Name="image"    Source="/image.jpg"> <Image.GestureRecognizers>  <PinchGestureRecognizer/> </Image.GestureRecognizers></Image>
```
```bash
image.GestureRecognizers.Add(new PinchGestureRecognizer());
```
The PinchGestureRecognizer raises a Gestures.PinchEvent when it detects the start of a pull gesture. When the pull ends, from the pointer being released or another gesture start, it raises a Gestures.PinchEndedEvent. The Scale property in the args passed to the Gestures.PinchEvent event handler contains the relative size of the pinch since it started.
`Gestures.PinchEvent` `Gestures.PinchEndedEvent` `Scale` `Gestures.PinchEvent` ### Binding Events​
After the PinchGestureRecognizer has been added to your control, you need to bind them in your code behind either through an inline handler or to an event function:
```bash
image.AddHandler(Gestures.PinchEvent, (s, e) => { });image.AddHandler(Gestures.PinchEndedEvent, (s, e) => { });
```
```bash
image.AddHandler(Gestures.PinchEvent, Image_PinchGesture);image.AddHandler(Gestures.PinchEndedEvent, Image_PinchGestureEnded);...private void Image_PinchGesture(object? sender, PinchGestureEventArgs e) { }private void Image_PinchGestureEnded(object? sender, PinchGestureEndedEventArgs e) { }
```
If your event handles the gesture completely, you can mark the event as handled by setting:
```bash
e.Handled = true;
```
### More Information​
View the source code on GitHub
PinchGestureRecognizer.cs
`PinchGestureRecognizer.cs` PinchEventArgs.cs
`PinchEventArgs.cs` - Using a PinchGestureRecognizer
- Binding Events
- More Information
# PullGestureRecognizer | Avalonia Docs
- Reference
- Gestures
- PullGestureRecognizer
## PullGestureRecognizer
A gesture recognizer that tracks a pull gesture. A pull gesture occurs when a pointer is dragged from the edge of a control. The direction of the pull is defined by the PullDirection property.
`PullDirection` ### Using a PullGestureRecognizer​
A PullGestureRecognizer can be attached to a control using the control's GestureRecognizers property.
`GestureRecognizers` ```bash
<Border Width="500"    Height="500"    Margin="5"    Name="border"> <Border.GestureRecognizers>  <PullGestureRecognizer PullDirection="TopToBottom"/> </Border.GestureRecognizers></Border>
```
```bash
border.GestureRecognizers.Add(new PullGestureRecognizer()      {        PullDirection = PullDirection.TopToBottom,      });
```
The PullGestureRecognizer raises a Gestures.PullGestureEvent when it detects the start of a pull gesture. When the pull ends, from the pointer being released or another gesture start, it raises a Gestures.PullGestureEndedEvent.
`Gestures.PullGestureEvent` `Gestures.PullGestureEndedEvent` #### PullDirection​
This defines the direction of the pull. There are 4 available values;
- PullDirection.TopToBottom : Pull starts from the top edge and moves towards the bottom
- PullDirection.BottomToTop : Pull starts from the bottom edge and moves towards the top
- PullDirection.LeftToRight : Pull starts from the left edge and moves towards the right
- PullDirection.RightToLeft : Pull starts from the right edge and moves towards the left
`PullDirection.TopToBottom` `PullDirection.BottomToTop` `PullDirection.LeftToRight` `PullDirection.RightToLeft` ### Binding Events​
After the PullGestureRecognizer has been added to your control, you need to bind them in your code behind either through an inline handler or to an event function:
```bash
image.AddHandler(Gestures.PullGestureEvent, (s, e) => { });image.AddHandler(Gestures.PullGestureEndedEvent, (s, e) => { });
```
```bash
image.AddHandler(Gestures.PullGestureEvent, Image_PullGesture);image.AddHandler(Gestures.PullGestureEndedEvent, Image_PullGestureEnded);...private void Image_PullGesture(object? sender, PullGestureEventArgs e) { }private void Image_PullGestureEnded(object? sender, PullGestureEndedEventArgs e) { }
```
If your event handles the gesture completely, you can mark the event as handled by setting:
```bash
e.Handled = true;
```
### Useful Properties​
You will probably use these properties most often:
### More Information​
View the source code on GitHub
PullGestureRecognizer.cs
`PullGestureRecognizer.cs` PullGestureEventArgs.cs
`PullGestureEventArgs.cs` - Using a PullGestureRecognizerPullDirection
- PullDirection
- Binding Events
- Useful Properties
- More Information
- PullDirection
# ScrollGestureRecognizer | Avalonia Docs
- Reference
- Gestures
- ScrollGestureRecognizer
## ScrollGestureRecognizer
A gesture recognizer that tracks a scrolling gesture. This can be attached to a control to detect when a pointer moves in a specific direction inside the control's bounds. This is especially useful when a control pans its contents, either horizontally, vertically or both.
### Using a ScrollGestureRecognizer​
A ScrollGestureRecognizer can be attached to a control using the control's GestureRecognizers property.
`GestureRecognizers` ```bash
<Image Stretch="UniformToFill"    Margin="5"    Name="image"    Source="/image.jpg"> <Image.GestureRecognizers>  <ScrollGestureRecognizer CanHorizontallyScroll="True"               CanVerticallyScroll="True"/> </Image.GestureRecognizers></Image>
```
```bash
image.GestureRecognizers.Add(new ScrollGestureRecognizer(){  CanVerticallyScroll = true,  CanHorizontallyScroll = true,});
```
The ScrollGestureRecognizer raises a Gestures.ScrollGestureEvent when it detects the start of a scroll gesture. When the scroll ends, from the pointer being released or another gesture start, it raises a Gestures.ScrollGestureEndedEvent.
`Gestures.ScrollGestureEvent` `Gestures.ScrollGestureEndedEvent` ### Binding Events​
After the ScrollGestureRecognizer has been added to your control, you need to bind them in your code behind either through an inline handler or to an event function:
```bash
image.AddHandler(Gestures.ScrollGestureEvent, (s, e) => { });image.AddHandler(Gestures.ScrollGestureEndedEvent, (s, e) => { });
```
```bash
image.AddHandler(Gestures.ScrollGestureEvent, Image_ScrollGesture);image.AddHandler(Gestures.ScrollGestureEndedEvent, Image_ScrollGestureEnded);...private void Image_ScrollGesture(object? sender, ScrollGestureEventArgs e) { }private void Image_ScrollGestureEnded(object? sender, ScrollGestureEndedEventArgs e) { }
```
If your event handles the gesture completely, you can mark the event as handled by setting:
```bash
e.Handled = true;
```
### Useful Properties​
You will probably use these properties most often:
### More Information​
For the complete API documentation about this gesture recognizer, see here.
View the source code on GitHub ScrollGestureRecognizer.cs
`ScrollGestureRecognizer.cs` - Using a ScrollGestureRecognizer
- Binding Events
- Useful Properties
- More Information
# Add Some Layout | Avalonia Docs
- Get Started
- Test Drive
- Add Some Layout
## Add Some Layout
Avalonia provides a range of built-in controls to help you layout the visual elements of an application. On this page, you will see how to use some of these layout controls.
At this stage, your application has a single button located in the content zone of the main window.
In fact, an Avalonia Window allows only one control in its content zone. To show multiple visual elements, you must use a layout control that allows multiple controls within its content zone.
`Window` ### StackPanel​
The StackPanel control lays out a sequence of controls in the order they are defined in XAML. By default, it lays out in a vertical stack but this can be changed to horizontal with its Orientation property.
`StackPanel` `Orientation` ```bash
<StackPanel>  <TextBlock>1</TextBlock>  <TextBlock>2</TextBlock></StackPanel>
```
### TextBlock​
The TextBlock control allows extensive styling of its contained text.
`TextBlock` To take the example forward, add a StackPanel as follows (include the preexisting Button XAML):
`StackPanel` `Button` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:vm="using:GetStartedApp.ViewModels"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="450"    x:Class="GetStartedApp.Views.MainWindow"    x:DataType="vm:MainWindowViewModel"    Icon="/Assets/avalonia-logo.ico"    Title="GetStartedApp">  <Design.DataContext>    <!-- This only sets the DataContext for the previewer in an IDE,       to set the actual DataContext for runtime, set the DataContext property in code (look at App.axaml.cs) -->    <vm:MainWindowViewModel/>  </Design.DataContext>  <StackPanel>    <Border Margin="5" CornerRadius="10" Background="LightBlue">      <TextBlock Margin="5"            FontSize="24"            HorizontalAlignment="Center"            Text="Temperature Converter">      </TextBlock>    </Border>    <Button HorizontalAlignment="Center">Calculate</Button>  </StackPanel></Window>
```
![Temperature StackPanel](https://docs.avaloniaui.net/img/get-started/test-drive/temperature-stackpanel-light.png)
![Temperature StackPanel](https://docs.avaloniaui.net/img/get-started/test-drive/temperature-stackpanel-dark.png)
You can explore the other layout controls in Avalonia using the reference here.
On the next page, you will add some inputs to the middle of the window.
- StackPanel
- TextBlock
# Input Controls | Avalonia Docs
- Get Started
- Test Drive
- Input Controls
## Input Controls
On this page, you will learn how to add input controls and arrange them in a neatly aligned layout. The aim is to add numerical inputs with labels and an output control following in the row below.
To achieve this layout, you will use the built-in Grid control to create cells and assign our controls to those cells.
`Grid` The following picture shows the finished application at runtime with the gridlines showing for layout visualization purposes. Normally, these are invisible on a production UI.
![Temperature StackPanel](https://docs.avaloniaui.net/img/get-started/test-drive/input-controls-light.png)
![Temperature StackPanel](https://docs.avaloniaui.net/img/get-started/test-drive/input-controls-dark.png)
To create a layout using the Grid control with 2 columns and 3 rows, follow this procedure:
`Grid` - Stop the app if it is running.
- Locate the empty line in the XAML between <Border> and <Button>
- Insert a <Grid> tag as shown:
`<Border>` `<Button>` `<Grid>` ```bash
<StackPanel>  <Border Margin="5" CornerRadius="10" Background="LightBlue">    <TextBlock Margin="5"      HorizontalAlignment="Center"      FontSize="24"      Text="Temperature Converter" />  </Border>  <Grid ShowGridLines="True" Margin="5"      ColumnDefinitions="120, 100"     RowDefinitions="Auto, Auto, Auto">  </Grid>  <Button HorizontalAlignment="Center">Calculate</Button></StackPanel>
```
This assigns the number of rows and columns, their sizes, and makes the gridlines visible. Currently, it will show as a straight line because the grid cells are empty. The Auto rows size to their content and will have zero height until content is added.
`Auto` - Add <Label> and <TextBox> (text input) controls to the Grid's children as shown:
`<Label>` `<TextBox>` `Grid` ```bash
<Grid ShowGridLines="True" Margin="5"   ColumnDefinitions="120, 100"    RowDefinitions="Auto, Auto, Auto">  <Label Grid.Row="0" Grid.Column="0">Celsius</Label>  <TextBox Grid.Row="0" Grid.Column="1"/>  <Label Grid.Row="1" Grid.Column="0">Fahrenheit</Label>  <TextBox Grid.Row="1" Grid.Column="1"/></Grid>
```
To complete the layout, tidy up the alignment of the controls in the Grid using their Margin property. Also, move the Button inside the Grid.
`Grid` `Margin` `Button` `Grid` ```bash
<Grid ShowGridLines="True" Margin="5"    ColumnDefinitions="120, 100"    RowDefinitions="Auto, Auto, Auto">  <Label Grid.Row="0" Grid.Column="0" Margin="10">Celsius</Label>  <TextBox Grid.Row="0" Grid.Column="1" Margin="0 5" Text="0"/>  <Label Grid.Row="1" Grid.Column="0" Margin="10">Fahrenheit</Label>  <TextBox Grid.Row="1" Grid.Column="1" Margin="0 5" Text="0"/>  <Button Grid.Row="2" Grid.Column="1">Calculate</Button></Grid>
```
- Run the app to see the result
For full information about the complete range of Avalonia built-in controls, and their attributes, see the reference section here.
On the next page, you will see how to improve your design-time experience by adjusting the size window when it is shown in the preview pane.
# The Design Preview | Avalonia Docs
- Get Started
- Test Drive
- The Design Preview
## The Design Preview
On this page, you will explore the attributes of the Window and then use some of them to adjust the size of the Window when it is shown in the preview pane.
`Window` `Window` Examine the XAML for the <Window> tag. It will look like this:
`<Window>` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:vm="using:GetStartedApp.ViewModels"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="450"    x:Class="GetStartedApp.Views.MainWindow"    x:DataType="vm:MainWindowViewModel"    Icon="/Assets/avalonia-logo.ico"    Title="GetStartedApp">
```
The Window tag starts by defining some of the XML namespaces that Avalonia uses. The aliases 'x', 'd' and 'mc' are used.
`Window` The design namespace 'd' allows the design-time attributes d:DesignWidth and d:DesignHeightto be set. In the above code sample, these have been set to make the preview look more like a mobile (portrait orientation) display.
`d:DesignWidth` `d:DesignHeight` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:vm="using:GetStartedApp.ViewModels"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="450"    x:Class="GetStartedApp.Views.MainWindow"    x:DataType="vm:MainWindowViewModel"    Icon="/Assets/avalonia-logo.ico"    Title="GetStartedApp">
```
With these attributes set, the preview of the window now looks like this:
![Application running](https://docs.avaloniaui.net/img/get-started/test-drive/temperature-design-preview-light.png)
![Application running](https://docs.avaloniaui.net/img/get-started/test-drive/temperature-design-preview-dark.png)
On the next page, you will learn how to add some action to the app by responding to the Button Click event.
`Button` `Click`
# Respond to an Event | Avalonia Docs
- Get Started
- Test Drive
- Respond to an Event
## Respond to an Event
There are a number of ways you can implement actions in an Avalonia application. On this page, you will see how to use one of the simplest: how to write event handling code for a button click.
To start, you will write a button click event handler that does not interact with any of the other controls.
### Code-Behind ​
XAML files can have C# source files associated with it referred to as by "code-behind". Code-behind is used to access named controls and handle events for its associated XAML. When using an IDE, you can find this file in the Solution Explorer as a sub-item of the .axaml file.
`.axaml` ![Solution Explorer](https://docs.avaloniaui.net/img/get-started/test-drive/codebehind-mainwindow-light.png)
![Solution Explorer](https://docs.avaloniaui.net/img/get-started/test-drive/codebehind-mainwindow-dark.png)
To change the code-behind for MainWindow:
`MainWindow` - Open the MainWindow.axaml.cs file
`MainWindow.axaml.cs` You should see C# code like this:
```bash
using Avalonia.Controls;namespace GetStartedApp.Views;public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();  }}
```
The partial class MainWindow corresponds to the Window created by Avalonia as a result of the XAML you already have. The namespace and class name must be the same in both XAML and code-behind. You can find this class name in the root XAML tag:
`MainWindow` `Window` ```bash
<UserControl x:Class="GetStartedApp.Views.MainWindow"  ...></UserControl>
```
To add an event handler for the Button, follow this procedure:
`Button` - Locate the MainWindow constructor in the code-behind file (see above instructions).
- After the constructor, add the following code:
`MainWindow` ```bash
private void Button_OnClick(object? sender, RoutedEventArgs e){  Debug.WriteLine("Click!");}
```
This will require the following using statements:
```bash
using Avalonia.Interactivity;using System.Diagnostics;
```
- Switch to the XAML file and locate the <Button> tag.
- Enter the Click attribute at the end of the tag, as follows:
`<Button>` `Click` ```bash
<Button Grid.Row="2" Grid.Column="1" Click="Button_OnClick">Calculate</Button>
```
- Run the app in Debug mode and click the Calculate button.
- Rider
- Visual Studio
You should see the result on the Output window for Debug, like this:
![Application running](https://docs.avaloniaui.net/img/get-started/test-drive/rider-event-debug-output-light.png)
![Application running](https://docs.avaloniaui.net/img/get-started/test-drive/rider-event-debug-output-dark.png)
You should see the result on the Output window for Debug, like this:
On the next page, you will see how to use code-behind to read and change the properties of Avalonia controls at runtime.
- Code-Behind
# Code With Controls | Avalonia Docs
- Get Started
- Test Drive
- Code With Controls
## Code With Controls
In this section, you will implement the core logic to update the Fahrenheit temperature based on the Celsius input.
### Control Names​
Avalonia creates objects for each control defined in the XAML hierarchy. Your code can access these controls at runtime, but should be named for easy access.
To add control names, follow this procedure:
- Stop the app if it is running.
- Locate the TextBox for Celsius.
- Add the Name attribute like this:
`TextBox` `Name` ```bash
<TextBox ... Name="Celsius"/>
```
- Repeat the above for the Fahrenheit input:
```bash
<TextBox ... Name="Fahrenheit"/>
```
### Get Control Values in Code-Behind​
To access the Text value of the celsius input, follow this procedure:
`Text` `celsius` - Switch to the MainWindow.axaml.cs code-behind file.
- Locate the Button_OnClick event handler.
- Alter the Debug statement to display the text property of the Celsius input, like this:
`Button_OnClick` `Debug` `Celsius` ```bash
Debug.WriteLine($"Click! Celsius={Celsius.Text}");
```
- Run the app again (in debug mode) to confirm that you can see the value in the Celsius appear in the debug window.
### Set Control Values in Code-Behind​
To use the simple formula that converts Celsius temperature to Fahrenheit, you will first need to ensure that the Celsius input text converts to a number. The formula is then:
```bash
Tf = Tc * (9/5) + 32
```
To add the conversion formula, follow this procedure:
- Locate the Button_OnClick event handler.
- Validate the Celsius input text as a number.
- Use the conversion formula.
- Update the Text in the Fahrenheit input.
- Run the app to check your work.
`Button_OnClick` `Text` One implementation of the above is as follows:
```bash
private void Button_OnClick(object? sender, RoutedEventArgs e){  if (double.TryParse(Celsius.Text, out double C))  {    var F = C * (9d / 5d) + 32;    Fahrenheit.Text = F.ToString("0.0");  }  else  {    Celsius.Text = "0";    Fahrenheit.Text = "0";  }}
```
You can check your work using the following conversion table:
#### Exercises​
You have now used an event handler to get and set control properties at runtime. Try some of these exercises:
- Stop showing the gridlines (easy).
- Stop the user from changing the text in the Fahrenheit input by setting the IsReadOnly attribute (easy).
- Calculate the conversion as the user types into the Celsius input using the TextChanged event (moderate).
`IsReadOnly` `TextChanged` For full information about the complete range of Avalonia built-in controls, events and attributes, see the controls reference section here.
- Control Names
- Get Control Values in Code-Behind
- Set Control Values in Code-BehindExercises
- Exercises
# RepeatButton | Avalonia Docs
- Reference
- Controls Reference
- Button Controls
- RepeatButton
## Repeat Button
The RepeatButton is a control that has the added feature of regularly generating click events while the button is being pressed down.
`RepeatButton` ### Useful Properties​
You will probably use these properties most often:
### Example​
This example shows a repeat button generating click events with the default interval and delay.
```bash
<Grid Margin="20" RowDefinitions="50,*"> <RepeatButton Grid.Row="0" Click="ClickHandler">Press and hold down</RepeatButton> <ScrollViewer Grid.Row="1">  <TextBlock Margin="0 10" x:Name="message">Ready...</TextBlock> </ScrollViewer></Grid>
```
```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();  }  public void ClickHandler(object sender, RoutedEventArgs args)  {    message.Text += "\rButton clicked!";  }}
```
![](https://docs.avaloniaui.net/assets/images/repeatbutton-hold-a62dc7dab41aeaf1affad538561fa7f8.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub RepeatButton.cs
`RepeatButton.cs` - Useful Properties
- Example
- More Information
# RadioButton | Avalonia Docs
- Reference
- Controls Reference
- Button Controls
- RadioButton
## Radio Button
The RadioButton control presents a group of options from which only one may be selected at a time. A selected option is drawn as a filled circle, and an unselected option as an empty circle.
`RadioButton` The content of the radio button control is presented as a label next to the circle.
It is possible for no options in a group to be selected, however as soon as one is selected, the radio button interaction cannot be stopped by the user.
### Useful Properties​
You will probably use these properties most often:
`GroupName` `IsChecked` `IsEnabled` ### Example​
This example shows two groups of radio buttons working independently:
```bash
<StackPanel Margin="20"> <TextBlock Margin="0 10 0 5">First Group</TextBlock>  <RadioButton GroupName="First Group"       Content="First Option"/>  <RadioButton GroupName="First Group"       Content="Second Option"/>  <RadioButton IsEnabled="False"       GroupName="First Group"       Content="Third Option"/> <TextBlock Margin="0 10 0 5">Second Group</TextBlock>   <RadioButton GroupName="Second Group"       Content="Fourth Option"/>  <RadioButton GroupName="Second Group"       Content="Fifth Option"/></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/radiobutton-8cb092025871631384f41e4b7388b03f.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub RadioButton.cs
`RadioButton.cs` - Useful Properties
- Example
- More Information
# ButtonSpinner | Avalonia Docs
- Reference
- Controls Reference
- Button Controls
- ButtonSpinner
## Button Spinner
The ButtonSpinner presents a control that includes buttons for spin-up and spin-down. The content of this button is flexible, but you will have to code quite a lot of the behavior.
`ButtonSpinner` ### Useful Properties​
You will probably use these properties most often:
`ButtonSpinnerLocation` `ValidSpinDirection` ### Example​
```bash
<ButtonSpinner Height="20" Width="130" ButtonSpinnerLocation="Left"> 123</ButtonSpinner>
```
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub ButtonSpinner.cs
`ButtonSpinner.cs` - Useful Properties
- Example
- More Information
# DataGrid | Avalonia Docs
- Reference
- Controls Reference
- DataGrid
## DataGrid
The DataGrid displays repeating data in a customizable grid. The control can be styled, templated and bound.
`DataGrid` The DataGrid needs to be bound to an observable collection in a view model that can be found in a related data context.
`DataGrid` To review the concept behind the data context, see here.
The DataGrid is in an additional Avalonia UI package. To use the DataGrid in your project, you must reference the Avalonia.Controls.DataGrid NuGet package, and reference the styles that it uses, see below.
`DataGrid` `DataGrid` ### NuGet Package Reference​
You must install the NuGet package for the DataGrid, there are several ways of doing this. You can use Manage NuGet Packages from the project menu of your IDE:
`DataGrid` Alternatively, you can run this instruction from the command line:
```bash
dotnet add package Avalonia.Controls.DataGrid
```
Or add package reference directly to the project (.csproj) file:
`.csproj` ```bash
<PackageReference Include="Avalonia.Controls.DataGrid" Version="11.0.0" />
```
Note you must always install the data grid version that matches the Avalonia UI version you are using.
### Include DataGrid Styles​
You must reference the DataGrid themes to include the additional styles that the DataGrid uses. You can do this by adding a <StyleInclude> element to the application (App.axaml file).
`DataGrid` `DataGrid` `<StyleInclude>` `App.axaml` For example:
```bash
<Application.Styles>  <FluentTheme />  <StyleInclude Source="avares://Avalonia.Controls.DataGrid/Themes/Fluent.xaml"/></Application.Styles>
```
### Useful Properties​
You will probably use these properties most often:
`AutoGenerateColumns` `ItemsSource` `IsReadOnly` `CanUserReorderColumns` `CanUserResizeColumns` `CanUserSortColumns` ### Examples​
This example will generate a basic DataGrid, with column header names auto-generated from the item class. The items data source is bound to the main window view model.
`DataGrid` ```bash
<DataGrid Margin="20" ItemsSource="{Binding People}"      AutoGenerateColumns="True" IsReadOnly="True"      GridLinesVisibility="All"     BorderThickness="1" BorderBrush="Gray"></DataGrid>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Person> People { get; }    public MainWindowViewModel()    {      var people = new List<Person>       {        new Person("Neil", "Armstrong"),        new Person("Buzz", "Lightyear"),        new Person("James", "Kirk")      };      People = new ObservableCollection<Person>(people);    }  }}
```
```bash
public class Person{  public string FirstName { get; set; }  public string LastName { get; set; }    public Person(string firstName , string lastName)  {    FirstName = firstName;    LastName = lastName;  }}
```
![](https://docs.avaloniaui.net/assets/images/datagrid-sort-column-25fd40a133c877c053be95f32904e730.gif)
These examples use the MVVM pattern with data binding to an ObservableCollection. For more information on the concepts behind data binding, see here.
`ObservableCollection` Property names from the item class will generally not make good column names. This example adds custom header names to the grid. It also allows column reordering and resizing and disallows the default column sorting option:
```bash
<DataGrid Margin="20" ItemsSource="{Binding People}"     IsReadOnly="True"     CanUserReorderColumns="True"     CanUserResizeColumns="True"     CanUserSortColumns="False"     GridLinesVisibility="All"     BorderThickness="1" BorderBrush="Gray"> <DataGrid.Columns>   <DataGridTextColumn Header="First Name" Binding="{Binding FirstName}"/>   <DataGridTextColumn Header="Last Name" Binding="{Binding LastName}" /> </DataGrid.Columns></DataGrid>
```
![](https://docs.avaloniaui.net/assets/images/datagrid-reorder-column-044a6bb53f563e5469d582d5d02bc90e.gif)
This example shows how the DataGrid can accept changes and update the underlying collection, and use different column types to edit the data:
`DataGrid` ```bash
<DataGrid Margin="20" ItemsSource="{Binding People}"         GridLinesVisibility="All"     BorderThickness="1" BorderBrush="Gray"> <DataGrid.Columns>   <DataGridTextColumn Header="First Name" Binding="{Binding FirstName}"/>   <DataGridTextColumn Header="Last Name" Binding="{Binding LastName}" />   <DataGridCheckBoxColumn Header="Fictitious?" Binding="{Binding IsFictitious}" /> </DataGrid.Columns></DataGrid>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Person> People { get; }    public MainWindowViewModel()    {      var people = new List<Person>       {        new Person("Neil", "Armstrong", false),        new Person("Buzz", "Lightyear", true),        new Person("James", "Kirk", true)      };      People = new ObservableCollection<Person>(people);    }  }}
```
```bash
public class Person{  public string FirstName { get; set; }  public string LastName { get; set; }  public bool IsFictitious { get; set; }  public Person(string firstName , string lastName, bool isFictitious)  {    FirstName = firstName;    LastName = lastName;    IsFictitious = isFictitious;  }}
```
![](https://docs.avaloniaui.net/assets/images/datagrid-column-types-90f3be4eb17d5258413060ad73c8db2e.gif)
### More Information​
For more information about the different kinds of DataGridColumn, see the next page.
`DataGridColumn` For the complete API documentation about this control, see here.
View the source code on GitHub DataGrid.cs
`DataGrid.cs` - NuGet Package Reference
- Include DataGrid Styles
- Useful Properties
- Examples
- More Information
# DataGridTemplateColumn | Avalonia Docs
- Reference
- Controls Reference
- DataGrid
- DataGridTemplateColumn
## DataGridTemplateColumn
You can use this column type to customise the display and editing for a data grid column.
There are two data templates which you define as attached properties:
`CellTemplate` `CellEditingTemplate` If you do not set a editing template, the column will stay read-only.
### Example​
This example adds a numeric up-down control when the age property for a person is being edited:
```bash
<Window ... xmlns:model="using:AvaloniaControls.Models" >  <DataGrid Margin="20" ItemsSource="{Binding People}"     GridLinesVisibility="All"     BorderThickness="1" BorderBrush="Gray">  <DataGrid.Columns>   <DataGridTextColumn Header="First Name" Width="2*"     Binding="{Binding FirstName}" />   <DataGridTextColumn Header="Last Name" Width="2*"     Binding="{Binding LastName}" />      <DataGridTemplateColumn Header="Age">    <DataGridTemplateColumn.CellTemplate>     <DataTemplate DataType="model:Person">      <TextBlock Text="{Binding AgeInYears, StringFormat='{}{0} years'}"        VerticalAlignment="Center" HorizontalAlignment="Center" />     </DataTemplate>    </DataGridTemplateColumn.CellTemplate>    <DataGridTemplateColumn.CellEditingTemplate>     <DataTemplate DataType="model:Person">      <NumericUpDown Value="{Binding AgeInYears}"         FormatString="N0" Minimum="0" Maximum="120"         HorizontalAlignment="Stretch"/>     </DataTemplate>    </DataGridTemplateColumn.CellEditingTemplate>   </DataGridTemplateColumn>    </DataGrid.Columns> </DataGrid></Window>
```
```bash
using AvaloniaControls.Models;using System.Collections.Generic;using System.Collections.ObjectModel;namespace AvaloniaControls.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ObservableCollection<Person> People { get; }    public MainWindowViewModel()    {      var people = new List<Person>       {        new Person("Neil", "Armstrong", 55),        new Person("Buzz", "Lightyear", 38),        new Person("James", "Kirk", 44)      };      People = new ObservableCollection<Person>(people);    }  }}
```
```bash
public class Person{  public string FirstName { get; set; }  public string LastName { get; set; }  public int AgeInYears { get; set; }   public Person(string firstName , string lastName, int ageInYears)  {    FirstName = firstName;    LastName = lastName;    AgeInYears = ageInYears;  }}
```
![](https://docs.avaloniaui.net/img/gitbook-import/assets/grid4.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub DataGridTemplateColumn.cs
`DataGridTemplateColumn.cs` - Example
- More Information
# Calendar | Avalonia Docs
- Reference
- Controls Reference
- Calendar
## Calendar
The calendar is a control for users to select dates or date ranges.
![](https://docs.avaloniaui.net/assets/images/calendar3-1828bca0fb75b637b86e3eaed5a848e1.gif)
### Useful Properties​
You will probably use these properties most often:
`SelectionMode` `DisplayMode` `SelectedDate` `SelectedDates` `DisplayDate` `DisplayDateStart` `DisplayDateEnd` `BlackoutDates` ### Examples​
This is a basic calendar allowing a single date selection. The calendar's selected date is shown in the text block below.
```bash
<StackPanel Margin="20"> <Calendar x:Name="calendar" SelectionMode="MultipleRange"/> <TextBlock Margin="20"       Text="{Binding #calendar.SelectedDate}"/></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/calendar-20ffb643df9016967ee213134195de1c.gif)
This example allows multiple range selections:
```bash
<StackPanel Margin="20"> <Calendar SelectionMode="MultipleRange"/></StackPanel>
```
After clicking a start date you can extend a single range by holding the shift key and clicking on the end date. You can add extra dates and ranges by holding the control key and clicking on other dates.
![](https://docs.avaloniaui.net/assets/images/calendar2-b9649f1acf179f76de21e3f0b2cb355f.gif)
This example has custom start and end dates, and some dates unavailable. This uses C# code behind the window.
```bash
<StackPanel Margin="20"> <Calendar x:Name="calendar" SelectionMode="SingleDate"/></StackPanel>
```
```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();    var today = DateTime.Today;    calendar.DisplayDateStart = today.AddDays(-25);    calendar.DisplayDateEnd = today.AddDays(25);    calendar.BlackoutDates.Add(      new CalendarDateRange( today.AddDays(5), today.AddDays(10)));  } }
```
![](https://docs.avaloniaui.net/assets/images/calendar4-3693498028628d485f2a30d7b3bbb4c3.gif)
### More Information​
For the complete API documentation about this control, see here.
View the source code on GitHub Calendar.cs
`Calendar.cs` - Useful Properties
- Examples
- More Information
# ColorPicker | Avalonia Docs
- Reference
- Controls Reference
- ColorPicker
## ColorPicker
The ColorPicker provides a highly customizable, general-purpose control that users can use to select colors in RGB or HSV color space. This implementation is just as much about providing primitive controls that developers can use to build their own color pickers as it is about providing a ready-to-use picker.
`ColorPicker` The ColorPicker includes a family of controls (components):
`ColorPicker` - ColorSpectrum (primitive) : A two dimensional spectrum for color selection.
- ColorSlider (primitive) : A slider with a background that represents a single color component.
- ColorPreviewer (primitive) : Shows a preview color with optional accent colors.
- ColorView : Presents a color for user editing using a spectrum, palette and component sliders.
- ColorPicker : Presents a color for user editing using a spectrum, palette and component sliders within a drop down. Editing is available when the drop down flyout is opened; otherwise, only the preview color is shown.
`ColorSpectrum` `ColorSlider` `ColorPreviewer` `ColorView` `ColorPicker` Each primitive component can be used on its own and mixed/matched with others. This allows significant composability that isn't possible with other color picker implementations. For example, you can quickly bind together the ColorSpectrum, ColorSlider and ColorPreviewer primitives to create your own color picker with a brand-new design.
`ColorSpectrum` `ColorSlider` `ColorPreviewer` Note on terminology: "color picker" usually refers to the family of controls while ColorPicker refers to the specific control.
`ColorPicker` ### Is this the right control?​
This control is intended to be used directly to select colors in a user-friendly, developer customizable way. This can be done using either a canvas-type ColorView control or a compact ColorPicker drop down.
`ColorView` `ColorPicker` For apps with even more special-purpose needs, each control and primitive component can be independently customized to create a new color picker without having to re-implement all the advanced rendering and color logic. This is very useful to match a specific app's design and usability requirements.
Developers using this control may:
- Use ColorView or ColorPicker as-is directly in their apps
- Customize ColorView or ColorPicker using the included properties. These properties allow significant changes to the control such as disabling components sliders, showing different palettes or hiding all but the spectrum tab.
- Create a new color picker to meet a specific app's design and usability requirements using the existing primitive components.
- Re-template the existing components to create a brand-new fully customized color picker.
`ColorView` `ColorPicker` `ColorView` `ColorPicker` ### Using in Your App​
Avalonia is used in several resource-constrained environments such as embedded devices. For this and other reasons, certain larger controls such as the ColorPicker are not included with the main Avalonia UI NuGet packages. This means a bit of extra work is required to add the ColorPicker to your app:
`ColorPicker` `ColorPicker` - Add the Avalonia.Controls.ColorPicker nuget to your project. This MUST match your version of Avalonia's other packages.
- Add control themes and styles for all color picker controls in App.axaml by adding: <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Fluent/Fluent.xaml" /> for Fluent themes OR <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Simple/Simple.xaml" /> for Simple themes
- <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Fluent/Fluent.xaml" /> for Fluent themes OR
- <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Simple/Simple.xaml" /> for Simple themes
`Avalonia.Controls.ColorPicker` `App.axaml` - <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Fluent/Fluent.xaml" /> for Fluent themes OR
- <StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Simple/Simple.xaml" /> for Simple themes
`<StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Fluent/Fluent.xaml" />` `<StyleInclude Source="avares://Avalonia.Controls.ColorPicker/Themes/Simple/Simple.xaml" />` This step is not required for some theme packages such as FluentAvalonia which include all controls by default.
### Background​
This control originated as a re-styling of the one in UWP (later WinUI) using the basic designs implemented for the Windows Community Toolkit. The WinUI ColorPicker isn't conducive to smaller screen sizes and the overall design/usability of the control left something to be desired for both users and developers.
`ColorPicker` With all its features, the WinUI control still wasn't as good as it should be. It couldn't be re-templated and customized without a lot of effort (partially because individual components were highly inter-dependent on each other). It also used a lot of template parts and code-behind. The Avalonia UI version of the control (a complete rewrite) attempts to fix all of these issues and become the predominant XAML color picker design.
Main improvements learning from WinUI were:
- The ColorPicker is implemented as a drop-down (matching all other "pickers"). There is also a ColorView control for those that want the canvas-type control (similar to WinUI).
- The Avalonia controls attempt to do everything possible in XAML control themes keeping code-behind to an absolute minimum. This significantly increases composability and enables app developers to customize every part of these controls (and even the primitives in most cases).
- Primitives such as the ColorSlider and ColorSpectrum are fully self-contained and can be used separately enabling app developers to create custom color picker implementations.
- A new HsvColor struct was added to base Avalonia itself (alongside Color and HslColor) and is now used in all color picker controls. This simplified code-behind and also made binding of color properties between primitives and controls possible. Color picker controls internally work in HSV color space.
- HsvColor along with ColorSlider together unlock a lot of power compared to WinUI (and enable easy re-templating).
- Many new properties (more than in WinUI) were added to control all aspects of the ColorView visibility. Each tab can be separately hidden along with most individual subsections. This allows a lot of design customization without having to re-template or use complex style selectors.
- Color palettes were added using the IColorPalette interface (same as the Windows Community Toolkit). No color palettes are supported in the WinUI version of this control.
- New properties such as SelectedIndex and ColorModel allow customizing the color picker and putting it into a pre-defined state. For example, the WinUI ColorPicker always defaults to RGB and this cannot be changed in code or XAML. This implementation does not have such limitations.
`ColorPicker` `ColorView` `ColorSlider` `ColorSpectrum` `HsvColor` `Color` `HslColor` `HsvColor` `ColorSlider` `ColorView` `IColorPalette` `SelectedIndex` `ColorModel` ### Controls & Primitives​
`ColorPicker` `ColorView` `ColorView` `ColorSpectrum` `ColorSlider` `ColorPreviewer` ### Color Palettes​
Several pre-defined color palettes implementing the IColorPalette interface are provided. Instances of these palettes may be set to the Palette property of a ColorView or ColorPicker.
`IColorPalette` `Palette` `ColorView` `ColorPicker` - Is this the right control?
- Using in Your App
- Background
- Controls & Primitives
- Color Palettes
# Unhandled Exceptions | Avalonia Docs
- Deep Dives
- Unhandled Exceptions
## Unhandled Exceptions
Avalonia UI does not offer any mechanism to handle exceptions globally and mark this as handled. The reason is, that one cannot know if the exception has been handled correctly and therefore the application may be in an invalid state. Instead it's highly recommend to handle exceptions locally if these can be handled by your application. That said it is still a good idea to log any unhandled exception for further support and debugging.
### Logging​
We recommend to log exceptions to the console, a file or anywhere else. There are several logging libraries available out there, for example Serilog and NLog.
### The global try-catch​
You can catch any exception from the main thread, which is also the UI thread in Avalonia UI, in your Program.cs-file. To do so we just wrap the entire void Main in a try and catch block. In the catch block you can log the error, inform the user, send the log file or restart the application.
`Program.cs` `void Main` `try` `catch` `catch` ```bash
// File: Program.cspublic static void Main(string[] args){  try  {    // prepare and run your App here    BuildAvaloniaApp()      .StartWithClassicDesktopLifetime(args);  }  catch (Exception e)  {    // here we can work with the exception, for example add it to our log file    Log.Fatal(e, "Something very bad happened");  }  finally  {    // This block is optional.     // Use the finally-block if you need to clean things up or similar    Log.CloseAndFlush();  }}
```
### Exceptions from another thread​
If you are using Tasks to run some work asynchronously, you can setup TaskScheduler.UnobservedTaskException. For more information read the Microsoft .NET-Documentation.
`Task` `TaskScheduler.UnobservedTaskException` ### Exceptions from Reactive UI​
If you are using Avalonia together with ReactiveUI, you can subscribe to their RxApp.DefaultExceptionHandler. For more information please refer to ReactiveUI Default Exception Handler.
`RxApp.DefaultExceptionHandler` Note, RxApp.DefaultExceptionHandler should be set before any ReactiveCommand was created. Otherwise, custom handler won't be used. You can set it in your application entry point or before any Avalonia view or window was created.
`RxApp.DefaultExceptionHandler` - Logging
- The global try-catch
- Exceptions from another thread
- Exceptions from Reactive UI
# Avalonia UI and MVVM | Avalonia Docs
- Deep Dives
- The MVVM Pattern
- Avalonia UI and MVVM
## Avalonia UI and MVVM
On this page you will learn how the MVVM pattern is realised when used with Avalonia UI.
### Views and View Models​
When you use the MVVM pattern with Avalonia UI, you implement a view with an AXAML file, attached to a corresponding code-behind file, and a view model with a plain-old code class file.
In Avalonia UI, a view is implemented as a composition of UI elements in a window or a user control (both AXAML files with code-behind). The UI elements in a composition can be a mixture of Avalonia UI built-in controls, user controls and (more advanced) controls of your own design and implementation.
For a full list of the Avalonia UI built-in controls, see the reference section here.
To learn more about the concept of UI composition, see here.
To learn how to design and implement your own controls, see here.
### Data Binding​
Data binding is the key technology that allows an Avalonia UI MVVM application to separate views from view models. You can visualise the view to view model relationship as two layers connected by the data bindings:
![](https://docs.avaloniaui.net/assets/images/mvvm-22304837aa64469743c8084694f0238e.png)
Notice how some of the data bindings are represented by a two way arrow and others by a single-headed arrow. For example, the name and address inputs are two ways - you want both changes in the view model to be notified to the view, and for inputs to the view to be updated on the view model.
The buttons however have one-direction commands, issued by the view and acted out by the view model.
Notice how the view model class is not dependent on the view layer, or how it will be rendered on the target platform by Avalonia UI. Because the view model class is independent, it can be unit tested like any other code.
When you use the MVVM pattern in practice, you will use a corresponding view model for each view, and the view model class contains all the application logic for the view.
### The MVVM Model​
The model is the other part of the MVVM pattern. Models are much less precisely defined in the pattern as they represent 'the rest of the architecture'. This is often data storage or other services.
The important principle for you to maintain is separation. You should implement the relationship between view model and model using some form of the Dependency Injection (DI) pattern.
### ReactiveUI​
There are a number of frameworks designed to help write applications using the MVVM pattern.
In the following pages, you will learn about the ReactiveUI framework which is one of the most popular and is supported by one of the Avalonia UI packages.
- Views and View Models
- Data Binding
- The MVVM Model
- ReactiveUI
# Native AOT Deployment | Avalonia Docs
- Deployment
- Native AOT Deployment
## Native AOT Deployment
Native AOT (Ahead-of-Time) compilation allows you to publish your Avalonia applications as self-contained executables with native performance characteristics. This guide covers Avalonia-specific considerations and setup for Native AOT deployment.
### Benefits for Avalonia Applications​
Native AOT compilation provides several advantages specifically relevant to Avalonia applications:
- Faster application startup time, particularly beneficial for desktop applications
- Reduced memory footprint for resource-constrained environments
- Self-contained deployment without requiring .NET runtime installation
- Improved security through reduced attack surface (no JIT compilation)
- Smaller distribution size when combined with trimming
### Setting Up Native AOT for Avalonia​
#### 1. Project Configuration​
Add the following to your csproj file:
```bash
<PropertyGroup>  <PublishAot>true</PublishAot>  <!-- Recommended Avalonia trimming settings for Native AOT -->  <BuiltInComInteropSupport>false</BuiltInComInteropSupport>  <TrimMode>link</TrimMode></PropertyGroup>
```
#### 2. Trimming Configuration​
Native AOT requires trimming. Add these trim settings specific to Avalonia:
```bash
<ItemGroup>  <!-- Preserve Avalonia types for reflection -->  <TrimmerRootAssembly Include="Avalonia.Themes.Fluent" />  <TrimmerRootAssembly Include="Avalonia.Themes.Default" /></ItemGroup>
```
### Avalonia-Specific Considerations​
#### XAML Loading​
When using Native AOT, XAML is compiled into the application at build time. Ensure you:
- Use x:CompileBindings="True" in your XAML files
- Avoid dynamic XAML loading at runtime
- Use static resource references instead of dynamic resources where possible
`x:CompileBindings="True"` #### Assets and Resources​
- Bundle all assets as embedded resources
- Use AvaloniaResource build action for your assets
- Avoid dynamic asset loading from external sources
`AvaloniaResource` #### ViewModels and Dependency Injection​
- Register your ViewModels at startup
- Use compile-time DI configuration
- Avoid reflection-based service location
### Publishing Avalonia Native AOT Applications​
#### Windows​
```bash
dotnet publish -r win-x64 -c Release
```
#### Linux​
```bash
dotnet publish -r linux-x64 -c Release
```
#### macOS​
Intel based macOS
```bash
dotnet publish -r osx-x64 -c Release
```
Apple silicon based macOS
```bash
dotnet publish -r osx-arm64 -c Release
```
You can then use Apple's lipo tool to combine both Intel and Apple Silicon binaries, enabling you to ship Universal binaries.
### Troubleshooting Common Issues​
#### 1. Missing XAML Controls​
If controls are missing at runtime:
```bash
<ItemGroup>  <!-- Add specific Avalonia controls you're using -->  <TrimmerRootAssembly Include="Avalonia.Controls" /></ItemGroup>
```
#### 2. Reflection-Related Errors​
For ViewModels or services using reflection:
```bash
<ItemGroup>  <TrimmerRootDescriptor Include="TrimmerRoots.xml" /></ItemGroup>
```
Create a TrimmerRoots.xml:
`TrimmerRoots.xml` ```bash
<linker>  <assembly fullname="YourApplication">    <type fullname="YourApplication.ViewModels*" preserve="all"/>  </assembly></linker>
```
### Known Limitations​
When using Native AOT with Avalonia, be aware of these limitations:
- Dynamic control creation must be configured in trimmer settings
- Some third-party Avalonia controls may not be AOT-compatible
- Platform-specific features need explicit configuration
- Live preview in design-time tools may be limited
### Platform Support​
### Best Practices​
- Application Structure Use MVVM pattern consistently Minimize reflection usage Prefer compile-time configuration
- Use MVVM pattern consistently
- Minimize reflection usage
- Prefer compile-time configuration
- Resource Management Use static resources when possible Bundle all required assets Implement proper cleanup in IDisposable
- Use static resources when possible
- Bundle all required assets
- Implement proper cleanup in IDisposable
- Performance Optimization Enable binding compilation Use compiled bindings Implement proper virtualization for large collections
- Enable binding compilation
- Use compiled bindings
- Implement proper virtualization for large collections
Application Structure
- Use MVVM pattern consistently
- Minimize reflection usage
- Prefer compile-time configuration
Resource Management
- Use static resources when possible
- Bundle all required assets
- Implement proper cleanup in IDisposable
Performance Optimization
- Enable binding compilation
- Use compiled bindings
- Implement proper virtualization for large collections
### Additional Resources​
- Avalonia Sample Applications with Native AOT
- Benefits for Avalonia Applications
- Setting Up Native AOT for Avalonia1. Project Configuration2. Trimming Configuration
- 1. Project Configuration
- 2. Trimming Configuration
- Avalonia-Specific ConsiderationsXAML LoadingAssets and ResourcesViewModels and Dependency Injection
- XAML Loading
- Assets and Resources
- ViewModels and Dependency Injection
- Publishing Avalonia Native AOT ApplicationsWindowsLinuxmacOS
- Windows
- Linux
- macOS
- Troubleshooting Common Issues1. Missing XAML Controls2. Reflection-Related Errors
- 1. Missing XAML Controls
- 2. Reflection-Related Errors
- Known Limitations
- Platform Support
- Best Practices
- Additional Resources
- 1. Project Configuration
- 2. Trimming Configuration
- XAML Loading
- Assets and Resources
- ViewModels and Dependency Injection
- Windows
- Linux
- macOS
- 1. Missing XAML Controls
- 2. Reflection-Related Errors
# Deployment | Avalonia Docs
- Deployment
## Deployment
# macOS Deployment | Avalonia Docs
- Deployment
- macOS Deployment
## macOS Deployment
macOS applications are typically distributed in a .app application bundle. To make .NET Core and Avalonia projects work in a .app bundle, some extra legwork has to be done after your application has gone through the publishing process.
`.app` `.app` With Avalonia, you'll have a .app folder structure that looks like this:
`.app` ```bash
MyProgram.app|----Contents\  |  ------_CodeSignature\ (stores code signing information)  |   |  |   ------CodeResources  |  ------MacOS\ (all your DLL files, etc. -- the output of `dotnet publish`)  |   |  |   ---MyProgram  |   |  |   ---MyProgram.dll  |   |  |   ---Avalonia.dll  |  ------Resources\  |   |  |   -----MyProgramIcon.icns (icon file)  |  ------Info.plist (stores information on your bundle identifier, version, etc.)  ------embedded.provisionprofile (file with signing information)
```
For more information on Info.plist, see Apple's documentation here.
`Info.plist` ### Making the application bundle​
There are a few options available for creating the .app file/folder structure. You can do this on any operating system, since a .app file is just a set of folders laid out in a specific format and the tooling isn't specific to one operating system. However, if you build on Windows outside of WSL, the executable may not have the right attributes for execution on macOS -- you may have to run chmod +x on the published binary output (the output generated by dotnet publish) from a Unix machine. This is the binary output that ends up in the folder MyApp.app/Contents/MacOS/, and the name should match CFBundleExecutable.
`.app` `.app` `chmod +x` `dotnet publish` `MyApp.app/Contents/MacOS/` `CFBundleExecutable` The .app structure relies on the Info.plist file being properly formatted and containing the right information. Use Xcode to edit Info.plist, it has auto-completion for all properties. Make sure that:
`.app` `Info.plist` `Info.plist` - The value of CFBundleExecutable matches the binary name generated by dotnet publish -- typically this is the same as your .dll assembly name without .dll.
- CFBundleName is set to the display name for your application. If this is longer than 15 characters, set CFBundleDisplayName too.
- CFBundleIconFile is set to the name of your icns icon file (including extension)
- CFBundleIdentifier is set to a unique identifier, typically in reverse-DNS format -- e.g. com.myapp.macos.
- NSHighResolutionCapable is set to true (<true/> in the Info.plist).
- CFBundleVersion is set to the version for your bundle, e.g. 1.4.2.
- CFBundleShortVersionString is set to the user-visible string for your application's version, e.g. Major.Minor.Patch.
`CFBundleExecutable` `dotnet publish` `.dll` `.dll` `CFBundleName` `CFBundleDisplayName` `CFBundleIconFile` `icns` `CFBundleIdentifier` `com.myapp.macos` `NSHighResolutionCapable` `<true/>` `Info.plist` `CFBundleVersion` `CFBundleShortVersionString` `Major.Minor.Patch` If you need a protocol registration or file associations - open plist files from other apps in Applications folder and check out their fields.
Example protocol:
```bash
<key>CFBundleURLTypes</key> <array>  <dict>   <key>CFBundleURLName</key>   <string>AppName</string>   <key>CFBundleTypeRole</key>   <string>Viewer</string>   <key>CFBundleURLSchemes</key>   <array>    <string>i8-AppName</string>   </array>  </dict> </array>
```
Example file association
```bash
<key>CFBundleDocumentTypes</key> <array>  <dict>   <key>CFBundleTypeName</key>   <string>Sketch</string>   <key>CFBundleTypeExtensions</key>   <array>    <string>sketch</string>   </array>   <key>CFBundleTypeIconFile</key>   <string>icon.icns</string>   <key>CFBundleTypeRole</key>   <string>Viewer</string>   <key>LSHandlerRank</key>   <string>Default</string>  </dict> </array>
```
More documentation on possible Info.plist keys is available here.
`Info.plist` If at any point the tooling gives you an error that your assets file doesn't have a target for osx-64, add the following runtime identifiers to the top <PropertyGroup> in your .csproj:
`osx-64` `<PropertyGroup>` `.csproj` ```bash
<RuntimeIdentifiers>osx-x64</RuntimeIdentifiers>
```
Add other runtime identifiers as necessary. Each one should be separated by a semicolon (;).
#### Notes on creating icon files​
This type of icon file can not only be created on Apple devices, but it is also possible on Linux devices. You can find more information about how you can achieve that in this blog post: Creating macOS Icons (icns) on Linux
#### Notes on the .app executable file​
`.app` The file that is actually executed by macOS when starting your .app bundle will not have the standard .dll extension. If your publish folder contents, which go inside the .app bundle, do not have both a MyApp (executable) and a MyApp.dll, things are probably not generating properly, and macOS will probably not be able to start your .app properly.
`.app` `.dll` `.app` `MyApp` `MyApp.dll` `.app` Some recent changes in the way .NET Core is distributed and notarized on macOS have caused the MyApp executable (also called the "app host" in the linked documentation) to not be generated. You need this file to be generated in order for your .app to function properly. To make sure this gets generated, do one of the following:
`MyApp` `.app` - Add the following to your .csproj file:
`.csproj` ```bash
<PropertyGroup> <UseAppHost>true</UseAppHost></PropertyGroup>
```
- Add -p:UseAppHost=true to your dotnet publish command.
`-p:UseAppHost=true` `dotnet publish` Additionally, you might want to add the '-p:PublishSingleFile=true' to your dotnet command, compiling most of the DLLs into a your single application, simplifying the signing and notarizing process.
#### dotnet-bundle​
dotnet-bundle is unmaintained but should still work.
It is recommended that you target net6-macos, which will handle package generation.
`net6-macos` dotnet-bundle is a NuGet package that publishes your project and then creates the .app file for you.
`.app` You'll first have to add the project as a PackageReference in your project. Add it to your project via NuGet package manager or by adding the following line to your .csproj file:
`PackageReference` `.csproj` ```bash
<PackageReference Include="Dotnet.Bundle" Version="*" />
```
After that, you can create your .app by executing the following on the command line:
`.app` ```bash
dotnet restore -r osx-x64dotnet msbuild -t:BundleApp -p:RuntimeIdentifier=osx-x64 -p:UseAppHost=true
```
You can specify other parameters for the dotnet msbuild command. For instance, if you want to publish in release mode:
`dotnet msbuild` ```bash
dotnet msbuild -t:BundleApp -p:RuntimeIdentifier=osx-x64 -property:Configuration=Release -p:UseAppHost=true
```
or if you want to specify a different app name:
```bash
dotnet msbuild -t:BundleApp -p:RuntimeIdentifier=osx-x64 -p:CFBundleDisplayName=MyBestThingEver -p:UseAppHost=true
```
Instead of specifying CFBundleDisplayName, etc., on the command line, you can also specify them in your project file:
`CFBundleDisplayName` ```bash
<PropertyGroup>  <CFBundleName>AppName</CFBundleName> <!-- Also defines .app file name -->  <CFBundleDisplayName>MyBestThingEver</CFBundleDisplayName>  <CFBundleIdentifier>com.example</CFBundleIdentifier>  <CFBundleVersion>1.0.0</CFBundleVersion>  <CFBundlePackageType>APPL</CFBundlePackageType>  <CFBundleSignature>????</CFBundleSignature>  <CFBundleExecutable>AppName</CFBundleExecutable>  <CFBundleIconFile>AppName.icns</CFBundleIconFile> <!-- Will be copied from output directory -->  <NSPrincipalClass>NSApplication</NSPrincipalClass>  <NSHighResolutionCapable>true</NSHighResolutionCapable></PropertyGroup>
```
By default, dotnet-bundle will put the .app file in the same place as the publish output: [project directory]/bin/{Configuration}/netcoreapp3.1/osx-x64/publish/MyBestThingEver.app.
`dotnet-bundle` `.app` `publish` `[project directory]/bin/{Configuration}/netcoreapp3.1/osx-x64/publish/MyBestThingEver.app` For more information on the parameters you can send, see the dotnet-bundle documentation.
If you created the .app on Windows, make sure to run chmod +x MyApp.app/Contents/MacOS/AppName from a Unix machine. Otherwise, the app will not start on macOS.
`.app` `chmod +x MyApp.app/Contents/MacOS/AppName` #### Manual​
First, publish your application (dotnet publish documentation):
```bash
dotnet publish -r osx-x64 --configuration Release -p:UseAppHost=true
```
Create your Info.plist file, adding or modifying keys as necessary:
`Info.plist` ```bash
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict>  <key>CFBundleIconFile</key>  <string>myicon-logo.icns</string>  <key>CFBundleIdentifier</key>  <string>com.identifier</string>  <key>CFBundleName</key>  <string>MyApp</string>  <key>CFBundleVersion</key>  <string>1.0.0</string>  <key>LSMinimumSystemVersion</key>  <string>10.12</string>  <key>CFBundleExecutable</key>  <string>MyApp.Avalonia</string>  <key>CFBundleInfoDictionaryVersion</key>  <string>6.0</string>  <key>CFBundlePackageType</key>  <string>APPL</string>  <key>CFBundleShortVersionString</key>  <string>1.0</string>  <key>NSHighResolutionCapable</key>  <true/></dict></plist>
```
You can then create your .app folder structure as outlined at the top of this page. If you want a script to do it for you, you can use something like this (macOS/Unix):
`.app` ```bash
#!/bin/bashAPP_NAME="/path/to/your/output/MyApp.app"PUBLISH_OUTPUT_DIRECTORY="/path/to/your/publish/output/netcoreapp3.1/osx-64/publish/."# PUBLISH_OUTPUT_DIRECTORY should point to the output directory of your dotnet publish command.# One example is /path/to/your/csproj/bin/Release/netcoreapp3.1/osx-x64/publish/.# If you want to change output directories, add `--output /my/directory/path` to your `dotnet publish` command.INFO_PLIST="/path/to/your/Info.plist"ICON_FILE="/path/to/your/myapp-logo.icns"if [ -d "$APP_NAME" ]then  rm -rf "$APP_NAME"fimkdir "$APP_NAME"mkdir "$APP_NAME/Contents"mkdir "$APP_NAME/Contents/MacOS"mkdir "$APP_NAME/Contents/Resources"cp "$INFO_PLIST" "$APP_NAME/Contents/Info.plist"cp "$ICON_FILE" "$APP_NAME/Contents/Resources/$ICON_FILE"cp -a "$PUBLISH_OUTPUT_DIRECTORY" "$APP_NAME/Contents/MacOS"
```
If you created the .app on Windows, make sure to run chmod +x MyApp.app/Contents/MacOS/AppName from a Unix machine. Otherwise, the app will not start on macOS.
`.app` `chmod +x MyApp.app/Contents/MacOS/AppName` ### Signing Your App​
Once you have your .app file created, you'll probably want to sign your app so that it can be notarized and distributed to your users without Gatekeeper giving you a hassle. Notarization is required for apps distributed outside the app store starting in macOS 10.15 (Catalina), and you'll have to enable hardened runtime and run codesign on your .app in order to notarize it successfully.
`.app` `codesign` `.app` You'll need a Mac computer for this step, unfortunately, as we have to run the codesign command line tool that comes with Xcode.
`codesign` #### Running codesign and enabling hardened runtime​
Enabling hardened runtime is done in the same step as code signing. You have to codesign everything in the .app bundle under the Contents/MacOS folder, which is easiest to do with a script since there are a lot of files. In order to sign your files, you need an Apple developer account. In order to notarize your app, you'll need to do the following steps with a Developer ID certificate, which requires a paid Apple developer subscription.
`.app` `Contents/MacOS` You'll also need to have the Xcode command line tools installed. You can get those by installing Xcode and running it or by running xcode-select --install on the command line and following the prompts to install the tools
`xcode-select --install` First, enable Hardened Runtime with exceptions by creating an MyAppEntitlements.entitlements file:
`MyAppEntitlements.entitlements` ```bash
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict>  <key>com.apple.security.cs.allow-jit</key>  <true/>  <key>com.apple.security.automation.apple-events</key>  <true/></dict></plist>
```
Then, run this script to do all the code signing for you:
```bash
#!/bin/bashAPP_NAME="/path/to/your/output/MyApp.app"ENTITLEMENTS="/path/to/your/MyAppEntitlements.entitlements"SIGNING_IDENTITY="Developer ID: MyCompanyName" # matches Keychain Access certificate namefind "$APP_NAME/Contents/MacOS/"|while read fname; do  if [[ -f $fname ]]; then    echo "[INFO] Signing $fname"    codesign --force --timestamp --options=runtime --entitlements "$ENTITLEMENTS" --sign "$SIGNING_IDENTITY" "$fname"  fidoneecho "[INFO] Signing app file"codesign --force --timestamp --options=runtime --entitlements "$ENTITLEMENTS" --sign "$SIGNING_IDENTITY" "$APP_NAME"
```
The --options=runtime part of the codesign line is what enables the hardened runtime with your app. Because .NET Core may not be fully compatible with hardened runtime, we add some exceptions to use JIT-compiled code and allow for Apple Events to be sent. The JIT-compiled code exception is required to run Avalonia apps under hardened runtime. We add the second exception for Apple Events to fix an error that shows up in Console.app.
`--options=runtime` `codesign` Note: Microsoft lists some other hardened runtime exceptions as being required for .NET Core. The only one that is actually needed to run an Avalonia app is com.apple.security.cs.allow-jit. The others may impose security risks with your application. Use with caution.
`com.apple.security.cs.allow-jit` Once your app is code signed, you can verify that it signed properly by making sure that the following command outputs no errors:
```bash
codesign --verify --verbose /path/to/MyApp.app
```
#### Notarizing your software​
Notarization allows your app to be distributed outside the macOS App Store. You can read more about it here. If you run into any issues during the process, Apple has a helpful document of potential fixes here.
For more information on customizing your notarization workflow and more flags you may need to send when running xcrun altool, check out Apple's documentation.
`xcrun altool` The following steps were modified from this StackOverflow post:
- Make sure your .app is code signed properly
- Stick your .app in a .zip file, e.g. MyApp.zip. Note that using zip will make notarization fail, instead use ditto like so: ditto -c -k --sequesterRsrc --keepParent MyApp.app MyApp.zip
- Run xcrun altool --notarize-app -f MyApp.zip --primary-bundle-id com.unique-identifier-for-this-upload -u username -p password. You can use a password in your keychain by passing -p "@keychain:AC_PASSWORD", where AC_PASSWORD is the key. The account has to be registered as an Apple Developer.
- If the upload is successful, you'll get a UUID back for your request token like this: 28fad4c5-68b3-4dbf-a0d4-fbde8e6a078f
- You can check notarization status using that token like this: xcrun altool --notarization-info 28fad4c5-68b3-4dbf-a0d4-fbde8e6a078f -u username -p password. This could take some time -- eventually it will succeed or fail.
- If it succeeds, you have to staple the notarization to the app: xcrun stapler staple MyApp.app. You can validate this by running xcrun stapler validate MyApp.app.
`.app` `.app` `.zip` `MyApp.zip` `zip` `ditto` `ditto -c -k --sequesterRsrc --keepParent MyApp.app MyApp.zip` `xcrun altool --notarize-app -f MyApp.zip --primary-bundle-id com.unique-identifier-for-this-upload -u username -p password` `-p "@keychain:AC_PASSWORD"` `28fad4c5-68b3-4dbf-a0d4-fbde8e6a078f` `xcrun altool --notarization-info 28fad4c5-68b3-4dbf-a0d4-fbde8e6a078f -u username -p password` `xcrun stapler staple MyApp.app` `xcrun stapler validate MyApp.app` Once notarization is complete, you should be able to distribute your application!
If you distribute your app in a .dmg, you will want to modify the steps slightly:
`.dmg` - Notarize your .app as normal (in a .zip file)
- Add your notarized and stapled (xcrun stapler) app into the DMG (the DMG now has the notarized/stapled .app file inside of it).
- Notarize your .dmg file (same basic xcrun altool command, just with the .dmg file for the -f flag instead of the .zip)
- Staple the notarization to the .dmg file: xcrun stapler staple MyApp.dmg
`.app` `.zip` `xcrun stapler` `.app` `.dmg` `xcrun altool` `.dmg` `-f` `.zip` `.dmg` `xcrun stapler staple MyApp.dmg` ### App Store Packaging​
You need a lot of things:
- Your app satisfies App Store Review Guidelines.
- Your app satisfies macOS Human Interface Guidelines.
- Apple Developer Account, with your Apple ID connected to it.
- Your app is registered in App Store Connect.
- Transporter app installed from App Store.
- Latest Xcode installed with your Apple ID authorized into it.
- Two certificates: 3rd Party Mac Developer Installer for signing .pkg file and 3rd Party Mac Developer Application for signing a bundle.
- App Store Provision Profile - get it for your app here.
- Two entitlements: One for signing .app and other for signing app helpers.
- Your app content is bundled correctly.
- Your bundle is signed correctly.
- Your .dylib files doesn't contain any non-ARM/x64 architectures. You can remove these by using lipo command line tool.
- Your app is ready to be launched from inside a sandbox.
`3rd Party Mac Developer Installer` `.pkg` `3rd Party Mac Developer Application` `.app` `.dylib` `lipo` #### Getting certificates​
- go to Xcode > Preferences > Account > Manage Certificates...
- Add them if they do not exists.
- Export them with a password.
- Open them and import into KeyChain Access.
- In KeyChain you should see this certificates 3rd Party Mac Developer Installer and Apple Distribution. If cert names are started with another strings - you've created a wrong certificate. Try again.
- Expand imported keys in KeyChain and double click on a private key inside.
- Go to Access Control Tab.
- Select Allow all applications to access this item in case you don't want to enter a Mac profile password for every file sign.
`3rd Party Mac Developer Installer` `Apple Distribution` `Allow all applications to access this item` #### Sandbox and bundle​
App Store required app to be launched inside a sandbox. That means app will have no access to everything and cannot harm user's PC.
Your app should be ready for this and do not crash if any folder is read/write protected.
.NET 6 apps will not crash inside a sandbox only if it's published with single file option enabled. Example:
dotnet publish src/MyApp.csproj -c Release -f net6.0 -r osx-x64 --self-contained true -p:PublishSingleFile=true
`dotnet publish src/MyApp.csproj -c Release -f net6.0 -r osx-x64 --self-contained true -p:PublishSingleFile=true` Your app content should be bundled correctly. Here's an article from Apple with a lot of useful info.
Most important rules from the article:
- .dll files are not considered as a code by Apple. So it should be placed inside /Resources folder and can be not signed.
- /MacOS files should contain only executable mach-o - you app executable and any other helper executables
- All other mach-o .dylib files should be inside Frameworks/ folder.
`.dll` `/Resources` `/MacOS` `.dylib` `Frameworks/` To satisfy this requirement without a lot of pain you can use relative symlinks from MacOS/ folder to Resources/ and Frameworks/ folders. As an example:
`MacOS/` `Resources/` `Frameworks/` ln -s fromFile toFile
`ln -s fromFile toFile` Also it's better to rewrite your app's resources access scheme to directly access Resources/ folder without using any symlinks, because over symlinks you might get I/O access issues in sandbox.
`Resources/` #### Sandbox entitlements and signing​
You should read all entitlements documentation and choose the ones your app requires.
First for the entitlements file is to sign all helper executables inside .app/Content/MacOS/ folder. It should look like this.
`.app/Content/MacOS/` ```bash
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict>  <key>com.apple.security.app-sandbox</key>  <true/>  <key>com.apple.security.inherit</key>  <true/></dict></plist>
```
Second is to sign app executable and a whole app bundle. It should contain all app's permissions. Here is an example:
```bash
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict>  <key>com.apple.security.cs.allow-jit</key>  <true/>  <key>com.apple.security.cs.allow-unsigned-executable-memory</key>  <true/>  <key>com.apple.security.cs.disable-library-validation</key>  <true/>  <key>com.apple.security.cs.allow-dyld-environment-variables</key>  <true/>  <key>com.apple.security.app-sandbox</key>  <true/>  <key>com.apple.security.temporary-exception.mach-lookup.global-name</key>  <array>    <string>com.apple.coreservices.launchservicesd</string>  </array></dict></plist>
```
Here are some optional permissions your app may need:
```bash
<key>com.apple.security.network.client</key>  <true/>  <key>com.apple.security.network.server</key>  <true/>  <key>com.apple.security.automation.apple-events</key>  <true/>  <key>com.apple.security.files.user-selected.read-write</key>  <true/>  <key>com.apple.security.files.bookmarks.document-scope</key>  <true/>  <key>com.apple.security.application-groups</key>  <array>   <string>[Your Team ID].[Your App ID]</string>  </array>
```
#### Packaging script​
Here is example packaging script with comments
```bash
#cleanup foldersrm -rf "App/AppName.app/Contents/MacOS/" rm -rf "App/AppName.app/Contents/CodeResources" rm -rf "App/AppName.app/Contents/_CodeSignature" rm -rf "App/AppName.app/Contents/embedded.provisionprofile" mkdir -p "App/AppName.app/Contents/Frameworks/"mkdir -p "App/AppName.app/Contents/MacOS/"#Build appdotnet publish ../../ProjectFolder/AppName.csproj -c release -f net5.0 -r osx-x64 --self-contained true -p:PublishSingleFile=true#Move appcd ..cd ..cp -R -f ProjectFolder/bin/release/net5.0/osx-x64/publish/* "build/osx/App/AppName.app/Contents/MacOS/"cd "build/osx/"APP_ENTITLEMENTS="AppEntitlements.entitlements"APP_SIGNING_IDENTITY="3rd Party Mac Developer Application: [***]"INSTALLER_SIGNING_IDENTITY="3rd Party Mac Developer Installer: [***]"APP_NAME="App/AppName.app"#<here is moving your app resources to Resources folder using relative symlinks>#<here is moving your .dylib files to Frameworks folder using relative symlinks>echo "[INFO] Switch provisionprofile to AppStore"\cp -R -f AppNameAppStore.provisionprofile "App/AppName.app/Contents/embedded.provisionprofile"echo "[INFO] Fix libuv.dylib architectures"lipo -remove i386 "App/AppName.app/Contents/Frameworks/libuv.dylib" "App/AppName.app/Contents/Frameworks/libuv.dylib"find "$APP_NAME/Contents/Frameworks/"|while read fname; do  if [[ -f $fname ]]; then    echo "[INFO] Signing $fname"    codesign --force --sign "$APP_SIGNING_IDENTITY" "$fname"  fidoneecho "[INFO] Signing app executable"codesign --force --entitlements "$FILE_ENTITLEMENTS" --sign "$APP_SIGNING_IDENTITY" "App/AppName.app/Contents/MacOS/AppName"echo "[INFO] Signing app bundle"codesign --force --entitlements "$APP_ENTITLEMENTS" --sign "$APP_SIGNING_IDENTITY" "$APP_NAME"echo "[INFO] Creating AppName.pkg"productbuild --component App/AppName.app /Applications --sign "$INSTALLER_SIGNING_IDENTITY" AppName.pkg
```
#### Testing a package​
Copy your .app into Applications folder and launch it. If it launches correctly - you did everything right. If it crashes - open Console app and check a crash report.
`.app` #### Uploading a package to app store​
Open a Transporter app, sign in, select your *.pkg package and wait for validation and uploading to app store.
If you will receive any errors - fix them, package app again, remove file in Transporter and select it again.
When upload succeeds - you will see your package in App Store Connect.
### Troubleshooting​
#### App menu shows About Avalonia menu item​
This means that your application most likely does not specify a menu. On startup, Avalonia creates the default menu items for an application and automatically adds the About Avalonia item when no menu has been configured. This can be resolved by adding one to your App.xaml:
`App.xaml` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       xmlns:local="using:RoadCaptain.App.RouteBuilder"       x:Class="RoadCaptain.App.RouteBuilder.App">	<NativeMenu.Menu>		<NativeMenu>			<NativeMenuItem Header="About MyApp" Click="AboutMenuItem_OnClick" />		</NativeMenu>	</NativeMenu.Menu></Application>
```
The rest of the macOS default menu items will still be generated by Avalonia.
#### Application name in menu bar does not match​
When you run an app from a bundle the name for the app that is shown in the menu bar is taken from the Info.plist in the bundle instead of the Name property in App.xaml.
`Info.plist` `Name` `App.xaml` If the names do not match, verify that the values for CFBundleName, CFBundleDisplayName and the Name property are the same.
`CFBundleName` `CFBundleDisplayName` `Name` Note that CFBundleName is limited to 15 characters, if your application name is longer you must set CFBundleDisplayName.
`CFBundleName` `CFBundleDisplayName` ### Packaging in GitHub Actions workflow​
Building the app in a CI/CD pipeline is straightforward using the dotnet command. For code signing and notarization to work a little extra work is required.
`dotnet` codesign and notarytool read the certificate and credentials to talk to the notarization service from a Keychain on the build machine:
`codesign` `notarytool` ```bash
# Create a new keychainsecurity create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD}}" build.keychain# Set it as the default keychainsecurity default-keychain -s build.keychain# Unlock the keychain so it can be used without an authorisation promptsecurity unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD}}" build.keychain
```
KEYCHAIN_PASSWORD is a password you generate specifically for this keychain. It can be generated on each build or a password you use for every build.
`KEYCHAIN_PASSWORD` Next, the certificate for signing needs to be imported into the keychain. Because GitHub secrets only support strings, the certificate .p12 file needs to be stored in base64 encoded form. In the pipeline the string is decoded to a file and added to the keychain:
`.p12` ```bash
# Decode certificate to fileecho "${{ secrets.MACOS_CERTIFICATE }}" | base64 --decode > certificate.p12# Import into keychainsecurity import certificate.p12 -k build.keychain -P "${{ secrets.MACOS_CERTIFICATE_PWD}}" -T /usr/bin/codesign
```
MACOS_CERTIFICATE is the base64 encoded .p12 file, MACOS_CERTIFICATE_PWD is the password to the .p12 file.
`MACOS_CERTIFICATE` `.p12` `MACOS_CERTIFICATE_PWD` `.p12` To prevent authorisation prompt popups during code signing, instruct keychain to allow codesign access:
`codesign` ```bash
# Allow codesign to access keychainsecurity set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "${{ secrets.KEYCHAIN_PASSWORD}}" build.keychain
```
As Apple requires multi-factor authentication (MFA) on developer accounts, notarytool uses a dedicated app-password that you can generate on the Apple developer site. We'll add the app-password for notarytool so it can be used later:
`notarytool` `notarytool` ```bash
xcrun notarytool store-credentials "AC_PASSWORD" --apple-id "${{ secrets.APPLE_ID }}" --team-id ${{ env.TEAM_ID }} --password "${{ secrets.NOTARY_TOOL_PASSWORD }}"
```
TEAM_ID is the team id in App Store Connect, APPLE_ID is your Apple account e-mail address, NOTARY_TOOL_PASSWORD is the app-password you generated.
`TEAM_ID` `APPLE_ID` `NOTARY_TOOL_PASSWORD` To use these steps in your GitHub Actions workflow add them as a step to the job that builds your app:
```bash
jobs: build_osx:  runs_on: macos-11  env:   TEAM_ID: MY_TEAM_ID  steps:  - name: Setup Keychain   run: |    security create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD}}" build.keychain    security default-keychain -s build.keychain    security unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD}}" build.keychain    echo "${{ secrets.MACOS_CERTIFICATE }}" | base64 --decode > certificate.p12    security import certificate.p12 -k build.keychain -P "${{ secrets.MACOS_CERTIFICATE_PWD}}" -T /usr/bin/codesign    security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "${{ secrets.KEYCHAIN_PASSWORD}}" build.keychain    xcrun notarytool store-credentials "AC_PASSWORD" --apple-id "${{ secrets.APPLE_ID }}" --team-id ${{ env.TEAM_ID }} --password "${{ secrets.NOTARY_TOOL_PASSWORD }}"
```
When configured like this you will not have to specify a specific keychain file for codesign or notarytool to use.
`codesign` `notarytool` The next steps are to publish the app and sign it. Start by adding this environment variable to the job:
```bash
env:   SIGNING_IDENTITY: thumbprint_of_certificate_added_to_keychain
```
And then add these steps:
```bash
- name: Publish app   run: dotnet publish -c Release -r osx-x64 -o $RUNNER_TEMP/MyApp.app/Contents/MacOS MyApp.csproj  - name: Codesign app   run: |    find "$RUNNER_TEMP/MyApp.app/Contents/MacOS/"|while read fname; do     if [ -f "$fname" ]     then       echo "[INFO] Signing $fname"       codesign --force --timestamp --options=runtime --entitlements MyApp.entitlements --sign "${{ env.$SIGNING_IDENTITY }}" "$fname"     fi    done    codesign --force --timestamp --options=runtime --entitlements MyApp.entitlements --sign "${{ env.SIGNING_IDENTITY }}" "$RUNNER_TEMP/MyApp.app"
```
Note: RUNNER_TEMP is an environment variable provided by GitHub Actions
`RUNNER_TEMP` After code signing the app bundle can now be notarized, by adding this step to the job:
```bash
- name: Notarise app   run: |    ditto -c -k --sequesterRsrc --keepParent "$RUNNER_TEMP/MyApp.app" "$RUNNER_TEMP/MyApp.zip"    xcrun notarytool submit "$RUNNER_TEMP/MyApp.zip" --wait --keychain-profile "AC_PASSWORD"    xcrun stapler staple "$RUNNER_TEMP/MyApp.app"
```
When you run this workflow you will have an app bundle that is signed and notarized, ready for packaging in a disk image or installer.
To verify that code signing worked you will need to download it first to trigger the quarantine functionality of macOS. You can do this by e-mailing it to yourself or using a service like WeTransfer or similar.
Once you've downloaded the app bundle and want to start it you should see the popup from macOS saying that the app was scanned and no malware was found.
- Making the application bundleNotes on creating icon filesNotes on the .app executable filedotnet-bundleManual
- Notes on creating icon files
- Notes on the .app executable file
- dotnet-bundle
- Manual
- Signing Your AppRunning codesign and enabling hardened runtimeNotarizing your software
- Running codesign and enabling hardened runtime
- Notarizing your software
- App Store PackagingGetting certificatesSandbox and bundleSandbox entitlements and signingPackaging scriptTesting a packageUploading a package to app store
- Getting certificates
- Sandbox and bundle
- Sandbox entitlements and signing
- Packaging script
- Testing a package
- Uploading a package to app store
- TroubleshootingApp menu shows About Avalonia menu itemApplication name in menu bar does not match
- App menu shows About Avalonia menu item
- Application name in menu bar does not match
- Packaging in GitHub Actions workflow
- Notes on creating icon files
- Notes on the .app executable file
- dotnet-bundle
- Manual
`.app` - Running codesign and enabling hardened runtime
- Notarizing your software
- Getting certificates
- Sandbox and bundle
- Sandbox entitlements and signing
- Packaging script
- Testing a package
- Uploading a package to app store
- App menu shows About Avalonia menu item
- Application name in menu bar does not match
# Debian / Ubuntu packaging | Avalonia Docs
- Deployment
- Debian / Ubuntu packaging
## Debian / Ubuntu packaging
Avalonia Linux programs can be executed in most Linux distros by double-clicking the executable or by starting it from the terminal. Nevertheless, for a better user experience, it is recommended to have the program installed, so the user can start it via desktop shortcut, that exists in desktop environments such as GNOME and KDE, or via command-line, by having the program added to PATH.
Debian and Ubuntu related distros have their applications packaged in .deb files, that can be installed via sudo apt install ./your_package.deb.
`.deb` `sudo apt install ./your_package.deb` ### Tutorial​
In this tutorial, we will use the dpkg-deb tool to compile your .deb package.
`dpkg-deb` `.deb` #### 1) Organize program files in a staging folder​
Debian packages follow this basic structure:
```bash
./staging_folder/├── DEBIAN│   └── control # package control file└── usr  ├── bin  │   └── myprogram # starter script  ├── lib  │   └── myprogram  │     ├── libHarfBuzzSharp.so # Avalonia native library  │     ├── libSkiaSharp.so # Avalonia native library  │     ├── other_native_library_1.so  │     ├── myprogram_executable # main executable  │     ├── myprogram.dll   │     ├── my_other_dll.dll   │     ├── ... # all files from dotnet publish  └── share    ├── applications    │   └── MyProgram.desktop # desktop shortcut file    ├── icons    │   └── hicolor    │     ├── ... # other resolution icons (optional)    └── pixmaps      └── myprogram.png # main application icon
```
Meaning of each folder:
- DEBIAN: contains the control file.
- /usr/bin/: contains the starter script (recommended for starting your program via command-line).
- /usr/lib/myprogram/: where all files generated by dotnet publish go into.
- /usr/share/applications/: folder for the desktop shortcut.
- /usr/share/pixmaps/ and /usr/share/icons/hicolor/**: folders for application icons.
`DEBIAN` `control` `/usr/bin/` `/usr/lib/myprogram/` `dotnet publish` `/usr/share/applications/` `/usr/share/pixmaps/` `/usr/share/icons/hicolor/**` The /usr/share/icons/hicolor/** are optional, as in your app icon will probably show up on desktop even without those images, however, it is recommended to have them for better resolution.
`/usr/share/icons/hicolor/**` #### 2) Make the control file​
`control` The control file goes inside the DEBIAN folder.
`control` `DEBIAN` This file describes general aspects of your program, such as its name, version, category, dependencies, maintainer, processor architecture and licenses. Debian docs have a more thorough description of all possible fields in the file.
Don't worry too much about filling all possible fields, most aren't required. This tutorial is to make a "good-enough" Debian package.
The .NET dependencies can be listed by running apt show dotnet-runtime-deps-8.0 (suffix changes for other .NET versions); they will appear on the line starting with Depends: .... You can also check them in the .NET Core repo.
`apt show dotnet-runtime-deps-8.0` Avalonia required dependencies are: libx11-6, libice6, libsm6, libfontconfig1.
`libx11-6, libice6, libsm6, libfontconfig1` Overall, all .NET and Avalonia dependencies are required, plus any others specific of your app.
Below is a simple example of a control file.
`control` ```bash
Package: myprogramVersion: 3.1.0Section: develPriority: optionalArchitecture: amd64Installed-Size: 68279Depends: libx11-6, libice6, libsm6, libfontconfig1, ca-certificates, tzdata, libc6, libgcc1 | libgcc-s1, libgssapi-krb5-2, libstdc++6, zlib1g, libssl1.0.0 | libssl1.0.2 | libssl1.1 | libssl3, libicu | libicu74 | libicu72 | libicu71 | libicu70 | libicu69 | libicu68 | libicu67 | libicu66 | libicu65 | libicu63 | libicu60 | libicu57 | libicu55 | libicu52Maintainer: Ken Lee <kenlee@outlook.com>Homepage: https://github.com/kenlee/myprogramDescription: This is MyProgram, great for doing X.Copyright: 2022-2024 Ken Lee <kenlee@outlook.com>
```
#### 3) Make the starter script​
This step is recommended for two reasons: first, to reduce the complexity of the desktop shortcut, and second, to make your app runnable from Terminal.
The starter script file name should preferrably be myprogram (without .sh extension), so whenever your user types "myprogram" on the Terminal, he / she will start your program.
`myprogram` `.sh` The myprogram_executable file usually has the same name as its .NET project, e.g., if your Avalonia .csproj project is named MyProgram.Desktop, then the main executable generated by dotnet publish will be MyProgram.Desktop.
`MyProgram.Desktop` Example of starter script:
```bash
#!/bin/bash# use exec to not have the wrapper script staying as a separate process# "$@" to pass command line arguments to the appexec /usr/lib/myprogram/myprogram_executable "$@"
```
#### 4) Make the desktop shortcut​
The desktop shortcut file follows the freedesktop specification. Arch Linux Wiki also has good related information.
Below is an example of a desktop shortcut file.
```bash
[Desktop Entry]Name=MyProgramComment=MyProgram, great for doing XIcon=myprogramExec=myprogramStartupWMClass=myprogramTerminal=falseType=ApplicationCategories=DevelopmentGenericName=MyProgramKeywords=keyword1; keyword2; keyword3
```
If your app is supposed to open files, append %F at the end of the Exec line, after myprogram; if it's supposed to open URLs, then append %U.
`myprogram` #### 5) Add hicolor icons (optional)​
Hicolor icons follow a folder structure like below.
This blog post advises us to put icons on both hicolor and pixmaps directories, according to Debian Menu System docs and FreeDesktop docs.
`hicolor` `pixmaps` ```bash
├── icons│   └── hicolor│     ├── 128x128│     │   └── apps│     │     └── myprogram.png│     ├── 16x16│     │   └── apps│     │     └── myprogram.png│     ├── 256x256│     │   └── apps│     │     └── myprogram.png│     ├── 32x32│     │   └── apps│     │     └── myprogram.png│     ├── 48x48│     │   └── apps│     │     └── myprogram.png│     ├── 512x512│     │   └── apps│     │     └── myprogram.png│     ├── 64x64│     │   └── apps│     │     └── myprogram.png│     └── scalable│       └── apps│         └── myprogram.svg
```
#### 6) Compile the .deb package​
`.deb` ```bash
# for x64 architectures, the suggested suffix is amd64.dpkg-deb --root-owner-group --build ./staging_folder/ "./myprogram_${versionName}_amd64.deb"
```
### Example of a Linux shell script for the entire process​
```bash
#!/bin/bash# Clean-uprm -rf ./out/rm -rf ./staging_folder/# .NET publish# self-contained is recommended, so final users won't need to install .NETdotnet publish "./src/MyProgram.Desktop/MyProgram.Desktop.csproj" \ --verbosity quiet \ --nologo \ --configuration Release \ --self-contained true \ --runtime linux-x64 \ --output "./out/linux-x64"# Staging directorymkdir staging_folder# Debian control filemkdir ./staging_folder/DEBIANcp ./src/MyProgram.Desktop.Debian/control ./staging_folder/DEBIAN# Starter scriptmkdir ./staging_folder/usrmkdir ./staging_folder/usr/bincp ./src/MyProgram.Desktop.Debian/myprogram.sh ./staging_folder/usr/bin/myprogramchmod +x ./staging_folder/usr/bin/myprogram # set executable permissions to starter script# Other filesmkdir ./staging_folder/usr/libmkdir ./staging_folder/usr/lib/myprogramcp -f -a ./out/linux-x64/. ./staging_folder/usr/lib/myprogram/ # copies all files from publish dirchmod -R a+rX ./staging_folder/usr/lib/myprogram/ # set read permissions to all fileschmod +x ./staging_folder/usr/lib/myprogram/myprogram_executable # set executable permissions to main executable# Desktop shortcutmkdir ./staging_folder/usr/sharemkdir ./staging_folder/usr/share/applicationscp ./src/MyProgram.Desktop.Debian/MyProgram.desktop ./staging_folder/usr/share/applications/MyProgram.desktop# Desktop icon# A 1024px x 1024px PNG, like VS Code uses for its iconmkdir ./staging_folder/usr/share/pixmapscp ./src/MyProgram.Desktop.Debian/myprogram_icon_1024px.png ./staging_folder/usr/share/pixmaps/myprogram.png# Hicolor iconsmkdir ./staging_folder/usr/share/iconsmkdir ./staging_folder/usr/share/icons/hicolormkdir ./staging_folder/usr/share/icons/hicolor/scalablemkdir ./staging_folder/usr/share/icons/hicolor/scalable/appscp ./misc/myprogram_logo.svg ./staging_folder/usr/share/icons/hicolor/scalable/apps/myprogram.svg# Make .deb filedpkg-deb --root-owner-group --build ./staging_folder/ ./myprogram_3.1.0_amd64.deb
```
### To install​
```bash
sudo apt install ./myprogram_3.1.0_amd64.deb
```
### To uninstall / remove​
```bash
sudo apt remove myprogram
```
### Third-party packaging tools for Debian / Ubuntu​
- https://github.com/quamotion/dotnet-packaging
- https://github.com/SuperJMN/DotnetPackaging
- https://github.com/kuiperzone/PupNet-Deploy
- Tutorial1) Organize program files in a staging folder2) Make the control file3) Make the starter script4) Make the desktop shortcut5) Add hicolor icons (optional)6) Compile the .deb package
- 1) Organize program files in a staging folder
- 2) Make the control file
- 3) Make the starter script
- 4) Make the desktop shortcut
- 5) Add hicolor icons (optional)
- 6) Compile the .deb package
- Example of a Linux shell script for the entire process
- To install
- To uninstall / remove
- Third-party packaging tools for Debian / Ubuntu
- 1) Organize program files in a staging folder
- 2) Make the control file
- 3) Make the starter script
- 4) Make the desktop shortcut
- 5) Add hicolor icons (optional)
- 6) Compile the .deb package
`control` `.deb`
# The View Locator | Avalonia Docs
- Deep Dives
- The View Locator
## The View Locator
While the use of the View Locator comes as part of the default templates, it's important to note that it's not a mandatory requirement. It's an optional tool provided to help you structure your Avalonia application using the Model-View-ViewModel (MVVM) design pattern.
The View Locator is a mechanism in Avalonia that is used to resolve the view (user interface) that corresponds to a specific ViewModel. This is a core part of the MVVM (Model-View-ViewModel) pattern, which is a design pattern that separates the development of the graphical user interface from the development of the business logic or back-end logic.
### How it works​
The View Locator uses naming conventions to map ViewModel types to view types. By default, it replaces every occurrence of the string "ViewModel" within the fully-qualified ViewModel type name with "View".
For example, given a ViewModel named MyApplication.ViewModels.ExampleViewModel, the View Locator will look for a View named MyApplication.Views.ExampleView.
`MyApplication.ViewModels.ExampleViewModel` `MyApplication.Views.ExampleView` The View Locator is typically used in conjunction with the DataContext property, which is used to link a view to its ViewModel.
`DataContext` Here's a simple usage example:
```bash
public class ViewLocator : IDataTemplate{  public bool SupportsRecycling => false;  public Control Build(object data)  {    var name = data.GetType().FullName.Replace("ViewModel", "View");    var type = Type.GetType(name);    if (type != null)    {      return (Control)Activator.CreateInstance(type);    }    else    {      return new TextBlock { Text = "Not Found: " + name };    }  }  public bool Match(object data)  {    return data is ViewModelBase;  }}
```
In this example, the View Locator is implemented as an IDataTemplate. The Build method creates the view for the ViewModel, and the Match method checks if the data object is a ViewModel that this locator knows how to handle. If you do not have a ViewModelBase class, at a minimum your ViewModel must implement INotifyPropertyChanged, and the comparison in Match should be changed accordingly.
`IDataTemplate` `Build` `Match` `ViewModelBase` `INotifyPropertyChanged` `Match` ### Customizing the View Locator​
You can customize the View Locator to use different conventions. For example, you might want to look for views in a different assembly, or use a different naming convention. To do this, you can implement your own View Locator by creating a class that implements the IDataTemplate interface, and replace the default View Locator with your own.
`IDataTemplate` ### Using the View Locator​
By default, the View Locator is referenced in App.axaml as a DataTemplate, in the content of the Application.DataTemplates XAML tag. Ensure that its appropriate 'using' statement is in the xmlns:local property of the Application root tag.
`Application.DataTemplates` `xmlns:local` ```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="LearningAvalonia.App"       xmlns:local="using:LearningAvalonia"       RequestedThemeVariant="Default">       <!-- "Default" ThemeVariant follows system theme variant. "Dark" or "Light" are other available options. -->  <Application.DataTemplates>    <local:ViewLocator />  </Application.DataTemplates>  <Application.Styles>    <FluentTheme />  </Application.Styles></Application>
```
- How it works
- Customizing the View Locator
- Using the View Locator
# Styles | Avalonia Docs
- Basics
- User Interface
- Styling
- Styles
## Styles
The Avalonia UI style system is a mechanism that can share property settings between controls.
A Style in Avalonia is more similar to a CSS style than a WPF/UWP style. The equivalent of a WPF/UWP Style in Avalonia is a ControlTheme.
`Style` `ControlTheme` ### How It Works​
In essence, the styling mechanism has two steps: selection and substitution. The XAML for the style can define how both of these steps are to be done, but often you will help the selection step by defining 'class' labels on control elements.
The Avalonia UI styling system's use of 'class' labels on control elements is analogous to how CSS (cascading style sheets) work with HTML elements.
The styling system implements cascading styles by searching the logical tree upwards from a control, during the selection step. This means styles defined at the highest level of the application (the App.axaml file) can be used anywhere in an application, but may still be overridden closer to a control (for example in a window, or user control).
`App.axaml` When a match is located by the selection step, then the matched control's properties are altered according to the setters in the style.
### How it is Written​
The XAML for a style has two parts: a selector attribute, and one or more setter elements. The selector value contains a string that uses the Avalonia UI style selector syntax. Each setter element identifies the property that will be changed by name, and the new value that will be substituted. The pattern is like this:
```bash
<Style Selector="selector syntax">   <Setter Property="property name" Value="new value"/>   ...</Style>
```
The Avalonia UI style selector syntax is analogous to that used by CSS (cascading style sheets). For detailed reference information, see here.
### Example​
This is an example of how a style is written and applied to a control element, with a style class to help selection:
```bash
<Window ... >  <Window.Styles>    <Style Selector="TextBlock.h1">      <Setter Property="FontSize" Value="24"/>      <Setter Property="FontWeight" Value="Bold"/>    </Style>  </Window.Styles>  <StackPanel Margin="20">    <TextBlock Classes="h1">Heading 1</TextBlock>  </StackPanel></Window>
```
In this example, all TextBlock elements with the h1 style class will be displayed with the font size and weight set by the style. This works in the preview pane:
`TextBlock` `h1` ### Where to put Styles​
Styles are placed inside a Styles collection element on a Control or on the Application. For example, a window styles collection looks like this:
`Styles` `Control` `Application` ```bash
<Window.Styles>  <Style> ... </Style></Window.Styles>
```
The location of a styles collection defines the scope of the styles it contains. In the above example, the styles will apply to the window and all of its contents. If a style is added to the Application then it will apply globally.
`Application` ### The Selector​
The style selector defines what controls the style will act upon. The selector uses a variety of formats, one of the simplest is this:
```bash
<Style Selector="TargetControlClass.styleClassName">
```
This selector will match all controls with a style key of TargetControlClass, having a style class of styleClassName.
`TargetControlClass` `styleClassName` A full list of selectors can be found here.
### Setters​
Setters describe what will happen when the selector matches a control. They are simple property/value pairs written in the format:
```bash
<Setter Property="FontSize" Value="24"/><Setter Property="Padding" Value="4 2 0 4"/>
```
Whenever a style is matched with a control, all of the setters within the style will be applied to the control.
For more information on setters see here.
### Nested Styles​
Styles can be nested in other styles. To nest a style, simply include the child style as a child of the parent <Style> element, and start the selector with the Nesting Selector (^):
`<Style>` `Nesting Selector (^)` ```bash
<Style Selector="TextBlock.h1">  <Setter Property="FontSize" Value="24"/>  <Setter Property="FontWeight" Value="Bold"/>    <Style Selector="^:pointerover">    <Setter Property="Foreground" Value="Red"/>  </Style></Style>
```
When this happens, the selector from the parent style will automatically apply to the child style. In the above example the nested style will effectively have a selector of TextBlock.h1:pointerover, meaning that it will display with a red foreground when the pointer is over the control.
`TextBlock.h1:pointerover` The nesting selector must be present and must appear at the start of the child selector.
### Style Key​
The type of an object matched by a style selector is not determined by the concrete type of the control, but rather by examining its StyleKey property.
`StyleKey` By default, the StyleKey property returns the type of the current instance. However, if you want your control, which inherits from Button, to be styled as a Button, you can override the StyleKeyOverride property in your class and have it return typeof(Button).
`StyleKey` `StyleKeyOverride` `typeof(Button)` ```bash
public class MyButton : Button{  // `MyButton` will be styled as a standard `Button` control.  protected override Type StyleKeyOverride => typeof(Button);}
```
Note this this logic is inverted as compared with WPF/UWP: in those frameworks, when you derive a new control it will be styled as its base control unless you override the DefaultStyleKey property. In Avalonia the control will be styled using its concrete type unless a different style key is provided.
`DefaultStyleKey` Before Avalonia 11, the style key was overridden by implementing IStyleable and providing a new implementation of the IStyleable.StyleKey property. This mechanism is still supported in Avalonia 11 for compatibility, but may be removed in a future version.
`IStyleable` `IStyleable.StyleKey` ### Styles and Resources​
Resources are often used with styles to help maintain consistent presentation. Resources can help define standard colors and icons in an application; or across multiple applications when included from separate files.
For guidance on how to use resources in you application, see here.
### Further Information​
For guidance on how to share styles by including a styles file, see here.
- How It Works
- How it is Written
- Example
- Where to put Styles
- The Selector
- Setters
- Nested Styles
- Style Key
- Styles and Resources
- Further Information
# Style Classes | Avalonia Docs
- Basics
- User Interface
- Styling
- Style Classes
## Style Classes
You can assign an Avalonia UI control one or more style classes, and use these to guide style selection. Style classes are assigned in a control element using the Classes attribute. If you want to assign more than one class, then use a space-separated list.
`Classes` For example, this button has both the h1 and blue style classes applied:
`h1` `blue` ```bash
<Button Classes="h1 blue"/>
```
### Pseudo Classes​
Like in CSS, controls can have pseudo classes; these are classes that are defined in the control itself rather than by the user. The names of pseudo classes in a selector always start with a colon.
For example :pointerover pseudo class indicates that the pointer input is currently over (inside the bounds of) a control. (This is pseudo class is the similar to :hover in CSS.)
`:pointerover` `:hover` This is an example of a :pointerover pseudo class selector:
`:pointerover` ```bash
<StackPanel> <StackPanel.Styles>  <Style Selector="Border:pointerover">   <Setter Property="Background" Value="Red"/>  </Style> </StackPanel.Styles> <Border>  <TextBlock>I will have red background when hovered.</TextBlock> </Border></StackPanel>
```
In this example, the pseudo class selector changes properties inside a control template:
```bash
<StackPanel> <StackPanel.Styles>  <Style Selector="Button:pressed /template/ ContentPresenter">    <Setter Property="TextBlock.Foreground" Value="Red"/>  </Style> </StackPanel.Styles> <Button>I will have red text when pressed.</Button></StackPanel>
```
Other pseudo classes include :focus, :disabled, :pressed for buttons, and :checked for checkboxes.
`:focus` `:disabled` `:pressed` `:checked` For more detail about pseudo classes, see the reference here.
### Conditional Classes​
If you need to add or remove a class using a bound condition, then you can use following special syntax:
```bash
<Button Classes.accent="{Binding IsSpecial}" />
```
### Classes in Code​
You can manipulate style classes in code using the Classes collection:
`Classes` ```bash
control.Classes.Add("blue");control.Classes.Remove("red");
```
- Pseudo Classes
- Conditional Classes
- Classes in Code
# Style Selector Syntax | Avalonia Docs
- Reference
- Styles
- Style Selector Syntax
## Style Selector Syntax
This page lists the XAML syntax for style selectors with the C# code methods that perform the same selection.
### By Control Class​
```bash
<Style Selector="Button"><Style Selector="local|Button">
```
```bash
new Style(x => x.OfType<Button>());new Style(x => x.OfType(typeof(Button)));
```
Selects a control by its class name.
The first example above selects the Avalonia.Controls.Button class. To include a XAML namespace in the type separate the namespace and the type with a | character.
`Avalonia.Controls.Button` `|` This selector does not match derived types. For that, use the :is selector, see below.
`:is` Note the type of an object is actually determined by looking at its StyleKey property. By default this simply returns the type of the current instance, but if, for example, you do want your control which inherits from Button to be styled as a Button, then you can override the StyleKeyOverride property on your class to return typeof(Button).
`StyleKey` `Button` `Button` `StyleKeyOverride` `typeof(Button)` ### By Name​
```bash
<Style Selector="#myButton"><Style Selector="Button#myButton">
```
```bash
new Style(x => x.Name("myButton"));new Style(x => x.OfType<Button>().Name("myButton"));
```
Selects a control by its Name attribute, with an added # (hash) character prefix.
`Name` `#` ### By Style Class​
```bash
<Style Selector="Button.large"><Style Selector="Button.large.red">
```
```bash
new Style(x => x.OfType<Button>().Class("large"));new Style(x => x.OfType<Button>().Class("large").Class("red"));
```
Selects a control with the specified style class or classes. Multiple classes are separated with a full stop. If multiple classes are specified in the selector, then the control must have all of the requested classes defined for a match.
### By Pseudo Class​
```bash
<Style Selector="Button:focus"><Style Selector="Button:focus:pointerover"><Style Selector="Button.large:focus">
```
```bash
new Style(x => x.OfType<Button>().Class(":focus"));new Style(x => x.OfType<Button>().Class(":focus").Class(":pointerover"));new Style(x => x.OfType<Button>().Class("large").Class(":focus"));
```
Selects a control using its current pseudo class. The colon character defines the start of the pseudo class name in the selector. Multiple pseudo classes may be applied to the same Control.
For more detail about pseudo classes, see the reference here.
### Include Derived Classes​
```bash
<Style Selector=":is(Button)"><Style Selector=":is(local|Button)">
```
```bash
new Style(x => x.Is<Button>());new Style(x => x.Is(typeof(Button)));
```
This is very similar to the style class selector except it also matches derived types.
Technical detail: during the matching process, Avalonia UI determines the type of a control by examining its StyleKey property.
`StyleKey` Interestingly, this allows you to write very general class-based selectors. As controls are all derived from the class Control, a selector that only selects on the style class margin2 can be written:
`Control` `margin2` ```bash
<Style Selector=":is(Control).margin2"><Style Selector=":is(local|Control.margin2)">
```
```bash
new Style(x => x.Is<Control>().Class("margin2"));new Style(x => x.Is(typeof(Control)).Class("margin2"));
```
### Child Operator​
```bash
<Style Selector="StackPanel > Button">
```
```bash
new Style(x => x.OfType<StackPanel>().Child().OfType<Button>());
```
A child selector is defined by separating two selectors with a > character. This selector matches only direct children in the logical controls tree.
`>` For the concept behind the logical controls tree, see here.
For example, applying the above selector to this XAML:
```bash
<StackPanel>  <Button>Save</Button>  <DockPanel Width="300" Height="300">    <Button DockPanel.Dock="Top">Top</Button>    <TextBlock>Some text</TextBlock>  </DockPanel></StackPanel>
```
The selector will match the first button, but not the second. This is because the second button is not a direct child of the stack panel (it is inside the dock panel as well).
### Any Descendant Operator​
```bash
<Style Selector="StackPanel Button">
```
```bash
new Style(x => x.OfType<StackPanel>().Descendant().OfType<Button>());
```
When two selectors are separated by a space, then the selector will match any descendants in the logical tree. The parent is on the left, and the descendant is on the right.
Therefore applying the above selector to the previous XAML sample, both buttons will be selected.
### By Property Match​
```bash
<Style Selector="Button[IsDefault=true]">
```
```bash
new Style(x => x.OfType<Button>().PropertyEquals(Button.IsDefaultProperty, true));
```
You can refine a selector so that it includes the value of a property. The property=value pair is defined inside square brackets. This matches any control that has the specified property set to the specified value.
```bash
<StackPanel Orientation="Horizontal">  <Button IsDefault="True">Save</Button>  <Button>Cancel</Button>  </StackPanel>
```
For example, in the XAML above, the first button will be selected, but not the second button.
Note: when you use an attached property as a property match, the property name must be wrapped in parentheses. For example:
```bash
<Style Selector="TextBlock[(Grid.Row)=0]">
```
Further note: when you use a property match, the property type must support the component model type converter, TypeConverter class. For more information see the Microsoft documentation here.
`TypeConverter` ### By Template​
```bash
<Style Selector="Button /template/ ContentPresenter">
```
```bash
new Style(x => x.OfType<Button>().Template().OfType<ContentPresenter>());
```
You can match a control in a control template using the above syntax. All the other selectors listed here work on the logical tree, but this selector can step into a template.
In the example above, if a button has a template, then the selector matches selects content presenter controls (class ContentPresenter) inside the template.
`ContentPresenter` ### Not Function​
```bash
<Style Selector="TextBlock:not(.h1)">
```
```bash
new Style(x => x.OfType<TextBlock>().Not(y => y.Class("h1")));
```
This function negates the selection in the brackets. In the example above all the text block controls that do not have the h1 class will be matched.
`h1` ### By List​
```bash
<Style Selector="TextBlock, Button">
```
```bash
new Style(x => Selectors.Or(x.OfType<TextBlock>(), x.OfType<Button>()))
```
You can select any element that matches a comma-separated list of selectors. Any setters in the style must change properties that are common to all the items.
### By Child Position Formula​
```bash
<Style Selector="TextBlock:nth-child(2n+3)">
```
```bash
new Style(x => x.OfType<TextBlock>().NthChild(2, 3));
```
You can match elements based on their position within a group of siblings. This is regardless of the class of the parent (container) control.
Selection is based on a simple formula in the style An + B so that A controls the step size and B the offset from the start. In the nth-child formula (above), n is supplied to the formula as zero and all positive integers starting at zero, and the match is made against the results of the formula compared with a one-based position of the child element.
`An + B` `A` `B` `n` So, for the above selector:
If the formula evaluates to less than 1 then it is ignored - there are never any child element with that index.
There is a corresponding selector with a formula that counts from the end of the group:
```bash
<Style Selector="TextBlock:nth-last-child(2n+3)">
```
```bash
new Style(x => x.OfType<TextBlock>().NthLastChild(2, 3));
```
#### Single child position​
You can omit the A and n from the formula in XAML to specify a single position only. For example, this selects only child number 3:
```bash
<Style Selector="TextBlock:nth-child(3)">
```
```bash
new Style(x => x.OfType<TextBlock>().NthChild(0, 3));
```
#### Keyword notation​
You can also use a keyword notation in place of the formula: odd or even. So these are selectors are equivalent:
`odd` `even` ```bash
<Style Selector="TextBlock:nth-child(2n)"><Style Selector="TextBlock:nth-child(even)">
```
```bash
<Style Selector="TextBlock:nth-child(2n+1)"><Style Selector="TextBlock:nth-child(odd)">
```
#### Other Formula Examples​
This table lists some examples of selection by child position:
`:nth-child(odd)` `:nth-child(even)` `:nth-child(2n+1)` `:nth-child(odd)` `:nth-child(2n)` `:nth-child(even)` `:nth-child(7)` `:nth-child(n+7)` `:nth-child(3n+4)` `:nth-child(-n+3)` #### Online Child Position Tester​
Although this is a CSS site, it will work for Avalonia UI child position selectors because the rules are the same.
You can use this site to test your child position selector: https://css-tricks.com/examples/nth-child-tester/
### Nesting​
```bash
<Style Selector="TextBlock">  <Setter Property="FontSize" Value="24"/>    <!-- Effectively "TextBlock:pointerover" -->  <Style Selector="^:pointerover">    <Setter Property="FontWeight" Value="Bold"/>  </Style></Style>
```
```bash
new Style(x => x.OfType<TextBlock>()){  Setters = { new Setter(TextBlock.FontSizeProperty, 24d) },  Children =  {    new Style(x => x.Nesting().Class(":pointerover"))    {      Setters = { new Setter(TextBlock.FontWeightProperty, FontWeight.Bold) }    }  }};
```
- By Control Class
- By Name
- By Style Class
- By Pseudo Class
- Include Derived Classes
- Child Operator
- Any Descendant Operator
- By Property Match
- By Template
- Not Function
- By List
- By Child Position FormulaSingle child positionKeyword notationOther Formula ExamplesOnline Child Position Tester
- Single child position
- Keyword notation
- Other Formula Examples
- Online Child Position Tester
- Nesting
- Single child position
- Keyword notation
- Other Formula Examples
- Online Child Position Tester
# Styles | Avalonia Docs
- Basics
- User Interface
- Styling
- Styles
## Styles
The Avalonia UI style system is a mechanism that can share property settings between controls.
A Style in Avalonia is more similar to a CSS style than a WPF/UWP style. The equivalent of a WPF/UWP Style in Avalonia is a ControlTheme.
`Style` `ControlTheme` ### How It Works​
In essence, the styling mechanism has two steps: selection and substitution. The XAML for the style can define how both of these steps are to be done, but often you will help the selection step by defining 'class' labels on control elements.
The Avalonia UI styling system's use of 'class' labels on control elements is analogous to how CSS (cascading style sheets) work with HTML elements.
The styling system implements cascading styles by searching the logical tree upwards from a control, during the selection step. This means styles defined at the highest level of the application (the App.axaml file) can be used anywhere in an application, but may still be overridden closer to a control (for example in a window, or user control).
`App.axaml` When a match is located by the selection step, then the matched control's properties are altered according to the setters in the style.
### How it is Written​
The XAML for a style has two parts: a selector attribute, and one or more setter elements. The selector value contains a string that uses the Avalonia UI style selector syntax. Each setter element identifies the property that will be changed by name, and the new value that will be substituted. The pattern is like this:
```bash
<Style Selector="selector syntax">   <Setter Property="property name" Value="new value"/>   ...</Style>
```
The Avalonia UI style selector syntax is analogous to that used by CSS (cascading style sheets). For detailed reference information, see here.
### Example​
This is an example of how a style is written and applied to a control element, with a style class to help selection:
```bash
<Window ... >  <Window.Styles>    <Style Selector="TextBlock.h1">      <Setter Property="FontSize" Value="24"/>      <Setter Property="FontWeight" Value="Bold"/>    </Style>  </Window.Styles>  <StackPanel Margin="20">    <TextBlock Classes="h1">Heading 1</TextBlock>  </StackPanel></Window>
```
In this example, all TextBlock elements with the h1 style class will be displayed with the font size and weight set by the style. This works in the preview pane:
`TextBlock` `h1` ### Where to put Styles​
Styles are placed inside a Styles collection element on a Control or on the Application. For example, a window styles collection looks like this:
`Styles` `Control` `Application` ```bash
<Window.Styles>  <Style> ... </Style></Window.Styles>
```
The location of a styles collection defines the scope of the styles it contains. In the above example, the styles will apply to the window and all of its contents. If a style is added to the Application then it will apply globally.
`Application` ### The Selector​
The style selector defines what controls the style will act upon. The selector uses a variety of formats, one of the simplest is this:
```bash
<Style Selector="TargetControlClass.styleClassName">
```
This selector will match all controls with a style key of TargetControlClass, having a style class of styleClassName.
`TargetControlClass` `styleClassName` A full list of selectors can be found here.
### Setters​
Setters describe what will happen when the selector matches a control. They are simple property/value pairs written in the format:
```bash
<Setter Property="FontSize" Value="24"/><Setter Property="Padding" Value="4 2 0 4"/>
```
Whenever a style is matched with a control, all of the setters within the style will be applied to the control.
For more information on setters see here.
### Nested Styles​
Styles can be nested in other styles. To nest a style, simply include the child style as a child of the parent <Style> element, and start the selector with the Nesting Selector (^):
`<Style>` `Nesting Selector (^)` ```bash
<Style Selector="TextBlock.h1">  <Setter Property="FontSize" Value="24"/>  <Setter Property="FontWeight" Value="Bold"/>    <Style Selector="^:pointerover">    <Setter Property="Foreground" Value="Red"/>  </Style></Style>
```
When this happens, the selector from the parent style will automatically apply to the child style. In the above example the nested style will effectively have a selector of TextBlock.h1:pointerover, meaning that it will display with a red foreground when the pointer is over the control.
`TextBlock.h1:pointerover` The nesting selector must be present and must appear at the start of the child selector.
### Style Key​
The type of an object matched by a style selector is not determined by the concrete type of the control, but rather by examining its StyleKey property.
`StyleKey` By default, the StyleKey property returns the type of the current instance. However, if you want your control, which inherits from Button, to be styled as a Button, you can override the StyleKeyOverride property in your class and have it return typeof(Button).
`StyleKey` `StyleKeyOverride` `typeof(Button)` ```bash
public class MyButton : Button{  // `MyButton` will be styled as a standard `Button` control.  protected override Type StyleKeyOverride => typeof(Button);}
```
Note this this logic is inverted as compared with WPF/UWP: in those frameworks, when you derive a new control it will be styled as its base control unless you override the DefaultStyleKey property. In Avalonia the control will be styled using its concrete type unless a different style key is provided.
`DefaultStyleKey` Before Avalonia 11, the style key was overridden by implementing IStyleable and providing a new implementation of the IStyleable.StyleKey property. This mechanism is still supported in Avalonia 11 for compatibility, but may be removed in a future version.
`IStyleable` `IStyleable.StyleKey` ### Styles and Resources​
Resources are often used with styles to help maintain consistent presentation. Resources can help define standard colors and icons in an application; or across multiple applications when included from separate files.
For guidance on how to use resources in you application, see here.
### Further Information​
For guidance on how to share styles by including a styles file, see here.
- How It Works
- How it is Written
- Example
- Where to put Styles
- The Selector
- Setters
- Nested Styles
- Style Key
- Styles and Resources
- Further Information
# Themes | Avalonia Docs
- Basics
- User Interface
- Styling
- Themes
## Themes
In Avalonia, themes are complete sets of control themes and theme resources for built-in controls.
### Official themes​
Avalonia provides two built-in themes:
#### Fluent theme​
- Fluent Theme is a modern theme inspired by Microsoft's Fluent Design System.
#### Simple theme​
- Simple Theme is an minimal and lightweight theme with limited built-in styling.
### Community themes​
Several themes, in varying stages of development, have been brought to life by our dedicated community
#### Material.Avalonia​
- Material.Avalonia is a modern theme inspired by Google's Material Design System.
#### Semi.Avalonia​
- Semi.Avalonia is inspired by Semi Design
#### Classic.Avalonia​
- Classic.Avalonia is a classic theme inspired by the design of Windows 9x family.
- Official themesFluent themeSimple theme
- Fluent theme
- Simple theme
- Community themesMaterial.AvaloniaSemi.AvaloniaClassic.Avalonia
- Material.Avalonia
- Semi.Avalonia
- Classic.Avalonia
- Fluent theme
- Simple theme
- Material.Avalonia
- Semi.Avalonia
- Classic.Avalonia
# Fluent Theme | Avalonia Docs
- Basics
- User Interface
- Styling
- Themes
- Fluent Theme
## Fluent Theme
### Introduction​
Avalonia Fluent theme is inspired by Microsoft's Fluent Design System, which is a set of design guidelines and components for creating visually appealing and interactive user interfaces. The Fluent Design System emphasizes modern, clean aesthetics, smooth animations, and intuitive interactions. It provides a consistent and polished look-and-feel across different platforms, while giving developers flexibility with our styling system.
![Fluent Theme](https://docs.avaloniaui.net/assets/images/fluent-theme-normal-60a108f0a7e60f2fd8d132e3e6db5bf2.png)
### How to use​
As a first step, Avalonia.Themes.Fluent nuget package needs to be installed.
On how to add a nuget package, you can follow steps from the NuGet page or Visual Studio, Rider documentation.
After that theme needs to be included in the Application class:
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"> <Application.Styles>  <FluentTheme /> </Application.Styles></Application>
```
If you need to specify theme dark or light variant, please follow Theme Variants documentation.
### Changing theme density​
Fluent theme has two sets of predefined density variants. To switch to more compact look, you can set it with DensityStyle property:
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"> <Application.Styles>  <FluentTheme DensityStyle="Compact" /> </Application.Styles></Application>
```
### Creating custom color palettes​
While FluentTheme has build-in resources for dark and light variants, it's still possible to override base palette for these variants. It is useful, when developers want to use the same base theme, but with different colors.
To do so, you need to define
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"> <Application.Styles>  <FluentTheme>   <FluentTheme.Palettes>    <!-- Palette for Light theme variant -->    <ColorPaletteResources x:Key="Light" Accent="Green" RegionColor="White" ErrorText="Red" />    <!-- Palette for Dark theme variant -->    <ColorPaletteResources x:Key="Dark" Accent="DarkGreen" RegionColor="Black" ErrorText="Yellow" />   </FluentTheme.Palettes>  </FluentTheme> </Application.Styles></Application>
```
While ColorPaletteResources has many color properties that can be overridden independently for each variant, it is possible to redefine only minimal set of what's needed, and keep everything else as per defaults. As in examples above, only a couple of colors are overridden.
`ColorPaletteResources` If Accent is not overridden, Avalonia uses platform OS accent color if available. Also, Accent supports bindings and can be changed in runtime. But not other properties, as they are read once after app started and are statically used for performance reasons.
It is possible to build palettes from the code behind, but same rules apply - only Accent can be updated dynamically, and palettes should be
FluentTheme supports only Dark and Light theme variants, and it's not possible to define palettes for custom variants.
### Creating custom color palettes with online editor​
Microsoft Fluent Theme Editor was ported to Avalonia and now available to be used with our FluentTheme as well. It is available on https://theme.xaml.live/ page and supports following features:
- Editing palette colors for both Light and Dark variants.
- Previewing of the current palette.
- Exporting current palettes as XAML code that can be copy pasted into App.axaml file.
- Saving current colors in a json file and loading it from the file system.
- Automatic hints, when palette has a low contrast between colors.
- Couple of quick start presets.
`App.axaml` Example of FluentTheme with a Forest palette preset available on the web app:
![Fluent Theme Forest Palette](https://docs.avaloniaui.net/assets/images/fluent-theme-forest-a943ef0d7b72b1f562553036777ab352.png)
- Introduction
- How to use
- Changing theme density
- Creating custom color palettes
- Creating custom color palettes with online editor
# Simple Theme | Avalonia Docs
- Basics
- User Interface
- Styling
- Themes
- Simple Theme
## Simple Theme
### Introduction​
Avalonia Simple theme is specifically designed to be minimal and lightweight, with limited built-in styling. It provides a simple and clean foundation for building custom styles on top. Low visual and structural complexity makes it a perfect choice for applications running on embedded devices.
![Simple Theme](https://docs.avaloniaui.net/assets/images/simple-theme-6104f94d9d94f1971a088d47b16aa0df.png)
### How to use​
As a first step, Avalonia.Themes.Simple nuget package needs to be installed.
On how to add a nuget package, you can follow steps from the NuGet page or Visual Studio, Rider documentation.
After that theme needs to be included in the Application class:
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="AvaloniaApplication.App"> <Application.Styles>  <SimpleTheme /> </Application.Styles></Application>
```
If you need to specify theme dark or light variant, please follow Theme Variants documentation.
- Introduction
- How to use
# Troubleshooting | Avalonia Docs
- Basics
- User Interface
- Styling
- Troubleshooting
## Troubleshooting
### My Control Theme isn't being found​
If you're having trouble getting Avalonia to find your theme, make sure it's returning a style key which matches the x:Key and TargetType of your control theme.
`x:Key` `TargetType` ### My Control Theme is Breaking Other Controls​
Many Avalonia controls consist of a combination of other Avalonia controls. If you create a style or control theme that applies to all controls of a type, you might get unexpected results. For example, if you create a style that targets the TextBlock type in a Window, the style is applied to all TextBlock controls in the window, even if the TextBlock is part of another control, such as a ListBox.
`TextBlock` `Window` `TextBlock` `TextBlock` `ListBox` ### Application Window is transparent or there is no content rendered​
Make sure you have installed and included Avalonia theme in your application. If you use built-in Fluent or Simple themes, please visit their corresponding pages on how to install them.
If you use third party themes, please contact their maintainers.
- My Control Theme isn't being found
- My Control Theme is Breaking Other Controls
- Application Window is transparent or there is no content rendered
# The MVVM Pattern | Avalonia Docs
- Deep Dives
- The MVVM Pattern
## The MVVM Pattern
The Model-View-View Model (MVVM) pattern is a common way of structuring a UI application. It uses a data binding system that helps move data between its view and view model parts. This means it achieves separation of application logic (view model) from the display of the UI (view).
Separation between the application logic and the business services (model) is commonly achieved by a Dependency Injection (DI) system.
MVVM might be overkill for a simple application; but as applications grow over time, they will often reach a point where keeping display definition and application logic in the same UI component modules becomes a problem:
- Interactions between UI components become complicated and error-prone.
- It becomes difficult to unit test UI components due to dependencies on the target UI platform.
MVVM solves this by abstracting the application logic into code-only classes that do not depend on the target UI platform, and can therefore be unit tested independently.
To discover more about the background to the MVVM pattern, see the Microsoft Patterns and Practices article here.
### When to use MVVM?​
MVVM is a more complex pattern of programming compared to the event-driven code-behind pattern. You have an additional learning overhead to master the techniques of the ReactiveUI framework which you will use to implement MVVM with Avalonia UI.
In fact, the code-behind pattern may well be easier for you to understand and maintain for a small simple application.
For details of how to program Avalonia UI with the code-behind pattern, see here.
The advantages of using the MVVM pattern may only become apparent when an application grows and becomes more complex. You therefore have two development strategies to consider:
- Start by using the simpler code-behind pattern. Aim to convert to MVVM should the application become difficult to maintain.
- Use MVVM from the start because you expect the application to grow.
You can use the following pages to learn about using MVVM with Avalonia UI whichever of the above strategies you adopt.
- When to use MVVM?
# The Main Window | Avalonia Docs
- Deep Dives
- The Main Window
## The Main Window
The main window is the window passed to ApplicationLifetime.MainWindow in the OnFrameworkInitializationCompleted method of your App.axaml.cs file:
`ApplicationLifetime.MainWindow` `OnFrameworkInitializationCompleted` `App.axaml.cs` ```bash
public override void OnFrameworkInitializationCompleted(){  if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktopLifetime)  {    desktopLifetime.MainWindow = new MainWindow();  }}
```
It can be retrieved at any time by casting Application.Current.ApplicationLifetime to IClassicDesktopStyleApplicationLifetime.
`Application.Current.ApplicationLifetime` `IClassicDesktopStyleApplicationLifetime` Worth mentioning, developers should keep in mind, that using static globals and accessing MainWindow from any place of the app can be dangerous and sometimes cause bad UX. All top-level (window) related APIs should be used from the most specific top-level, usually, it's the latest active one. In this way, user dialogs won't be opened from the wrong window, for example.
Mobile and browser platforms don't have a concept of Window in Avalonia. Instead, you need to set MainView control in Application.ApplicationLifetime when it implements ISingleViewApplicationLifetime interface.
# KeyBinding and MouseBinding | Avalonia Docs
- Deep Dives
- Input
- KeyBinding and MouseBinding
## KeyBinding and MouseBinding
- This section explains how to place shortcut keys that often appear in business tools in various controls.
- As an example, binding with double-click or the Enter key on a simple list box.
- It also works for DataGrid.
- XAML
- CodeBehind
- ViewModel
```bash
<UserControl ..>  <StackPanel>    <ListBox      DoubleTapped="ListBox_DoubleTapped"      ItemsSource="{Binding OperatingSystems}"      SelectedItem="{Binding OS}">      <ListBox.KeyBindings>        <!-- Enter -->        <KeyBinding Command="{Binding PrintItem}" Gesture="Enter" />        <!--          MouseBindings are not supported.          Instead, handle it in the view's code-behind. (DoubleTapped event)        -->      </ListBox.KeyBindings>    </ListBox>    <TextBlock Text="{Binding Result}">      <TextBlock.ContextMenu>        <ContextMenu>          <!-- Right Click -->          <MenuItem Command="{Binding Clear}" Header="Clear" />        </ContextMenu>      </TextBlock.ContextMenu>    </TextBlock>  </StackPanel></UserControl>
```
```bash
public partial class MainView : UserControl{  public MainView()  {    InitializeComponent();  }  private void ListBox_DoubleTapped(object? sender, Avalonia.Input.TappedEventArgs e)  {    if (DataContext is MainViewModel vm)    {      vm.PrintItem.Execute(null);    }  }}
```
```bash
public class MainViewModel : ViewModelBase{  public List<string> OperatingSystems =>  [    "Windows",    "Linux",    "Mac",  ];  public string OS { get; set; } = string.Empty;  [Reactive]  public string Result { get; set; } = string.Empty;  public ICommand PrintItem { get; }  public ICommand Clear { get; }  public MainViewModel()  {    PrintItem = ReactiveCommand.Create(() => Result = OS);    Clear = ReactiveCommand.Create(() => Result = string.Empty);  }}
```
![](https://docs.avaloniaui.net/assets/images/binding-key-mouse-test-c8621a926af37f748eee7f587ae49158.gif)
# Keyboard and Hotkeys | Avalonia Docs
- Deep Dives
- Input
- Keyboard and Hotkeys
## Keyboard and Hotkeys
Various Controls that implement ICommandSource have a HotKey property that you can set or bind to. Pressing the hotkey will execute the command bound to the Control.
`ICommandSource` `HotKey` ```bash
<Menu>  <MenuItem Header="_File">    <MenuItem x:Name="SaveMenuItem" Header="_Save" Command="{Binding SaveCommand}" HotKey="Ctrl+S"/>  </MenuItem></Menu>
```
You can also use the static methods of the HotKeyManager class to set and get hotkeys from code:
`HotKeyManager` ```bash
InitializeComponent();HotKeyManager.SetHotKey(saveMenuItem, new KeyGesture(Key.S, KeyModifiers.Control));
```
### Keys and Modifiers​
A Hotkey must have one Key and zero or more KeyModifiers. When setting a Hotkey in XAML using the HotKey property, the string will be parsed as a KeyGesture. Enum.Parse is used to parse the key and modifiers but synonyms like Ctrl instead of Control or Win instead of Meta can be used.
`HotKey` `Ctrl` `Control` `Win` `Meta` ### Assign number keys to hotkeys​
- A Hotkey must be use D1..D0 or NumPad1..NumPad0. see: Key
- By binding the same command to two buttons and hiding one button, you can differentiate between a single number on the numpad and a simple Ctrl+number key.
- If you want to limit command malfunctions caused by pressing numbers on the numpad, you can also use KeyModifiers.
```bash
<!-- It's worked fine --><!-- e.g. Ctrl+1 --><Button  Command="{Binding CommandX}"  Content="[1]"  HotKey="Ctrl+D1" /><!-- e.g. You can also use Alt+NumPad1 --><Button  Command="{Binding CommandX}"  HotKey="NumPad1"  IsVisible="False" /><!-- These didn't work --><!-- Alt+Number --><Button Command="{Binding CommandX}" Content="_1" />
```
#### Reference​
- HotKeyManager
- KeyGesture
- KeyModifiers
- Key
#### Source code​
- HotkeyManager.cs
- KeyGesture.cs
- Keys and Modifiers
- Assign number keys to hotkeysReferenceSource code
- Reference
- Source code
- Reference
- Source code
# Adding Interactivity | Avalonia Docs
- Basics
- User Interface
- Adding Interactivity
## Adding Interactivity
One of the fundamental things that a user interface must do is interact with the user. In Avalonia, you can add interactivity to your applications by leveraging events and commands. This guide will introduce events and commands with simple examples.
### Handling Events​
Events in Avalonia provide a way to respond to user interactions and control-specific actions. You can handle events by following these steps:
- Implement the Event Handler: Write an event handler in the code-behind that will be executed when the event is triggered. The event handler should contain the logic you want to execute in response to the event.
```bash
public partial class MainWindow : Window{  public MainWindow()  {    InitializeComponent();  }  private void HandleButtonClick(object sender, RoutedEventArgs e)  {    // Event handling logic goes here  }}
```
- Subscribe to the Event: Identify the event you want to handle in your control. Most controls in Avalonia expose various events, such as Click or SelectionChanged. Subscribe to the event in XAML by locating the control and adding an attribute with the name of the event and a value indicating the name of the event handler method.
`Click` `SelectionChanged` ```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    x:Class="AvaloniaApplication1.Views.MainWindow"> <Button Name="myButton" Content="Click Me" Click="HandleButtonClick" /></Window>
```
The above example adds a handler called HandleButtonClick to a Button's Click event.
`HandleButtonClick` `Button` `Click` ### Using Commands​
Commands in Avalonia provide a higher-level approach to handling user interactions, decoupling the user action from the implementation logic. Whereas events are defined in a control's code-behind, commands are usually bound to a property or method on the data context.
Commands are available in all controls which provide a Command property. The command is usually triggered when the control's primary method of interaction occurs, for example a button click.
`Command` The simplest way of using commands is to bind to a method in the object's data context.
- Add a method to the view model: Define a method in a view model which will handle the command.
```bash
public class MainWindowViewModel  {    public bool HandleButtonClick()    {      // Event handling logic here    }  }
```
- Bind the Method: Associate the method with the control that triggers it. XAML<Button Content="Click Me" Command="{Binding HandleButtonClick}" />
Bind the Method: Associate the method with the control that triggers it.
```bash
<Button Content="Click Me" Command="{Binding HandleButtonClick}" />
```
- Handling Events
- Using Commands
# Gestures | Avalonia Docs
- Deep Dives
- Input
- Gestures
## Gestures
Controls can detect gestures using Gesture Recognizers. These recognizers are hosted in controls, and listen for and track pointer events that the control receives, sending gesture events when they have detected a gesture has started.
All gesture recognizers derive from the base class GestureRecognizer, and can be attached to a control using the control's GestureRecognizers property. The following shows an Image hosting a ScrollGestureRecognizer;
`GestureRecognizer` `GestureRecognizers` `ScrollGestureRecognizer` ```bash
<Image Stretch="UniformToFill"    Margin="5"    Name="image"    Source="/image.jpg"> <Image.GestureRecognizers>  <ScrollGestureRecognizer CanHorizontallyScroll="True"               CanVerticallyScroll="True"/> </Image.GestureRecognizers></Image>
```
```bash
image.GestureRecognizers.Add(new ScrollGestureRecognizer()      {        CanVerticallyScroll = true,        CanHorizontallyScroll = true,      });
```
### More Information​
You can view more information on the available gesture recognizers here
You can view the source for related classes
GestureRecognizer
GestureRecognizerCollection
- More Information
# Gestures | Avalonia Docs
- Reference
- Gestures
## Gestures
Avalonia UI provides following gesture recognizers:
- PinchGestureRecognizer
- PullGestureRecognizer
- ScrollGestureRecognizer
### ​
#### ​
### ​
# Focus | Avalonia Docs
- Deep Dives
- Input
- Focus
## Focus
Focus refers to the InputElement which is expected to receive keyboard input and are typically distinguished with a visual indicator. The most familiar example is a TextBox with a blinking cursor inside, but non-textual controls like Button and Slider also participate in focus.
`InputElement` `TextBox` `Button` `Slider` ### IsFocused and Focusable​
IsFocused is a get-only property that keeps track of the InputElement's focus state.
`IsFocused` `InputElement` The Focusable property enables or disables the ability to focus an InputElement. Elements which cannot be focused can still be interacted with via pointer, so some care should be taken that a functional keyboard equivalent (such as hotkeys) is available when possible.
`Focusable` `InputElement` ### Explicit Focusing​
To explicitly assign focus to any InputElement, call its .Focus() method from code. Optionally, you may specify the NavigationMethod and KeyModifiers to simulate as if the focus were triggered by a specific focus navigation flow. Explicit focusing is often used to focus a specific InputElement in a data entry form upon loading or to programmatically move to the next InputControl once the current input has been satisfied.
`InputElement` `.Focus()` `NavigationMethod` `KeyModifiers` `InputElement` `InputControl` `XYFocus` ### Focus Events​
InputElements expose GotFocus and LostFocus events. The GotFocusEventArgs contains the NavigationMethod and KeyModifiers used to trigger the focus navigation.
`InputElement` `GotFocus` `LostFocus` `GotFocusEventArgs` `NavigationMethod` `KeyModifiers` ### Focus Pseudoclasses​
These pseudoclasses are helpful when styling Controls that are Focusable.
`Control` `Focusable` The FocusAdorner property is used to show a default focus visual, typically a Border, around a Control with :focus-visible. When using :focus-visible to show a custom visual indicator, setting FocusAdorner to null will avoid showing a duplicate indicator.
`FocusAdorner` `Border` `Control` `:focus-visible` `:focus-visible` `FocusAdorner` `null` ### FocusManager​
The FocusManager provides global access to focus functionality, such as retrieving the currently focused element or clearing focus. For additional information, see the FocusManager docs.
`FocusManager` ### Tab Focus Navigation​
Focus navigation by tab occurs when the user presses tab on their keyboard. InputElements with their IsTabStop property set to true will be available for tab focus navigation. The TabIndex specifies the priority with lower numeric values being navigated to first. When the TabIndex of multiple controls is equal, the priority is based on a Visual Tree traversal order.
`InputElement` `IsTabStop` `true` `TabIndex` `TabIndex` The KeyboardNavigation.TabNavigation attached property can set a KeyboardNavigationMode onto any InputElement acting as a container and modify its tab navigation characteristics.
`KeyboardNavigation.TabNavigation` `KeyboardNavigationMode` `InputElement` `TabIndex` ### Directional Focus Navigation v11.1​
Focus navigation through XYFocus is a 2D directional scheme enabling spatial navigation from the focused control towards another control in a cardinal direction: left, right, up, or down. By default, XYFocus.NavigationModes is set to allow Gamepad and Remote navigation.
`XYFocus` `XYFocus.NavigationModes` `Gamepad` `Remote` Gamepad inputs are supported on devices that can natively send these inputs, such as Android and Tizen. However, Avalonia currently lacks cross-platform Gamepad APIs required for broad out-of-the-box support.
#### Navigation Strategy​
When 2D directional navigation is enabled, a disambiguation strategy is used to select the navigation target.
#### Explicit Navigation​
XYFocus allows each control to specify an explicit navigation target when a direction is pressed via XYFocus.Up, XYFocus.Down, XYFocus.Left, and XYFocus.Right. This has priority over any navigation strategy.
`XYFocus` `XYFocus.Up` `XYFocus.Down` `XYFocus.Left` `XYFocus.Right` Focus engagement is not yet implemented, so combining Directional focus navigation with controls that also handle directional input themselves may have some limitations, especially with visuals.
#### Example​
The following demonstrates how to use Directional focus navigation in a WrapPanel. It explicitly allows navigation to wrap from the first to the last element and vice-versa.
`WrapPanel` The Slider provides an example of mixing navigation with control interaction. On Desktop, pressing the Enter key while the Slider is focused will begin an interaction where the user will modify the Slider.Value instead of causing navigation. Pressing Enter a second time will end the interaction and resume Directional focus navigation.
`Slider` `Slider` `Slider.Value` ```bash
<Window  XYFocus.NavigationModes="Enabled"  XYFocus.UpNavigationStrategy="Projection"  XYFocus.DownNavigationStrategy="Projection"  XYFocus.LeftNavigationStrategy="Projection"  XYFocus.RightNavigationStrategy="Projection">  <Grid>    <WrapPanel>      <Button x:Name="first"        Content="First"        XYFocus.Left="{Binding #last}" />      <Button Content="Second" />      <Button Content="Third" />        <Slider Width="100" Maximum="100" />        <Button Content="Fourth" />      <Button x:Name="last"        Content="Last"        XYFocus.Right="{Binding #first}" />    </WrapPanel>  </Grid></Window>
```
![Directional Navigation Example](https://docs.avaloniaui.net/assets/images/directional-navigation-420ad0add3d83b32bb2415cc4d10f40d.gif)
- IsFocused and Focusable
- Explicit Focusing
- Focus Events
- Focus Pseudoclasses
- FocusManager
- Tab Focus Navigation
- Directional Focus Navigation Navigation StrategyExplicit NavigationExample
- Navigation Strategy
- Explicit Navigation
- Example
- Navigation Strategy
- Explicit Navigation
- Example
# Mouse and Pointer Devices | Avalonia Docs
- Deep Dives
- Input
- Mouse and Pointer Devices
## Mouse and Pointer Devices
In Avalonia UI you implement the interaction of pointing devices with your application using a 'pointer' abstraction. This can represent devices including, but not limited to a mouse, touchpad, and pen. Avalonia UI controls have events that allow you to subscribe to pointer movements, clicks and wheel movements. These are as follows:
- PointerEntered
- PointerExited
- PointerMoved
- PointerPressed
- PointerReleased
- PointerWheelChanged
- Tapped
- DoubleTapped
- Holding
For example, you can subscribe to the event for one of the pointer buttons being pressed on a control, like this:
```bash
private void PointerPressedHandler (object sender, PointerPressedEventArgs args){  var point = args.GetCurrentPoint(sender as Control);  var x = point.Position.X;  var y = point.Position.Y;  var msg = $"Pointer press at {x}, {y} relative to sender.";  if (point.Properties.IsLeftButtonPressed)  {    msg += " Left button pressed.";  }  if (point.Properties.IsRightButtonPressed)  {    msg += " Right button pressed.";  }  results.Text = msg ;}
```
```bash
<StackPanel Margin="20" Background="AliceBlue"         PointerPressed="PointerPressedHandler" > <TextBlock x:Name="results" Margin="5">Ready...</TextBlock></StackPanel>
```
![](https://docs.avaloniaui.net/assets/images/pointer-pressed-8e186992e7255d691861dfb44876db04.gif)
### Pointer Position​
In the example above, the pointer coordinates (x and y) have been calculated relative to the sender control origin (top, left), in this case the stack panel. If you want the coordinates relative to the containing window, then you can use the GetCurrentPoint method as follows:
`x` `y` `GetCurrentPoint` ```bash
var point = args.GetCurrentPoint(this);
```
### Tap Events​
Controls also have special gesture events, these are: Tapped, DoubleTapped and Holding. The tapped event is raised after the pointer is pressed on the control and then released. Double tapped is raised after pointer is pressed twice in the same place.
`Tapped` `DoubleTapped` `Holding` Holding is raised after the pointer is pressed for a set duration. The duration to hold for is defined in the HoldWaitDuration property in TopLevel PlatformSettings. Holding can be enabled on a control by setting the Gestures.IsHoldingEnabled attached property. When the hold duration has elapsed, the control's HoldingEvent is raised with the args' HoldingState set to HoldingState.Started. On pointer release, the event is raised again with HoldingState.Completed state. If a new gesture is initiated or a second pointer is pressed while Holding has started, the Holding gesture is cancelled and a HoldingEvent is raised with the HoldingState.Cancelled state. Holding can also be initiated using the mouse pointer, by setting the Gestures.IsHoldWithMouseEnabled attached property on the control.
`HoldWaitDuration` `TopLevel` `Gestures.IsHoldingEnabled` `HoldingEvent` `HoldingState` `HoldingState.Started` `HoldingState.Completed` `Holding` `Holding` `HoldingEvent` `HoldingState.Cancelled` `Gestures.IsHoldWithMouseEnabled` Note that the maximum distance between a first and second tap, and the time delay between them, will depend on the target platform and usually is bigger for touch devices.
### More Information​
For the complete API documentation about pointer and tap events, see here.
- Pointer Position
- Tap Events
- More Information
# Data Templates | Avalonia Docs
- Get Started
- Coming from WPF?
- Data Templates
## Data Templates
In Avalonia UI, data templates are not stored in the application resources. (The same is true of styles - see here.)
Instead, data templates are placed either inside a DataTemplates collection in a control, or inside the (and on Application):
`DataTemplates` `Application` For example, this code adds a data template to display the view model class FooViewModel:
`FooViewModel` ```bash
<UserControl xmlns:viewmodels="using:MyApp.ViewModels"       x:DataType="viewmodels:ControlViewModel">  <UserControl.DataTemplates>    <DataTemplate DataType="viewmodels:FooViewModel">      <Border Background="Red" CornerRadius="8">        <TextBox Text="{Binding Name}"/>      </Border>    </DataTemplate>  </UserControl.DataTemplates>  <!-- Assuming that ControlViewModel.Foo is an object of type     MyApp.ViewModels.FooViewModel then a red border with a corner     radius of 8 containing a TextBox will be displayed here.     DataType is required only if you use Compiled Bindings, so it can be type-checked. -->  <ContentControl Content="{Binding Foo}"/></UserControl>
```
Data templates in Avalonia can also target interfaces and derived classes (which cannot be done in WPF) and so the order of DataTemplates can be important: DataTemplates within the same collection are evaluated in declaration order so you need to place them from most-specific to least-specific as you would in code.
`DataTemplate` `DataTemplate` ### Data Template Selector​
In WPF you can create a DataTemplateSelector to select or create a DataTemplate based on the provided data. In Avalonia you cannot do this; but you can implement IDataTemplate which can be seen as a good replacement for the DataTemplateSelector. Please find a sample here.
`DataTemplateSelector` `DataTemplate` `IDataTemplate` `DataTemplateSelector` ### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
- Data Template Selector
# HierarchicalDataTemplate | Avalonia Docs
- Get Started
- Coming from WPF?
- HierarchicalDataTemplate
## HierarchicalDataTemplate
WPF's HierarchicalDataTemplate is called TreeDataTemplate in Avalonia (as the former is difficult to type!). The two are almost entirely equivalent other than the naming.
`HierarchicalDataTemplate` `TreeDataTemplate` ### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# UIElement, FrameworkElement and Control | Avalonia Docs
- Get Started
- Coming from WPF?
- UIElement, FrameworkElement and Control
## UIElement, FrameworkElement and Control
WPF's UIElement and FrameworkElement are non-templated control base classes, which roughly equate to the Avalonia Control class. WPF's Control class on the other hand is a templated control - Avalonia's equivalent of this is TemplatedControl.
`UIElement` `FrameworkElement` `Control` `Control` `TemplatedControl` - In WPF/UWP you would inherit from the Control class to create a new templated control, but in Avalonia you should inherit from TemplatedControl.
- In WPF/UWP you would inherit from the FrameworkElement class to create a new custom-drawn control, but in Avalonia you should inherit from Control.
`Control` `TemplatedControl.` `FrameworkElement` `Control.` So to recap:
- UIElement 🠞 Control
- FrameworkElement🠞 Control
- Control 🠞 TemplatedControl
`UIElement` `Control` `FrameworkElement` `Control` `Control` `TemplatedControl` ### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# DependencyProperty | Avalonia Docs
- Get Started
- Coming from WPF?
- DependencyProperty
## DependencyProperty
The Avalonia equivalent of DependencyProperty is StyledProperty, however Avalonia has a richer property system than WPF, and includes DirectProperty for turning standard CLR properties into Avalonia properties. The common base class of StyledProperty and DirectProperty is AvaloniaProperty.
`DependencyProperty` `StyledProperty` `DirectProperty` `StyledProperty` `DirectProperty` `AvaloniaProperty` ### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# Grid | Avalonia Docs
- Get Started
- Coming from WPF?
- Grid
## Grid
Column and row definitions can be specified in Avalonia using strings, avoiding the clunky syntax in WPF:
```bash
<Grid ColumnDefinitions="Auto,*,32" RowDefinitions="*,Auto">
```
A common use of Grid in WPF is to stack two controls on top of each other. For this purpose in Avalonia you can just use a Panel which is more lightweight than Grid.
`Grid` `Panel` `Grid` ### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# Tunnelling Events | Avalonia Docs
- Get Started
- Coming from WPF?
- Tunnelling Events
## Tunnelling Events
Avalonia has tunnelling events but they're not exposed via separate Preview CLR event handlers. To subscribe to a tunnelling event you must call AddHandler with RoutingStrategies.Tunnel:
`Preview` `AddHandler` `RoutingStrategies.Tunnel` ```bash
target.AddHandler(InputElement.KeyDownEvent, OnPreviewKeyDown, RoutingStrategies.Tunnel);void OnPreviewKeyDown(object sender, KeyEventArgs e){  // Handler code}
```
### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# Class Handlers | Avalonia Docs
- Get Started
- Coming from WPF?
- Class Handlers
## Class Handlers
In WPF, class handlers for events can be added by calling EventManager.RegisterClassHandler. An example of registering a class handler in WPF might be:
```bash
static MyControl(){  EventManager.RegisterClassHandler(typeof(MyControl), MyEvent, HandleMyEvent));}private static void HandleMyEvent(object sender, RoutedEventArgs e){}
```
```bash
static MyControl(){  MyEvent.AddClassHandler<MyControl>((x, e) => x.HandleMyEvent(e));}private void HandleMyEvent(RoutedEventArgs e){}
```
Notice that in WPF you have to add the class handler as a static method, whereas in Avalonia the class handler is not static: the notification is automatically directed to the correct instance. The sender parameter typical of event handlers is not necessary in this case and everything remains strongly typed.
`sender` ### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# PropertyChangedCallback | Avalonia Docs
- Get Started
- Coming from WPF?
- PropertyChangedCallback
## PropertyChangedCallback
Listening to changes on DependencyProperties in WPF can be complex. When you register a DependencyProperty you can supply a static PropertyChangedCallback but if you want to listen to changes from elsewhere things can get complicated and error-prone.
`DependencyProperty` `PropertyChangedCallback` In Avalonia, there is no PropertyChangedCallback at the time of registration, instead a class listener is added to the control's static constructor in much the same way that event class listeners are added.
`PropertyChangedCallback` ### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# How To Bind from Code | Avalonia Docs
- How-To Guides
- Data Binding
- How To Bind from Code
## How To Bind from Code
Binding from code in Avalonia works somewhat differently to WPF/UWP. At the low level, Avalonia's binding system is based on Reactive Extensions' IObservable which is then built upon by XAML bindings (which can also be instantiated in code).
`IObservable` ### Subscribing to Changes to a Property​
You can subscribe to changes on a property by calling the GetObservable method. This returns an IObservable<T> which can be used to listen for changes to the property:
`GetObservable` `IObservable<T>` ```bash
var textBlock = new TextBlock();var text = textBlock.GetObservable(TextBlock.TextProperty);
```
Each property that can be subscribed to has a static readonly field called [PropertyName]Property which is passed to GetObservable in order to subscribe to the property's changes.
`[PropertyName]Property` `GetObservable` IObservable (part of Reactive Extensions, or rx for short) is out of scope for this guide, but here's an example which uses the returned observable to print a message with the changing property values to the console:
`IObservable` ```bash
var textBlock = new TextBlock();var text = textBlock.GetObservable(TextBlock.TextProperty);text.Subscribe(value => Console.WriteLine(value + " Changed"));
```
When the returned observable is subscribed, it will return the current value of the property immediately and then push a new value each time the property changes. If you don't want the current value, you can use the rx Skip operator:
`Skip` ```bash
var text = textBlock.GetObservable(TextBlock.TextProperty).Skip(1);
```
### Binding to an observable​
You can bind a property to an observable using the AvaloniaObject.Bind method:
`AvaloniaObject.Bind` ```bash
// We use an Rx Subject here so we can push new values using OnNextvar source = new Subject<string>();var textBlock = new TextBlock();// Bind TextBlock.Text to sourcevar subscription = textBlock.Bind(TextBlock.TextProperty, source);// Set textBlock.Text to "hello"source.OnNext("hello");// Set textBlock.Text to "world!"source.OnNext("world!");// Terminate the bindingsubscription.Dispose();
```
Notice that the Bind method returns an IDisposable which can be used to terminate the binding. If you never call this, then then binding will automatically terminate when the observable finishes via OnCompleted or OnError.
`Bind` `IDisposable` `OnCompleted` `OnError` ### Setting a binding in an object initializer​
It is often useful to set up bindings in object initializers. You can do this using the indexer:
```bash
var source = new Subject<string>();var textBlock = new TextBlock{  Foreground = Brushes.Red,  MaxWidth = 200,  [!TextBlock.TextProperty] = source.ToBinding(),};
```
Using this method you can also easily bind a property on one control to a property on another:
```bash
var textBlock1 = new TextBlock();var textBlock2 = new TextBlock{  Foreground = Brushes.Red,  MaxWidth = 200,  [!TextBlock.TextProperty] = textBlock1[!TextBlock.TextProperty],};
```
Of course the indexer can be used outside object initializers too:
```bash
textBlock2[!TextBlock.TextProperty] = textBlock1[!TextBlock.TextProperty];
```
The only downside of this syntax is that no IDisposable is returned. If you need to manually terminate the binding then you should use the Bind method.
`IDisposable` `Bind` ### Transforming binding values​
Because we're working with observables, we can easily transform the values we're binding!
```bash
var source = new Subject<string>();var textBlock = new TextBlock{  Foreground = Brushes.Red,  MaxWidth = 200,  [!TextBlock.TextProperty] = source.Select(x => "Hello " + x).ToBinding(),};
```
### Using XAML bindings from code​
Sometimes when you want the additional features that XAML bindings provide, it's easier to use XAML bindings from code. For example, using only observables you could bind to a property on DataContext like this:
`DataContext` ```bash
var textBlock = new TextBlock();var viewModelProperty = textBlock.GetObservable(TextBlock.DataContextProperty)  .OfType<MyViewModel>()  .Select(x => x?.Name);textBlock.Bind(TextBlock.TextProperty, viewModelProperty);
```
However, it might be preferable to use a XAML binding in this case:
```bash
var textBlock = new TextBlock{  [!TextBlock.TextProperty] = new Binding("Name")};
```
Or, if you need an IDisposable to terminate the binding:
`IDisposable` ```bash
var textBlock = new TextBlock();var subscription = textBlock.Bind(TextBlock.TextProperty, new Binding("Name"));subscription.Dispose();
```
### Subscribing to a Property on Any Object​
The GetObservable method returns an observable that tracks changes to a property on a single instance. However, if you're writing a control you may want to implement an OnPropertyChanged method which isn't tied to an instance of an object.
`GetObservable` `OnPropertyChanged` To do this you can subscribe to AvaloniaProperty.Changed which is an observable which fires every time the property is changed on any instance.
`AvaloniaProperty.Changed` In WPF this is done by passing a static PropertyChangedCallback to the DependencyProperty registration method, but this only allows the control author to register a property changed callback.
`PropertyChangedCallback` `DependencyProperty` In addition there is an AddClassHandler extension method which can automatically route the event to a method on your control.
`AddClassHandler` For example if you want to listen to changes to your control's Foo property you'd do it like this:
`Foo` ```bash
static MyControl(){  FooProperty.Changed.AddClassHandler<MyControl>(FooChanged);}private static void FooChanged(MyControl sender, AvaloniaPropertyChangedEventArgs e){  // The 'e' parameter describes what's changed.}
```
### Binding to INotifyPropertyChanged objects​
`INotifyPropertyChanged` Binding to objects that implements INotifyPropertyChanged is also available.
`INotifyPropertyChanged` ```bash
var textBlock = new TextBlock();var binding = new Binding {   Source = someObjectImplementingINotifyPropertyChanged,   Path = nameof(someObjectImplementingINotifyPropertyChanged.MyProperty)}; textBlock.Bind(TextBlock.TextProperty, binding);
```
- Subscribing to Changes to a Property
- Binding to an observable
- Setting a binding in an object initializer
- Transforming binding values
- Using XAML bindings from code
- Subscribing to a Property on Any Object
- Binding to INotifyPropertyChanged objects
`INotifyPropertyChanged`
# RenderTransforms and RenderTransformOrigin | Avalonia Docs
- Get Started
- Coming from WPF?
- RenderTransforms and RenderTransformOrigin
## RenderTransforms and RenderTransformOrigin
RenderTransformOrigins are different in WPF and Avalonia: If you apply a RenderTransform, keep in mind that default value for the RenderTransformOrigin in Avalonia is RelativePoint.Center. In WPF the default value is RelativePoint.TopLeft (0, 0). In controls like Viewbox the same code will lead to a different rendering behavior:
`RenderTransform` `RelativePoint.Center` `RelativePoint.TopLeft` In WPF:
![WPF](https://docs.avaloniaui.net/assets/images/rendertransformorigin-wpf-86eb245cb62297e39d9763c9567128cd.png)
In Avalonia:
In AvaloniaUI, to get the same scale transform we should indicate that the RenderTransformOrigin is the TopLeft part of the Visual.
### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# WPF and UWP Comparison | Avalonia Docs
- Get Started
- Coming from WPF?
- WPF and UWP Comparison
## WPF and UWP Comparison
Originally based on UWPvsWPF.md with Avalonia-specific changes.
This document is licensed CC BY-SA 4.0. For the full text of this license see: https://creativecommons.org/licenses/by-sa/4.0/legalcode
This section lists the main differences (primarily from a XAML viewpoint) between Avalonia, UWP and WPF.
Legend:
- ✔ Indicates the platform (defined by the Avalonia, WPF or UWP column) has the feature
- ✖ Indicates the feature is generally missing in the platform
- ⚡ Indicates the feature is only partially implemented compared to other platforms
### Markup Extensions​
### Binding​
`{RelativeSource Self}` `{RelativeSource TemplatedParent}` `{RelativeSource PreviousData}` `{Binding RelativeSource={RelativeSource Mode=PreviousData, AncestorType={x:Type TextBox}}` `{Binding DateValue, StringFormat=Date: {0:dddd yyyy-MM-dd}}` ### Styling​
`BasedOn={StaticResource {x:Type TextBlock}` ### Other​
`<ListBox.ItemsSource><x:Array><s:string>foo<s/:string><x/:Array></ListBox.ItemsSource>` ### Controls​
This section describes the differences in controls in vanilla WPF and UWP (with the WinUI 2.x library). It excludes some primitives and shapes (Ellipse, Rect, etc.)
### Quirks​
- Several UWP controls have reentrancy issues. For example, changing the selected item while in a ComboBox SelectionChanged event is largely not possible and will result in a crash. This makes validation directly in the event handler nearly impossible.
- UWP controls are generally not as powerful as the WPF counterparts. For example, for several years the ComboBox in UWP was not editable. The UWP DatePicker also does not allow typing in a specific date.
- UWP has no support for data (input) validation. This is a large issue for line-of-business apps migrating from WPF to UWP that heavily use this feature in view models or binding.
- The UWP styling system is different enough from WPF to require extra effort during porting. UWP uses the VisualStateManger instead of concepts like DataTriggers or EventTriggers from WPF. Styling/Templating are one of the main differences.
- The ResourceDictionary XAML markup in UWP supports far fewer features than in WPF.
- UWP seems to follow only the XAML/2006 spec instead of XAML/2009 supported by WPF
- Several UWP controls are sealed and new controls cannot derive from them
- For advanced rendering, UWP has fewer features built in. This requires falling back to Win2D or composition more often.
- There are several namespaces differences in UWP and WPF. For example, WPF has System.Windows.Media.Colors while UWP moves this to Windows.UI.Colors.
### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
- Markup Extensions
- Binding
- Styling
- Other
- Controls
- Quirks
# Learn More | Avalonia Docs
- Get Started
- Learn More
## Learn More
This section has introduced you to some of the Avalonia concepts and techniques.
### What Next?​
If you are confident with the material in this section, you could:
- Introduce yourself to data binding here.
- Investigate the MVVM concepts here.
- Explore Avalonia UI styling here.
Your recommended next practical step is to tackle the 'To Do List App' tutorial here.
For a full list of Avalonia tutorials, see here.
- What Next?
# Samples & Tutorials | Avalonia Docs
- Samples & Tutorials
## Samples & Tutorials
This section has practical tutorials that are designed to help you learn Avalonia UI and build your confidence. Here is a brief guide to what you can expect from each of the tutorials:
### To Do List App​
A simple to do list application using the Model View View-Model (MVVM) pattern, with binding to a collection, from which you will meet:
- How to use Bindings
- How to use Commands
- Some basic Styling
- Some very basic I/O operations
This is a very good introduction to the MVVM pattern recommended for Avalonia UI programming. Follow the tutorial here.
### Music Store App​
This app was made for a demonstration on a webinar hosted by JetBrains, and co-hosted by Dan Walmsley, one of the creators of Avalonia UI.
To view the JetBrains and Avalonia UI webinar on YouTube, see here.
It uses the JetBrains Rider IDE running on macOS, but the steps will be equivalent on other platforms; and the developer experience will also be similar on other IDEs such as Visual Studio.
The app features a highly graphical application using the MVVM pattern, and including how to display a dialog, present images and collections of data, and implement data persistence.
Follow this demonstration here.
- To Do List App
- Music Store App
# Breaking Changes | Avalonia Docs
- Stay Up-To-Date
- Breaking Changes
## Breaking Changes
This page will list any breaking changes in Avalonia 11. Although we endeavour not to break our API for major versions, some changes to behavior may result in your application not working.
To see a list of breaking changes between Avalonia 0.10 and 11 see the upgrade guide.
# Stay Up-To-Date | Avalonia Docs
- Stay Up-To-Date
## Stay Up-To-Date
# Upgrading from 0.10 | Avalonia Docs
- Stay Up-To-Date
- Upgrading from 0.10
## Upgrading from 0.10
Avalonia 11 introduces a number of breaking changes from 0.10. The following guide converse the most commonly-encountered changes and gives solutions for them.
### Updating the project​
- Update the Avalonia packages to 11.x
- Themes are no longer included in the Avalonia.Desktop package, so you will need to add a package reference to either Avalonia.Themes.Fluent Avalonia.Themes.Simple
- Avalonia.Themes.Fluent
- Avalonia.Themes.Simple
- Remove the package reference to XamlNameReferenceGenerator - Avalonia now includes this generator by default
- If necessary, update the <LangVersion> to at least 9 in order to be able to use init-only properties
- If you want the same fonts as in 0.10, also include Avalonia.Fonts.Inter package and add .WithInterFont() to the app builder. By default, 11.0 doesn't include any custom fonts.
- Avalonia.Themes.Fluent
- Avalonia.Themes.Simple
`Avalonia.Themes.Fluent` `Avalonia.Themes.Simple` `XamlNameReferenceGenerator` `<LangVersion>` `Avalonia.Fonts.Inter` `.WithInterFont()` ### Theme Handling​
In v0.10, the theme is specified directly inside the Application.Styles tag in the Application.axaml file. An example of this is shown below:
`Application.Styles` `Application.axaml` ```bash
<Application.Styles>  <FluentTheme Mode="Light"/></Application.Styles>
```
In this example, the Mode attribute of the FluentTheme tag is used to specify the theme mode, which can be either "Light" or "Dark".
`Mode` `FluentTheme` Theme management is improved by introducing a new attribute to the Application tag: RequestedThemeVariant. This new attribute is used to set the theme of your application, overriding the system's current theme if specified. If you want to follow the system's current theme, you can set it to "Default". Other available options are "Dark" and "Light".
`Application` `RequestedThemeVariant` An example of how this attribute is used is shown below:
```bash
<Application xmlns="https://github.com/avaloniaui"       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"       x:Class="ILoveAvaloniaUI.App"       xmlns:local="using:ILoveAvaloniaUI"       RequestedThemeVariant="Default">
```
The FluentTheme tag no longer requires the Mode attribute and can be left empty.
`FluentTheme` `Mode` ```bash
<Application.Styles>  <FluentTheme /></Application.Styles>
```
#### Theme Dictionary and Theme Variant​
The method, Styles.TryGetResource method now requires a nullable ThemeVariant parameter as per PR #8166. This allows users to specify Light, Dark, and Default
`Styles.TryGetResource` `ThemeVariant` `Light` `Dark` `Default` Using ThemeVariant.Default as the key marks a specific theme dictionary as a fallback in case the theme variant or resource key is not found in other theme dictionaries.
`ThemeVariant.Default` In addition to the built-in values of Light, Dark, and Default, any object value can be used as a key (since it's wrapped in the ThemeVariant(object key) structure). {x:Static} markup extension can also be used here if a developer wants to define multiple custom themes as static properties and reference them from the XAML code.
`Light` `Dark` `Default` `ThemeVariant(object key)` `{x:Static}` ```bash
// Beforebool TryGetResource(object key, out object? value)// Avalonia v11bool TryGetResource(object key, ThemeVariant? theme, out object? value)
```
### System.Reactive/Observables​
Avalonia no longer has a dependency on System.Reactive. If you're using reactive features, add a package reference to System.Reactive to your project.
`System.Reactive` `System.Reactive` If you don't need the whole of System.Reactive but just want to make a simple subscription to an IObservable<T> you can use the utility class AnonymousObserver<T> provided by Avalonia, for example:
`System.Reactive` `IObservable<T>` `AnonymousObserver<T>` ```bash
observable.Subscribe(new AnonymousObserver<string>(() => { /* Code to execute when the observable changes. */ }));
```
If you need to subscribe on property or event changes, you can AddClassHandler instead of observables.
`AddClassHandler` See #9749, #10105 for more information.
### Updating Interfaces​
Many interfaces have been removed in Avalonia 11. You should be able to do a global find/replace to replace each of the follow interfaces with its concrete type:
- IAvaloniaObject -> AvaloniaObject
- IBitmap -> Bitmap
- IContentPresenter -> ContentPresenter
- IControl -> Control
- IInteractive -> Interactive
- IItemsPresenter -> ItemsPresenter
- ILayoutable -> Layoutable
- IPanel -> Panel
- IStyledElement -> StyledElement
- ITemplatedControl -> TemplatedControl
- IVisual -> Visual
`IAvaloniaObject` `AvaloniaObject` `IBitmap` `Bitmap` `IContentPresenter` `ContentPresenter` `IControl` `Control` `IInteractive` `Interactive` `IItemsPresenter` `ItemsPresenter` `ILayoutable` `Layoutable` `IPanel` `Panel` `IStyledElement` `StyledElement` `ITemplatedControl` `TemplatedControl` `IVisual` `Visual` If you have your own interfaces that derive from one of these interfaces you'll need to remove the interface base, and do a cast to the concrete class at the point of usage.
See #9553, #11495 for more information.
#### Optional, but recommended:​
The IStyleable interface is now deprecated. In Avalonia 0.10.x, to override a control's style key you implemented IStyleable and added an explicit interface implementation for StyleKey:
`IStyleable` `IStyleable` `StyleKey` ```bash
class MyButton : Button, IStyleable{  Type IStyleable.StyleKey => typeof(Button);}
```
In Avalonia 11, the IStyleable reference will give a deprecated warning. The following should be used instead:
`IStyleable` ```bash
class MyButton : Button{  protected override Type StyleKeyOverride => typeof(Button);}
```
See #11380 for more information.
### Views​
Views that are in the form of a .axaml/.axaml.cs (or .xaml/.xaml.cs) pair now have auto-generated C# code. To facilitate this:
`.axaml` `.axaml.cs` `.xaml` `.xaml.cs` - Make the class in the .cs file partial
- Remove the private void InitializeComponent() method
- Do NOT remove the call to InitializeComponent() in the constructor: this method is now a generated method and still needs to be called
- Remove the this.AttachDevTools() call from the constructor - InitializeComponent now has a parameter which controls whether DevTools is attached in debug mode whose default is true
`partial` `private void InitializeComponent()` `InitializeComponent()` `this.AttachDevTools()` `InitializeComponent` `true` Previously, to find a named control declared in the XAML file, a call to this.FindControl<T>(string name) or this.GetControl<T>(string name) was needed. This is now unnecessary - controls in the XAML file with a Name or x:Name attribute will automatically cause a field to be generated in the class to access the named control (as in WPF/UWP etc).
`this.FindControl<T>(string name)` `this.GetControl<T>(string name)` `Name` `x:Name` Note, this source generator is available for C# only. For F# nothing was changed.
### ItemsControl​
ItemsControl and derived classes such as ListBox and ComboBox now have both an Items property and an ItemsSource as in WPF/UWP.
`ItemsControl` `ListBox` `ComboBox` `Items` `ItemsSource` Items is a readonly collection property that is pre-populated, and ItemsSource is the read/write version that has a default value of null.
`Items` `ItemsSource` Replace any bindings to Items with a binding to ItemsSource:
`Items` `ItemsSource` ```bash
<ListBox Items="{Binding Items}">
```
Becomes
```bash
<ListBox ItemsSource="{Binding Items}">
```
In addition:
- ListBox.VirtualizationMode has been removed, the virtualization mode is changed by changing the ItemsPanel: To disable virtualization use a StackPanel. To enable virtualization use a VirtualizingStackPanel.
- To disable virtualization use a StackPanel.
- To enable virtualization use a VirtualizingStackPanel.
- Carousel.IsVirtualizing has been removed, there is now only a "virtualizing" mode for Carousel
- Item container lookup was moved to ItemsControl as in UWP (old methods are left on ItemContainerGenerator marked with [Obsolete]): ItemsControl.ContainerFromIndex(object item) ItemsControl.IndexFromContainer(Control container)
- ItemsControl.ContainerFromIndex(object item)
- ItemsControl.IndexFromContainer(Control container)
- The Items and ItemTemplate properties on ItemsPresenter have been removed. The template bindings to these properties in control templates can simply be removed
`ListBox.VirtualizationMode` `ItemsPanel` - To disable virtualization use a StackPanel.
- To enable virtualization use a VirtualizingStackPanel.
`StackPanel` `VirtualizingStackPanel` `Carousel.IsVirtualizing` `Carousel` `ItemsControl` - ItemsControl.ContainerFromIndex(object item)
- ItemsControl.IndexFromContainer(Control container)
`ItemsControl.ContainerFromIndex(object item)` `ItemsControl.IndexFromContainer(Control container)` `Items` `ItemTemplate` `ItemsPresenter` See #10590, #10827 for more information.
### Classes​
StyledElement.Classes is now a readonly property. When used in an object initializer, code which did the following:
`StyledElement.Classes` ```bash
var c = new Control{  Classes = new Classes("foo", "bar"),};
```
Should be changed to:
```bash
var c = new Control{  Classes = { "foo", "bar" },};
```
To manipulate a Classes collection outside of an object initializer use the standard IList<string> methods.
`Classes` `IList<string>` See #11013 for more information.
### Windows​
The TopLEvel.PlatformImpl API is no longer available for controls such as Window. The relevant methods have been moved to TopLevel, WindowBase or Window itself:
`TopLEvel.PlatformImpl` `Window` `TopLevel` `WindowBase` `Window` - window.PlatformImpl.Handle becomes window.TryGetPlatformHandle()
- window.PlatformImpl.BeginMove(e) becomes window.BeginMove()
- window.PlatformImpl.Resized becomes window.Resized
`window.PlatformImpl.Handle` `window.TryGetPlatformHandle()` `window.PlatformImpl.BeginMove(e)` `window.BeginMove()` `window.PlatformImpl.Resized` `window.Resized` ### AssetLoader​
The IAssetLoader interface is no longer available. Use the static AssetLoader class:
`IAssetLoader` `AssetLoader` ```bash
var assets = AvaloniaLocator.Current.GetService<IAssetLoader>();var bitmap = new Bitmap(assets.Open(new Uri(uri)));
```
Becomes:
```bash
var bitmap = new Bitmap(AssetLoader.Open(new Uri(uri)));
```
### OnPropertyChanged​
The virtual AvaloniaObject.OnPropertyChanged method is now non-generic. Replace
`AvaloniaObject.OnPropertyChanged` ```bash
protected override void OnPropertyChanged<T>(AvaloniaPropertyChangedEventArgs<T> change)
```
with
```bash
protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
```
Also the technique for getting the old and new values from AvaloniaPropertyChangedEventArgs without boxing has changed:
`AvaloniaPropertyChangedEventArgs` - Replace change.NewValue.GetValueOrDefault<T>() with change.GetNewValue<bool>()
- Replace change.OldValue.GetValueOrDefault<T>() with change.GetOldValue<bool>()
- You can also use change.GetOldAndNewValue<T>() to get both
`change.NewValue.GetValueOrDefault<T>()` `change.GetNewValue<bool>()` `change.OldValue.GetValueOrDefault<T>()` `change.GetOldValue<bool>()` `change.GetOldAndNewValue<T>()` See #7980 for more information.
### Events​
The following events have been renamed:
- PointerEnter -> PointerEntered
- PointerLeave -> PointerExited
- ContextMenu ContextMenuClosing -> Closing ContextMenuOpening -> Opening
- ContextMenuClosing -> Closing
- ContextMenuOpening -> Opening
- MenuBase MenuClosed -> Closed MenuOpened -> Opened
- MenuClosed -> Closed
- MenuOpened -> Opened
`PointerEnter` `PointerEntered` `PointerLeave` `PointerExited` `ContextMenu` - ContextMenuClosing -> Closing
- ContextMenuOpening -> Opening
`ContextMenuClosing` `Closing` `ContextMenuOpening` `Opening` `MenuBase` - MenuClosed -> Closed
- MenuOpened -> Opened
`MenuClosed` `Closed` `MenuOpened` `Opened` RoutedEventArgs.Source has changed from type IInteractive to type object: cast to a concrete type such as Control to use it.
`RoutedEventArgs.Source` `IInteractive` `object` `Control` ### Layout​
Previously a full layout pass was achieved by getting the layout root and calling a method on the layout manager:
```bash
((ILayoutRoot)control).LayoutManager.ExecuteLayout();
```
The LayoutManager is no longer exposed from the ILayoutRoot, instead call the UpdateLayout method on any control as in WPF/UWP:
`LayoutManager` `ILayoutRoot` `UpdateLayout` ```bash
control.UpdateLayout();
```
ILayoutable was used in 0.10.x to get the previous measure constraints and arrange bounds. Because ILayoutable is no longer available, these are now exposed from LayoutInformation:
`ILayoutable` `ILayoutable` `LayoutInformation` - Size? LayoutInformation.GetPreviousMeasureConstraint(Layoutable control)
- Rect? LayoutInformation.GetPreviousArrangeBounds(Layoutable control)
`Size? LayoutInformation.GetPreviousMeasureConstraint(Layoutable control)` `Rect? LayoutInformation.GetPreviousArrangeBounds(Layoutable control)` ### Focus​
The focus manager is no longer available via FocusManager.Instance and has instead been moved to the TopLevel:
`FocusManager.Instance` `TopLevel` ```bash
var focusManager = FocusManager.Instance;
```
Becomes:
```bash
var focusManager = TopLevel.GetTopLevel(control).FocusManager;
```
In addition, the IFocusManager API has been changed.
`IFocusManager` - To get the currently focused element, use IFocusManager.GetFocusedElement()
- To focus a control use control.Focus()
`IFocusManager.GetFocusedElement()` `control.Focus()` There is currently no event for listening to focus changes on IFocusManager. To listen for focus changes, add a listener to the InputElement.GotFocusEvent:
`IFocusManager` `InputElement.GotFocusEvent` ```bash
InputElement.GotFocusEvent.AddClassHandler<InputElement>((element, args) => { });
```
The same applied to KeyboardDevice, which isn't accessible anymore. Use the same focus related APIs as a replacement.
See #11407 for more information.
### Visual Tree​
IVisual was used in 0.10.x to expose the visual parent and visual children of a control. Because IVisual is no longer available, these are now exposed as extension methods in the Avalonia.VisualTree namespace:
`IVisual` `IVisual` `Avalonia.VisualTree` ```bash
using Avalonia.VisualTree;var visualParent = control.GetVisualParent();var visualChildren = control.GetVisualChildren();
```
### Rendering​
The Render method on certain controls is now sealed. This is because it is planned to make these controls use composition primitives instead of rendering via DrawingContext.
`Render` `DrawingContext` If you have a control whose Render method was being overloaded but it's now sealed, consider using a base class, for example instead of Border use Decorator. Note that you will now be responsible for drawing the background/border.
`Render` `Border` `Decorator` See #10299 for more information.
### Locator​
The AvaloniaLocator is no longer available. Most services that were available via the locator now have alternative methods of access:
`AvaloniaLocator` - AssetLoader is a static class now with all of the old methods.
- IPlatformSettings was moved to TopLevel.PlatformSettings and Application.PlatformSettings. Note, it's always preferred to use settings of the specific top level (window) rather than global ones.
- IClipboard was moved to the TopLevel.Clipboard. Note, that Application.Clipboard was removed as well.
- PlatformHotkeyConfiguration was moved to the PlatformSettings.HotkeyConfiguration.
`AssetLoader` `IPlatformSettings` `TopLevel.PlatformSettings` `Application.PlatformSettings` `IClipboard` `TopLevel.Clipboard` `Application.Clipboard` `PlatformHotkeyConfiguration` `PlatformSettings.HotkeyConfiguration` Some applications were using the AvaloniaLocator as a general-purpose service locator. This was never an intended usage of AvaloniaLocator and those application should move to a service locator or DI container designed for the purpose, e.g. Splat or Microsoft.Extensions.DependencyInjection.
`AvaloniaLocator` `AvaloniaLocator` `Splat` `Microsoft.Extensions.DependencyInjection` ### Miscellaneous/Advanced Scenarios​
- IRenderer/DeferredRenderer/ImmediateRenderer have now been removed. For performance reasons it is no longer possible to supply your own renderer, everything uses the new composition renderer.
- Renderer.Diagnostics is now RendererDiagnostics
- ICustomDrawOperation.Render now takes an ImmediateDrawingContext instead of a DrawingContext
- Add .GetTask() to the end of calls to Dispatcher.UIThread.InvokeAsync if directly returning the value in a method which returns a Task
- IRenderRoot.RenderScaling has been moved to TopLevel.RenderScaling
- LightweightObservableBase and SingleSubscriberObservableBase have been made internal. These were utility classes designed for a specific purpose in Avalonia and were not intended to be used by clients as they do not handle certain edge cases. Use the mechanisms provided by System.Reactive to create observables, such as Observable.Create
- When binding to methods, the method must either have no parameters or a single object parameter.
- OpenFileDialog and SaveFileDialog have been removed. For file system storage service use IStorageProvider on the Top Level.
`IRenderer` `DeferredRenderer` `ImmediateRenderer` `Renderer.Diagnostics` `RendererDiagnostics` `ICustomDrawOperation.Render` `ImmediateDrawingContext` `DrawingContext` `.GetTask()` `Dispatcher.UIThread.InvokeAsync` `Task` `IRenderRoot.RenderScaling` `TopLevel.RenderScaling` `LightweightObservableBase` `SingleSubscriberObservableBase` `System.Reactive` `Observable.Create` `OpenFileDialog` `SaveFileDialog` `IStorageProvider` - Updating the project
- Theme HandlingTheme Dictionary and Theme Variant
- Theme Dictionary and Theme Variant
- System.Reactive/Observables
- Updating InterfacesOptional, but recommended:
- Optional, but recommended:
- Views
- ItemsControl
- Classes
- Windows
- AssetLoader
- OnPropertyChanged
- Events
- Layout
- Focus
- Visual Tree
- Rendering
- Locator
- Miscellaneous/Advanced Scenarios
- Theme Dictionary and Theme Variant
- Optional, but recommended:
# What's new | Avalonia Docs
- Stay Up-To-Date
- What's new
## What's new
The Avalonia team has been working hard on this release and we're excited to share with you all the new features and improvements. Let's dive in!
### New Features​
#### A11y (Accessibility)​
This version of Avalonia takes major strides in making applications more accessible. We've added support for various accessibility tools, making it easier for everyone to use Avalonia applications.
#### IME (Input Method Editor) Support​
We have introduced support for Input Method Editor (IME), facilitating users to input characters and symbols not found on their input devices.
#### Composition Renderer​
The new composition renderer enhances the graphical rendering capabilities, providing a more robust, efficient, and flexible rendering pipeline.
#### WebAssembly (WASM) Support​
WASM support allows Avalonia applications to run directly in the browser, broadening our platform support and giving developers more freedom and flexibility.
#### iOS and Android Support​
We've added support for both iOS and Android platforms. Developers can now build and run Avalonia applications on two of the most popular mobile platforms.
#### Text Inlines​
With the Text Inlines feature, you can easily construct complex formatted text blocks. It enables you to add annotations, hyperlinks, and other inline elements in your text.
#### Smooth Virtualization (Reworked ItemsControl)​
We've completely reworked the ItemsControl to provide smooth virtualization. This improves the efficiency and user experience for controls with many items.
#### Performance Improvements​
Avalonia 11.0 comes with significant performance improvements, enhancing the speed and efficiency of your applications.
#### Control Themes, Nested Styles, and Theme Variants​
We've added the ability to theme controls, apply nested styles, and choose theme variants. This makes it easier to build beautiful and consistent UIs.
#### Bitmap Effects​
The Bitmap Effects feature lets you apply visual effects to bitmaps. You can add blur, drop shadows, and other effects to images.
#### 3D Transforms​
With 3D Transforms, you can now create stunning three-dimensional effects in your UI.
#### AOT (Ahead-Of-Time) Compilation and Trimming​
AOT compilation enables your apps to run faster by compiling them before runtime. Trimming reduces the size of your apps by removing unused code.
#### GPU Interop​
The GPU Interop feature allows Avalonia to work more efficiently with the GPU, improving rendering performance and visuals.
#### Experimental Metal Support​
We're testing Metal support to improve performance on iOS and macOS devices.
### Important Notes​
This version also includes many bug fixes and improvements based on community feedback. As always, your feedback and contributions help us make Avalonia better. Please report any issues or suggestions on GitHub.
- New FeaturesA11y (Accessibility)IME (Input Method Editor) SupportComposition RendererWebAssembly (WASM) SupportiOS and Android SupportText InlinesSmooth Virtualization (Reworked ItemsControl)Performance ImprovementsControl Themes, Nested Styles, and Theme VariantsBitmap Effects3D TransformsAOT (Ahead-Of-Time) Compilation and TrimmingGPU InteropExperimental Metal Support
- A11y (Accessibility)
- IME (Input Method Editor) Support
- Composition Renderer
- WebAssembly (WASM) Support
- iOS and Android Support
- Text Inlines
- Smooth Virtualization (Reworked ItemsControl)
- Performance Improvements
- Control Themes, Nested Styles, and Theme Variants
- Bitmap Effects
- 3D Transforms
- AOT (Ahead-Of-Time) Compilation and Trimming
- GPU Interop
- Experimental Metal Support
- Important Notes
- A11y (Accessibility)
- IME (Input Method Editor) Support
- Composition Renderer
- WebAssembly (WASM) Support
- iOS and Android Support
- Text Inlines
- Smooth Virtualization (Reworked ItemsControl)
- Performance Improvements
- Control Themes, Nested Styles, and Theme Variants
- Bitmap Effects
- 3D Transforms
- AOT (Ahead-Of-Time) Compilation and Trimming
- GPU Interop
- Experimental Metal Support
# Release Notes | Avalonia Docs
- Stay Up-To-Date
- Release Notes
## Release Notes
You can find release notes for all version on https://github.com/AvaloniaUI/Avalonia/releases
### 11.0.7​
https://www.nuget.org/packages/Avalonia/11.0.7
Full Changelog: 11.0.6...11.0.7
#### What's Changed​
- Fixed issue: Default font family name cannot be null or empty by @mihnea-radulescu in https://github.com/AvaloniaUI/Avalonia/pull/12817
- Fixed missing resources for TimePicker & DatePicker in simple theme by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/12851
- Fixed memory leak in Animatable transitions by @DmitryZhelnin in https://github.com/AvaloniaUI/Avalonia/pull/12861
- Fixed issue with VirtualizingPanel's RemoveInternalChildRange() by @liwuqingxin in https://github.com/AvaloniaUI/Avalonia/pull/12877
- Fixed Xaml Compiler error when code-behind class contains a DllImport method by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/12882
- Fixed memory leak in TopLevel's Cursor property subscriptions by @DmitryZhelnin in https://github.com/AvaloniaUI/Avalonia/pull/12996
- Added Clear function to Date and Time pickers by @rabbitism in https://github.com/AvaloniaUI/Avalonia/pull/13082
- Fixed typo in ItemsControlFromItemContainer by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/13118
- Updated RenderDataRectangleNode.HitTest for proper hit-testing of rounded rectangles by @billhenn in https://github.com/AvaloniaUI/Avalonia/pull/13797
- Fixed initialization property order in SelectedItemsControl by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13800
- Implemented helper OutputApiDiff target by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13818
- Unsubscribed Android back handler when toplevel is disposed by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/13831
- Fixed DataGrid IList editing issue by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13845
- Fixed TextLine run bounds union calculation by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13847
- Fixed TabItem.TabStripPlacement not being set for new tab items by @pavelovcharov in https://github.com/AvaloniaUI/Avalonia/pull/13849
- Hackfix for calling SelectAll with SelectedItem binding by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13868
- Fix OutOfMemory crash with LowLatencyDxgiSwapChain enabled by @ShadowMarker789 https://github.com/AvaloniaUI/Avalonia/pull/13869
- Added transition leak tests by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13870
- Fixed ToggleSwitch dragging by @Splitwirez in https://github.com/AvaloniaUI/Avalonia/pull/13893
- Fixed Adorner Layer Clipping by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13921
- Fixed BoxShadow style changes not triggering render updates on ContentPresenter by @Al12rs in https://github.com/AvaloniaUI/Avalonia/pull/13932
- Added feature to allow treating Avalonia Access Unstable Private APIs Warning as Error by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/13937
- OpenglControl - Don't queue update if control is not attached by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/13938
- Fixed iOS Dispatcher by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13942
- Used ShowNoActivate in Win32NativeControlHost by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13966
- Don't override ContextMenu.Placement when Open is called from code by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13967
- Don't share style instances with Or selector by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13969
- Fixed IOSStorageFolder permission problem by @sghctoma in https://github.com/AvaloniaUI/Avalonia/pull/13976
- Fixed Border and Shape border re-rendering when changing Brush value by @SKProCH in https://github.com/AvaloniaUI/Avalonia/pull/13980
- Fixed DBus Exception on window close by @affederaffe in https://github.com/AvaloniaUI/Avalonia/pull/13997
- Updated Tmds.DBus.SourceGenerator to 0.0.13 by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/14010
- Fixed Relative line drawing in Geometries by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/14013
- Removed missing MVID warning on XAML compilation by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/14014
- Fixed color of selected DataGridRow by @zavaleriy in https://github.com/AvaloniaUI/Avalonia/pull/14026
- Fixed regression in rendering of non-clear type text by @danwalmsley in https://github.com/AvaloniaUI/Avalonia/pull/14080
- Don't crash on IsCurrent checks by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/14089
- Implemented ApiInformation checks by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/14090
- Fixed XML Docs: Renamed inheritdocs to inheritdoc by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/14093
- Added an event to detect when an Application icon is clicked by @danwalmsley in https://github.com/AvaloniaUI/Avalonia/pull/14106
- Improved TextBox behavior on Ctrl+Backspace down event by @exGensImpl in https://github.com/AvaloniaUI/Avalonia/pull/14138
- Added InheritDataTypeFromItems for AutoCompleteBox.ValueMemberBinding by @gehongyan in https://github.com/AvaloniaUI/Avalonia/pull/14162
- Fixed exception when SelectedValueBinding evaluates to null by @TomEdwardsEnscape in https://github.com/AvaloniaUI/Avalonia/pull/14171
- Updated SkiaSharp to 2.88.7 to fix a memory exception by @MontagueM in https://github.com/AvaloniaUI/Avalonia/pull/14179
- Ported DragMove logic from WPF by @jmacato in https://github.com/AvaloniaUI/Avalonia/pull/14186
### 11.0.6​
https://www.nuget.org/packages/Avalonia/11.0.6
Full Changelog: https://github.com/AvaloniaUI/Avalonia/compare/11.0.5...11.0.6
Join Discussion: https://github.com/AvaloniaUI/Avalonia/discussions/13841
#### What's Changed​
- Fix: RangeBase should not write coerced values back when DataContext is changing by @timunie in https://github.com/AvaloniaUI/Avalonia/pull/11918
- Fix TabItem memory leak by @DmitryZhelnin in https://github.com/AvaloniaUI/Avalonia/pull/12418
- Key handling improvements by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12549
- Use Tmds.DBus.SourceGenerator 0.0.10 by @affederaffe in https://github.com/AvaloniaUI/Avalonia/pull/12730
- Use the focus proxy window in X11 by @vlad-lubenskyi in https://github.com/AvaloniaUI/Avalonia/pull/12751
- Finding ancestor IScrollAnchorProvider instead ScrollViewer. by @Meloman19 in https://github.com/AvaloniaUI/Avalonia/pull/13079
- Fix ManagedFileChooser FileName issue by @rabbitism in https://github.com/AvaloniaUI/Avalonia/pull/13096
- Introduce DrawingContextHelper.RenderAsync method by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13128
- Ambiguous error message when you load App.axaml by @prashantvc in https://github.com/AvaloniaUI/Avalonia/pull/13129
- Fix text hit testing for invisible runs by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13135
- Obsolete CubicBezierEasing by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13137
- #13123 Fix ButtonSpinnerLocation in SimpleTheme by @stogle in https://github.com/AvaloniaUI/Avalonia/pull/13142
- [Text] Fix hit testing issues by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13155
- Remove viewport estimation from VirtualizingStackPanel by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13169
- Fix viewport calculation with non-invertible render transform by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13188
- Rethrow layout exceptions by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13189
- Fix text wrapping for chinese etc. by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13193
- fix(ImmutableSolidColorBrush): Missing assingment of ctor transform argument by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/13194
- Fix macOS clipboard formats mapping by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13197
- Implement Next action in android IME by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/13222
- feat(Gestures): Allow using some Gestures events in Xaml by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/13232
- Introduce TextBlock.LineSpacing by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13243
- Fix OpenGlControlBase: Ensure _updateQueued is set to false when DoCleanup() is called by @laolarou726 in https://github.com/AvaloniaUI/Avalonia/pull/13260
- Add option to enable/disable input focus proxy for X11. by @jmacato in https://github.com/AvaloniaUI/Avalonia/pull/13273
- Add TextBox.ScrollToLine by @mgnslndh in https://github.com/AvaloniaUI/Avalonia/pull/13274
- X11 IME preedit, preedit cursor, input context improvements by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/13282
- Fix TextLayout.OverhandLeading calculation by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13287
- Fix watermark alignment of TextBox in the Simple theme #5802 by @mgnslndh in https://github.com/AvaloniaUI/Avalonia/pull/13295
- iBus support fixes by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/13297
- Fix Sector Fill by @robloo in https://github.com/AvaloniaUI/Avalonia/pull/13304
- Make Avalonia.Browser work on .NET 8 by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13312
- Implement IList on DataGridCollectionView. by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13313
- Prevent gesture recognition when gesture is captured by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/13323
- Exclude access key markers from native menu titles on macOS. by @Steveice10 in https://github.com/AvaloniaUI/Avalonia/pull/13338
- Add tooltip support to NativeMenuItem. by @Steveice10 in https://github.com/AvaloniaUI/Avalonia/pull/13350
- Update HarfBuzzSharp by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13357
- fix(CaptionButton): theme used hardcoded Background, Foreground and BorderBrush color by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/13373
- Fix ShapedTextRun Split by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13385
- Fix some issues with focus scopes by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13409
- Dispose CecilTypeSystem in XAML compiler task by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/13429
- Tooltip inherits theme from control by @HermanKirshin in https://github.com/AvaloniaUI/Avalonia/pull/13454
- Fix TimePicker empty designator on 12 hour clock by @maprosen in https://github.com/AvaloniaUI/Avalonia/pull/13469
- Fix DateTimePicker scroll down by @maprosen in https://github.com/AvaloniaUI/Avalonia/pull/13482
- Fix dragging a slider with a tooltip by @TomEdwardsEnscape in https://github.com/AvaloniaUI/Avalonia/pull/13489
- Fixed passing current_folder to DBus for save file dialog by @HermanKirshin in https://github.com/AvaloniaUI/Avalonia/pull/13491
- Fix issue #11006 by correcting SelectionChanged event to be fired AFTER (not before) raising Prop. by @lnxon in https://github.com/AvaloniaUI/Avalonia/pull/13503
- Fix ImageBrush crash when source bitmap gets disposed by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/13506
- fix: Navigation when CanExecute is false by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/13507
- DataGrid inertial scroll support (#13502) by @stogle in https://github.com/AvaloniaUI/Avalonia/pull/13511
- Fix for issue #13493 by @laolarou726 in https://github.com/AvaloniaUI/Avalonia/pull/13518
- fix: Potential TransformGroup memory leak by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/13529
- Avoid Adreno DXGI adapter on Win-ARM devices by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13538
- Don't hide tooltip when pointer is over it. by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13565
- Fix: Allow ColorPicker-Fylout to swap position if needed by @timunie in https://github.com/AvaloniaUI/Avalonia/pull/13567
- Update scaling when Position is set directly on x11 by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/13590
- current_folder added to DBus open file / folder picker by @HermanKirshin in https://github.com/AvaloniaUI/Avalonia/pull/13596
- Win32 file picker fixes by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13625
- fix:Previewer connection fails from VSCode by @prashantvc in https://github.com/AvaloniaUI/Avalonia/pull/13630
- Properly handle overhang with RTL FlowDirection by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13631
- Deferred scrolling by @TomEdwardsEnscape in https://github.com/AvaloniaUI/Avalonia/pull/13644
- [WIP]Fix overhang leading calculation for negative values by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/13672
- Fix blocking shutdown app with LibInput by @Seeung in https://github.com/AvaloniaUI/Avalonia/pull/13677
- Data grid handled events by @ltetak in https://github.com/AvaloniaUI/Avalonia/pull/13680
- Fix WasmExtraFilesToDeploy on non-Windows .NET 8 by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13698
- Fix Design.IsDesignMode being false in BuildAvaloniaApp method by @Takoooooo in https://github.com/AvaloniaUI/Avalonia/pull/13699
- Update Xamarin.AndroidX by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13708
- Ignore mouse move when left window by @ltetak in https://github.com/AvaloniaUI/Avalonia/pull/13724
- Allow users to change menu show delay by @WillisXue in https://github.com/AvaloniaUI/Avalonia/pull/13752
- Fix overlapping items in VirtualizingStackPanel by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13765
- Fix nth-child styles on virtualized lists by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13770
- Fix Animation.FillMode when cue isn't 0% or 100% by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13775
- fix: Expander header icon flip when collapsing or expanding canceled by @memorydream in https://github.com/AvaloniaUI/Avalonia/pull/13780
- release Context by @Coloryr in https://github.com/AvaloniaUI/Avalonia/pull/13788
- Fix Some Virtualizing List Update Bugs by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13795
- Added default excludes for AvaloniaXaml by @jp2masa in https://github.com/AvaloniaUI/Avalonia/pull/13809
- Update Avalonia.Browser.props by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13820
- Fix some issues with tabbing into virtualized list by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13826
`Gestures` `VirtualizingStackPanel` `nth-child` ### 11.0.5​
https://www.nuget.org/packages/Avalonia/11.0.5
#### What's Changed​
- feat: Also allows using string instead of x:Type in ControlTemplate.TargetType by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/11575
- feat: Handle ClrPropertyInfo in StaticResourceExtension by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/12047
- fix DropDownButton glyph foreground color by @almightyju in https://github.com/AvaloniaUI/Avalonia/pull/12048
- Fix NotificationCard to determine the type of notification from an inherited INotification object by @Onebeld in https://github.com/AvaloniaUI/Avalonia/pull/12103
- Improve AutoCompleteBox performance by @timunie in https://github.com/AvaloniaUI/Avalonia/pull/12338
- Fix issue #12453, TextBox does not scroll at the end of line when entering CJK characters via IME by @lnxon in https://github.com/AvaloniaUI/Avalonia/pull/12454
- fix: AvaloniaVS can not resolve resource relative path in Previewer by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/12473
- ToggleSwitch: fix toggle on single touch tap on the knob part by @msneijders in https://github.com/AvaloniaUI/Avalonia/pull/12520
- When calculating geometry bounds take into account parameters that affect geometry bounds by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/12606
- Allow setting a LineHeight that is smaller than the default by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12613
- Fix TextTrimming in combination with TextWrapping by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12614
- Fix for TextBlock.TextDecorations not inheriting down to inlines. by @billhenn in https://github.com/AvaloniaUI/Avalonia/pull/12624
- Fix changing ItemsControl.ItemContainerTheme by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/12630
- Update Rotate3DTransition.cs to fix flickering on backwards navigation by @yankun in https://github.com/AvaloniaUI/Avalonia/pull/12631
- Fix for AccessText underlines being very blurry by @billhenn in https://github.com/AvaloniaUI/Avalonia/pull/12634
- Revert Inline breaking change by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12638
- csproj cleanup by @SimonCropp in https://github.com/AvaloniaUI/Avalonia/pull/12657
- Call CaptureLost on gestures when pointer loses capture by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/12666
- Fix Inlines TextTrimming with embedded controls by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12695
- Fix OnOpenGlInit getting called twice by @wannkunstbeikor in https://github.com/AvaloniaUI/Avalonia/pull/12713
- Updated Transition to use direct properties via use of new TransitionBase class by @billhenn in https://github.com/AvaloniaUI/Avalonia/pull/12716
- Fix popups in Windows being offset incorrectly by a workaround for another issue by @billhenn in https://github.com/AvaloniaUI/Avalonia/pull/12725
- Fix the scrollbar attaching to wrong scrollviewer, like scrollviewer . by @liwuqingxin in https://github.com/AvaloniaUI/Avalonia/pull/12732
- Introduce DrawingContext Push/PopRenderOptions by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12734
- Added Avalonia.ForTestingOnly to InternalsVisibleTo list by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/12750
- Fix property analyzer exception with object initializers in cctors by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12754
- Fix previewer security issue by @Takoooooo in https://github.com/AvaloniaUI/Avalonia/pull/12757
- Ensure GlyphRunImpl has consistent bounds by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12765
- [Mac] Fixes raw keyDown/textInput handling by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12774
- Fix interpolator being called after last animation iteration by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12781
- fix: DataGrid scroll should behave the same as ScrollViewer by @timunie in https://github.com/AvaloniaUI/Avalonia/pull/12787
- Restore PathIcon Foreground setter in Fluent theme by @wieslawsoltes in https://github.com/AvaloniaUI/Avalonia/pull/12789
- creating only one gtk thread by @HermanKirshin in https://github.com/AvaloniaUI/Avalonia/pull/12830
- fixed restarting renderer when window is minimized and restored progr. by @HermanKirshin in https://github.com/AvaloniaUI/Avalonia/pull/12832
- Fixed blinking caret in case TextPresenter detached and attached again by @HermanKirshin in https://github.com/AvaloniaUI/Avalonia/pull/12846
- macOS: Disallow entering fullscreen when showing window. by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/12865
- macOS: Don't clear clipboard in SetText. by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/12866
- Fixes font family definitions that mix embedded and system fonts by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12871
- Fix DataGrid' SelectedItems removing wrong item when DataGrid is grou. by @liwuqingxin in https://github.com/AvaloniaUI/Avalonia/pull/12875
- Fix focus loss issue with AutocompleteBox by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/12883
- macOS file type filter in native file dialog by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/12899
- Change iOS initialization order by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/12915
- Detect recursion and check for cancellation in analyser while loops by @TomEdwardsEnscape in https://github.com/AvaloniaUI/Avalonia/pull/12916
- Trimmable runtime xaml loader by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/12937
- [X11] Don't convert the current time from long to int by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/12941
- [Windows] [IME] Prevent duplicate input for some IMEs by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12942
- Fix - TextPresenter ignores FontStretch property by @VladimirDrobyshev in https://github.com/AvaloniaUI/Avalonia/pull/12947
- Add support for setting tooltip text for TrayIcons on macOS by @Takoooooo in https://github.com/AvaloniaUI/Avalonia/pull/12948
- Fix VirtualizingStackPanel and nth-child for the currently realizing item container by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12957
- FluentTheme: settable ListBoxItem.FontWeight/FontSize by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12958
- Added guards for compositor reentrancy and exposed batch lifetime events by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/12968
- [Browser] [IME] Fix event handling by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12970
- Fix HeadlessUnitTestSession creation race condition by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12979
- Fix FontManager crash by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/12982
- Fix XAML name generator with non-Avalonia XAML files by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13001
- Fix unit tests culture by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13016
- Fix ItemsControl logical child removal by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13019
- In Avalonia.Controls, modernized getter/setter syntax by @Lehonti in https://github.com/AvaloniaUI/Avalonia/pull/13021
- Fix initial logical scrollable state by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13066
- Fix offset expression animation by @Meloman19 in https://github.com/AvaloniaUI/Avalonia/pull/13071
- Add "EGL_ANGLE_flexible_surface_compatibility" ext check by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13080
- Fix CalendarDatePicker two way binding syntax. by @rabbitism in https://github.com/AvaloniaUI/Avalonia/pull/13083
- fix: TemplateBinding clone should carry original Mode. by @rabbitism in https://github.com/AvaloniaUI/Avalonia/pull/13087
- Fix popup tests randomly failing after logical scrollable tests by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/13098
- [nuke] Use a regex to detect a release branch. by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/13106
- Update SkiaSharp to 2.88.6 to fix a critical security vulnerability by @spofdamon in https://github.com/AvaloniaUI/Avalonia/pull/13109
- fix parsing the baseline version for api diff. by @danwalmsley in https://github.com/AvaloniaUI/Avalonia/pull/13156
- Fix AccessKeyHandler matching on elements that are not effectively enabled. by @boydpatterson in https://github.com/AvaloniaUI/Avalonia/pull/13185
- Try to fix api validator by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/13213
`ItemsControl.ItemContainerTheme` `while` `Avalonia.Controls` `get` `set` Full Changelog: https://github.com/AvaloniaUI/Avalonia/compare/11.0.4...11.0.5
### 11.0.4​
Just some bug fixes! Stability++
https://www.nuget.org/packages/Avalonia/11.0.4
#### What's Changed​
- [TransitioningContentControl] Manage his LogicalChildren by @danielmayost in https://github.com/AvaloniaUI/Avalonia/pull/12173
- Set PreserveSig to true for OleGetClipboard by @EgorRudakov2 in https://github.com/AvaloniaUI/Avalonia/pull/12553
- Fixed memory leaks in ContextMenu.cs by @adirh3 in https://github.com/AvaloniaUI/Avalonia/pull/12526
- Fix DataGridHeader style by @Flithor in https://github.com/AvaloniaUI/Avalonia/pull/12544
- remove legacy nuget feed no longer reachable. by @danwalmsley in https://github.com/AvaloniaUI/Avalonia/pull/12563
- fix macos keydown and textinput events being raised in the wrong order. by @danwalmsley in https://github.com/AvaloniaUI/Avalonia/pull/12560
- Fix for Track not arranging after IsDirectionReversed property changed. by @billhenn in https://github.com/AvaloniaUI/Avalonia/pull/12575
- Enhanced Clipping and Rendered Visuals Tracking in ServerCompositionVisual by @stepangovorko in https://github.com/AvaloniaUI/Avalonia/pull/12568
- Fix UI thread main loop cancellation from another thread on macOS by @de1acr0ix in https://github.com/AvaloniaUI/Avalonia/pull/12579
- Introduce RenderOptions.RequiresFullOpacityHandling by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12572
- Updated ToggleSplitButton.IsChecked to bind TwoWay by default, same as ToggleButton. by @billhenn in https://github.com/AvaloniaUI/Avalonia/pull/12584
- Fixes TextBox measure logic for MaxLines scenario by @billhenn in https://github.com/AvaloniaUI/Avalonia/pull/12589
- ShowInTaskBar with Owned window: make consistent with WPF by @danwalmsley in https://github.com/AvaloniaUI/Avalonia/pull/12593
#### New Contributors​
- @EgorRudakov2 made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12553
- @Flithor made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12544
- @billhenn made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12575
- @stepangovorko made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12568
- @de1acr0ix made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12579
Full Changelog: https://github.com/AvaloniaUI/Avalonia/compare/11.0.3...11.0.4
### 11.0.3​
Minor fixes and improvements
#### What's Changed​
- feat(NumericUpDown): TextAlignment by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/12368
- Make the animation display complete by @Coloryr in https://github.com/AvaloniaUI/Avalonia/pull/12364
- Add null check for TextInputMethodClient in OnSelectionChanged() method by @3dfxuser in https://github.com/AvaloniaUI/Avalonia/pull/12415
- Generate pdb for ref assemblies by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12410
- Fix not working hotkey on a custom control. closes #12323 by @flexxxxer in https://github.com/AvaloniaUI/Avalonia/pull/12347
- Fix DataContext not getting GC'd/Finalized. closes #12123 by @flexxxxer in https://github.com/AvaloniaUI/Avalonia/pull/12430
- Unwrap win32 data object by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/12478
- Allow embedded root automation peers. by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/12330
#### New Contributors​
- @Coloryr made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12364
- @3dfxuser made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12415
- @flexxxxer made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12347
### 11.0.2​
https://www.nuget.org/packages/Avalonia/11.0.2
#### What's Changed​
- Use embedded pdb for analyzers and build tasks by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12336
- Fix window incorrect positioning with window startup location CenterScreen on macOS by @Takoooooo in https://github.com/AvaloniaUI/Avalonia/pull/12327
- Fixed issue where RowDetailsTemplate was getting the wrong DataContext by @Gundz in https://github.com/AvaloniaUI/Avalonia/pull/12174
- Catch dbus errors so that WatchAsync can register all names by @ThereGoesMySanity in https://github.com/AvaloniaUI/Avalonia/pull/12377
#### New Contributors​
- @Gundz made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12174
Full Changelog: https://github.com/AvaloniaUI/Avalonia/compare/11.0.1...11.0.2
### 11.0.1​
Bug fixes only this time folks!
https://www.nuget.org/packages/Avalonia/11.0.1
#### What's Changed​
- Fix datagrid not updating when not attached to tree by @almightyju in https://github.com/AvaloniaUI/Avalonia/pull/12009
- Fix AutoCompleteBox not opening when the text box is empty by @AtomCrafty in https://github.com/AvaloniaUI/Avalonia/pull/12057
- Add event trigger time in DevTools. #11338 by @yll690 in https://github.com/AvaloniaUI/Avalonia/pull/12036
- Use CancellationToken in AvaloniaNameGenerator by @jankrib in https://github.com/AvaloniaUI/Avalonia/pull/12043
- Country or Region by @afunc233 in https://github.com/AvaloniaUI/Avalonia/pull/12070
- Fix EGL OpenGLControlBase on Win32 by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/12056
- Drop original internal XAML resources after merge by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12074
- Api validation tool by @maxkatz6 in https://github.com/AvaloniaUI/Avalonia/pull/12072
- Setting child of TestRoot once by @YohDeadfall in https://github.com/AvaloniaUI/Avalonia/pull/12094
- Add suppression for removed generated NamespaceInfo types by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12136
- Changed null checks to make use of nameof() by @Lehonti in https://github.com/AvaloniaUI/Avalonia/pull/12150
- Removed redundant Source check by @YohDeadfall in https://github.com/AvaloniaUI/Avalonia/pull/12035
- Fix composition render resources invalidation by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12146
- Rename ImportCompeted into ImportCompleted by @jgcodes2020 in https://github.com/AvaloniaUI/Avalonia/pull/12117
- fix textbox crash double clicking last empty line 12161 by @startewho in https://github.com/AvaloniaUI/Avalonia/pull/12171
- remove duplicates in InternalsVisibleTo by @viordash in https://github.com/AvaloniaUI/Avalonia/pull/12200
- fix combobox inside popup 11954 by @startewho in https://github.com/AvaloniaUI/Avalonia/pull/12186
- Fix SelectedValueBinding with items defined in XAML by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/12193
- Added support for Mica Light & Dark based on Win11 by @adirh3 in https://github.com/AvaloniaUI/Avalonia/pull/12196
- Allow to run previewer from command line via MSBuild target by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/12206
- Fix typo in GetColorValues by @Sorien in https://github.com/AvaloniaUI/Avalonia/pull/12215
- X11 mate clipboard by @viordash in https://github.com/AvaloniaUI/Avalonia/pull/12002
- added clear function to combobox by @lhsrebel72 in https://github.com/AvaloniaUI/Avalonia/pull/12217
- Generate external symbol packages by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12216
- Remove unnecessary cast from RootAutomationNode. by @grokys in https://github.com/AvaloniaUI/Avalonia/pull/12222
- Modernizing syntax by @Lehonti in https://github.com/AvaloniaUI/Avalonia/pull/12226
- Special handling for macos dispatcher quirks by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/12230
- Rework TextLine.GetNext/PreviousCharacterHit by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12239
- Make dispatcher more usable on non-ui threads by @kekekeks in https://github.com/AvaloniaUI/Avalonia/pull/12240
- macOS native: fix destructors accessing freed .NET objects by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12248
- Fix window incorrect positioning with window startup location CenterScreen by @Takoooooo in https://github.com/AvaloniaUI/Avalonia/pull/12093
- Update Rotate3DTransition.cs to fix flickering by @yankun in https://github.com/AvaloniaUI/Avalonia/pull/12254
- Handle ScrollContentPresenter extent rounding errors by @MrJul in https://github.com/AvaloniaUI/Avalonia/pull/12256
- Support non-generic AvaloniaProperty in GetObservable(converter) by @tomenscape in https://github.com/AvaloniaUI/Avalonia/pull/12160
- Android - Text Input fixes by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/12270
- feat(DataGrid): Allow binding DataGridColumn Witdh by @workgroupengineering in https://github.com/AvaloniaUI/Avalonia/pull/12088
- Fix TextLine.GetCharacterHitFromDistance for mixed buffers by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12318
- Fix creating fields for attached properties called name. closes #12283 by @Mrxx99 in https://github.com/AvaloniaUI/Avalonia/pull/12294
- Fix windows with BorderOnly decoration being unresizable by @emmauss in https://github.com/AvaloniaUI/Avalonia/pull/12257
- Fix segfault on Linux when typing in a TexBox by @iq2luc in https://github.com/AvaloniaUI/Avalonia/pull/12313
- Adjust GetCharacterHitFromDistance to match what WPF expects by @Gillibald in https://github.com/AvaloniaUI/Avalonia/pull/12322
`AvaloniaProperty` `GetObservable(converter)` #### New Contributors​
- @yll690 made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12036
- @afunc233 made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12070
- @Lehonti made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12150
- @jgcodes2020 made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12117
- @lhsrebel72 made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12217
- @Mrxx99 made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12294
- @iq2luc made their first contribution in https://github.com/AvaloniaUI/Avalonia/pull/12313
Full Changelog: https://github.com/AvaloniaUI/Avalonia/compare/11.0.0...11.0.1
### 11.0.0​
Our docs have had an overhaul also: https://docs.avaloniaui.net/
See this guide on how to update your application. https://docs.avaloniaui.net/docs/next/stay-up-to-date/upgrade-from-0.10
https://www.nuget.org/packages/Avalonia/11.0.0
#### What's New​
##### A11y (Accessibility)​
This version of Avalonia takes major strides in making applications more accessible. We've added support for various accessibility tools, making it easier for everyone to use Avalonia applications.
##### IME (Input Method Editor) Support​
We have introduced support for Input Method Editor (IME), this allows onscreen keyboards and input in all languages.
##### Compositing Renderer​
The new compositing renderer enhances the graphical rendering capabilities, providing a more robust, efficient, and flexible rendering pipeline.
##### WebAssembly (WASM) Support​
WASM support allows Avalonia applications to run directly in the browser, broadening our platform support and giving developers more freedom and flexibility.
##### iOS and Android Support​
We've added support for both iOS and Android platforms. Developers can now build and run Avalonia applications on two of the most popular mobile platforms.
##### Full Rich Text support​
You can now fully render rich text allowing you to render complex documents.
With the Text Inlines feature, you can easily construct complex formatted text blocks. It enables you to add annotations, hyperlinks, and other inline elements in your text.
##### Smooth Virtualization (Reworked ItemsControl)​
We've completely reworked the ItemsControl to provide smooth virtualization. This improves the efficiency and user experience for controls with many items.
##### Performance Improvements​
Avalonia 11.0 comes with significant performance improvements, enhancing the speed and efficiency of your applications.
##### Control Themes, Nested Styles, and Theme Variants​
We've added the ability to theme controls, apply nested styles, and choose theme variants. This makes it easier to build beautiful and consistent UIs.
##### Bitmap Effects​
The Bitmap Effects feature lets you apply visual effects to bitmaps. You can add blur, drop shadows, and other effects to images.
##### 3D Transforms​
With 3D Transforms, you can now create stunning three-dimensional effects in your UI.
##### AOT (Ahead-Of-Time) Compilation and Trimming​
AOT compilation enables your apps to run faster by compiling them before runtime. Trimming reduces the size of your apps by removing unused code.
##### GPU Interop​
The GPU Interop feature allows Avalonia to work more efficiently with the GPU, improving rendering performance and visuals.
##### Experimental Metal Support​
We're testing Metal support to improve performance on iOS and macOS devices.
- 11.0.7What's Changed
- What's Changed
- 11.0.6What's Changed
- What's Changed
- 11.0.5What's Changed
- What's Changed
- 11.0.4What's ChangedNew Contributors
- What's Changed
- New Contributors
- 11.0.3What's ChangedNew Contributors
- What's Changed
- New Contributors
- 11.0.2What's ChangedNew Contributors
- What's Changed
- New Contributors
- 11.0.1What's ChangedNew Contributors
- What's Changed
- New Contributors
- 11.0.0What's New
- What's New
- What's Changed
- New Contributors
- What's Changed
- New Contributors
- What's Changed
- New Contributors
- What's Changed
- New Contributors
- What's New
# https://docs.avaloniaui.net/docs/next/stay-up-to-date/upgrade-from-0.10
# Samples | Avalonia Docs
- Samples & Tutorials
- Samples
## Samples
### Model-View-ViewModel (MVVM)​
#### Basic MVVM
This sample will show you how you can use the MVVM-pattern to receive and process text input by the user.
#### Binding & Converters
This sample will show you how you can use use bindings and converters to convert a Date to a string value (calculating the age of a person).
#### Commands
This sample will show you how you can use Commands to invoke methods in your ViewModel from your user interface.
#### ValueConverter
In this sample you will learn how you can use a Converter inside your Binding in order to calculate a new value for the View.
#### Data Validation
This sample you will learn how to validate properties and display an error message to the user, if the entered values are invalid.
#### Dialogs
This sample will show you how to use Reactive UI Interactions to show [dialogs] in your MVVM application
#### Dialog Manager
This sample will show you how to write a service (we will call it dialog manager) that will help you to show dialogs in your MVVM application
### DataTemplates​
#### Basic DataTemplate
This sample will show you how you can use DataTemplates to control how your data is displayed.
#### FuncDataTemplate
This sample will show you how to use a FuncDataTemplate to create an advanced DataTemplate in code.
#### IDataTemplate
This sample will show you how to implement IDataTemplate in your own class to have full control over your DataTemplates.
### Controls, Styles & Drawing​
#### Customized Button
This sample will show you how to customize the style of a button by creating reusable styles.
#### Making Lists
This sample will show you how to create lists of data using Bindings and a ListBox control
#### Native Menus
This sample will show you how to use native menus on macOS and Linux.
#### Splash Screen
This sample will show you how to create a custom Splash Screen that loads before your MainWindow
#### Rect Painter
This sample will show you how to create a custom rendered control which interacts with the mouse, to form a simple paint application.
#### Image Loading
This sample will show you how to load images via XAML, Bindings and from the internet.
#### Using Google Fonts
This sample will show you how to use Google fonts within your application
#### BattleCity
The purpose of the sample is to demonstrate that how to create a 2D game in Avalonia without writing any rendering code.
### Custom Controls​
#### Custom Rating Control
This sample will show you how to create a custom control. The goal is to create a rating control, where the user can vote via clicking one of several stars.
#### Custom Snowflakes Control
This sample will show you how to create a custom control that overrides OnRender in order to have advanced render capabilities.
### Miscellaneous​
#### Clipboard Operations
This sample demonstrates how to interact with the devices clipboard and copy and paste text.
#### Drag and Drop Operations
This sample demonstrates how to implement dragging and dropping within your Avalonia application.
#### Native File Dialogs
This sample demonstrates how to use the native Save As and Open File dialogs.
#### Basic Localization
This sample demonstrates how to localize your Avalonia application.
#### Basic Inversion of Control
This sample demonstrates how to use the native Save As and Open File dialogs with IoC.
#### Basic ViewLocator
This sample will show you how to use a ViewLocator in order to change the contents of your UI.
#### Native AOT
This sample will show you how to setup your application for building with Native AOT
### Automated UI Testing​
#### Headless Testing with XUnit
This sample will show you how the headless platform in Avalonia provides the capability to run Avalonia applications without a visible graphical user interface
#### Headless Testing with NUnit
This sample will show you how the headless platform in Avalonia provides the capability to run Avalonia applications without a visible graphical user interface
#### Testing with Appium
Automated tests for UI interactions, such as button clicks, text input, and screen navigation.
- Model-View-ViewModel (MVVM)
- DataTemplates
- Controls, Styles & Drawing
- Custom Controls
- Miscellaneous
- Automated UI Testing
# Create a GroupBox Using HeaderedContentControl | Avalonia Docs
- Samples & Tutorials
- Creating a GroupBox
## Create a GroupBox Using HeaderedContentControl
While Avalonia doesn't include a built-in GroupBox control, you can achieve the same functionality and appearance using a HeaderedContentControl with custom styling. The HeaderedContentControl provides a header area and content region, making it perfect for grouping related interface elements.
`GroupBox` `HeaderedContentControl` `HeaderedContentControl` ### Implementation​
Add the following style to your application resources (typically in App.axaml) or to the specific Window or UserControl where you need the GroupBox functionality:
`Window` `UserControl` `GroupBox` ```bash
<Style Selector="HeaderedContentControl">  <Setter Property="Template">    <ControlTemplate>      <Grid>        <Grid.RowDefinitions>          <RowDefinition Height="Auto"/>          <RowDefinition Height="*"/>        </Grid.RowDefinitions>        <Grid.ColumnDefinitions>          <ColumnDefinition Width="Auto"/>          <ColumnDefinition Width="*"/>        </Grid.ColumnDefinitions>            <!-- Header -->        <Border           ZIndex="1"           Background="{DynamicResource SystemControlBackgroundAltHighBrush}"           Padding="5,0,5,0"           Margin="5,0,0,0">          <TextBlock             Text="{TemplateBinding Header}"             FontWeight="Bold"/>        </Border>            <!-- Content Area -->        <Border           Grid.RowSpan="2"           Padding="0,5,0,0"          Grid.ColumnSpan="2"          CornerRadius="4"          Margin="0,10,0,0"          BorderBrush="{DynamicResource SystemControlForegroundBaseMediumBrush}"          BorderThickness="1">          <ContentPresenter             Name="PART_ContentPresenter"            Padding="8"            Content="{TemplateBinding Content}"/>        </Border>      </Grid>    </ControlTemplate>  </Setter></Style>
```
Once the style is in place, you can use the HeaderedContentControl in your XAML:
`HeaderedContentControl` ```bash
<HeaderedContentControl Header="Settings">  <StackPanel Spacing="8">    <TextBox Text="Sample content"/>    <Button Content="Click me"/>  </StackPanel></HeaderedContentControl>
```
![image](https://docs.avaloniaui.net/assets/images/groupbox-48b3afad4fc37be311ae9417d0922557.png)
The style uses Avalonia's theme resources to ensure the control looks appropriate in both light and dark themes. The header text appears to "break" the border line by using a background color matching the window, creating the classic GroupBox appearance. The content area features rounded corners and proper padding for a modern look.
`GroupBox` This implementation provides all the visual and functional benefits of a traditional GroupBox while maintaining consistency with Avalonia's design patterns and theme system.
`GroupBox` - Implementation
# Supported Platforms | Avalonia Docs
- Supported Platforms
## Supported Platforms
Avalonia apps can be written for the following platforms:
`Windows` `macOS` `Linux` `iOS` `Android` `WebAssembly` ### Windows​
- Windows 8.1
- Windows 10
- Windows 11
While Avalonia apps will successfully run on Windows 7, this legacy platform receives limited support. We no longer provide bug fixes for Windows 7-specific issues.
### macOS​
- macOS 10.14 (Mojave)
- macOS 10.15 (Catalina)
- macOS 11 (Big Sur)
- macOS 12 (Monterey)
- macOS 13 (Ventura)
- macOS 14 (Sonoma)
- macOS 15 (Sequoia)
Avalonia also runs on macOS 10.13 (High Sierra), but we are in the process of migrating to the Metal GPU API, which is currently disabled by default. It is planned to be enabled during one of minor updates.
It is possible to develop for macOS on Windows, macOS and Linux using Avalonia. If you plan to sign and notarize your macOS application for distribution, you will require a Mac with XCode installed.
### Linux​
- Debian 9+
- Ubuntu 16.04+
- Fedora 30+
Avalonia works reliably on most Linux distributions as long as they support the .NET SDK and have either X11 or framebuffer capabilities. While we officially support Debian 9+, Ubuntu 16.04+, and Fedora 30+, many other distributions run Avalonia applications without issues, and we actively work to ensure broad Linux compatibility.
For customers with support agreements, we offer expanded Linux distribution coverage and can assist with specific distribution requirements. Wayland support is currently in private preview and will be available in an upcoming release.
WSL 2 distros are supported as well, but libice6, libsm6 and libfontconfig1 dependencies must be installed individually.
`libice6` `libsm6` `libfontconfig1` Skia is built against glibc 2.17. If your distro uses something else instead, you need to build your own libSkiaSharp.so at SkiaSharp. You also can visit SkiaSharp home page for more information about supported versions.
### iOS​
- iOS 13
- iOS 14
- iOS 15
- iOS 16
- iOS 17
- iOS 18
.NET 7 is required for iOS support.
### Android​
.NET 7 is required for Android support.
### WebAssembly (Browser)​
Any browser with full WebAssembly support technically should work - https://caniuse.com/wasm.
For the best performance and support we recommend latest Chrome or Safari versions.
.NET 7 is required for Browser support. Starting with 11.0.6 we recommend .NET 8.
### Additional platform support​
Avalonia also supports Tizen and tvOS, though this is provided by the community.
- Windows
- macOS
- Linux
- iOS
- Android
- WebAssembly (Browser)
- Additional platform support
# What is Avalonia? | Avalonia Docs
- What is Avalonia?
## What is Avalonia?
Avalonia is an open-source, cross-platform UI framework that enables developers to create application using .NET for Windows, macOS, Linux, iOS, Android and WebAssembly.
It uses its own rendering engine to draw UI controls, ensuring consistent appearance and behavior across all supported platforms. This means that developers can share their UI code and maintain a uniform look and feel regardless of the target platform.
![](https://docs.avaloniaui.net/assets/images/Architecture-4860577d5373c89eca69c4178f70045b.png)
### Who Avalonia is for?​
Avalonia is for developers who want to:
- Write cross-platform apps in XAML and C#, from a single shared code-base.
- Share UI, layout and design across multiple platforms.
- Share code, tests, and business logic across platforms.
### How does Avalonia work?​
Avalonia unifies desktop, mobile, and web platforms through a unique approach that differs from traditional cross-platform frameworks. Rather than wrapping native UI controls, Avalonia implements its own cross-platform rendering engine that ensures pixel-perfect consistency across all supported platforms.
#### Architecture Overview​
Avalonia is built on .NET Standard 2.0, allowing it to run on any platform that supports .NET. The framework consists of several key layers:
##### Core Platform-Agnostic Layer​
The majority of Avalonia's functionality resides in a platform-agnostic core layer that handles:
- UI Controls and Layout
- Visual Tree Management
- Styling System
- Data Binding
- Input Handling
- Animation Framework
This core layer is completely platform-independent, meaning it behaves identically regardless of the operating system or device.
##### Rendering Engine​
Unlike frameworks that rely on native UI controls, Avalonia uses its own rendering engine powered by either Skia or Direct2D. This approach means that:
- Applications look and behave identically across platforms
- Custom controls and visual effects can be implemented once and work everywhere
- The framework isn't limited by platform-specific UI capabilities
##### Platform Integration Layer​
Avalonia requires minimal platform-specific code to integrate with each supported platform. This layer handles:
- Window Management
- Input Events
- Clipboard Operations
- Native Dialogs
- Hardware Acceleration
- Platform-Specific Features
##### Runtime Environment​
Avalonia applications run on the .NET runtime, whether that's .NET Core, or Mono.
##### Comparison with Native Approaches​
While frameworks like .NET MAUI abstract over native UI controls, Avalonia takes a different approach:
![](https://docs.avaloniaui.net/assets/images/MAUI-Comparision-c204b70483e3ecf4c9e00349d01503b8.png)
This architectural difference provides several benefits:
- Consistent behavior across platforms
- Pixel-perfect rendering
- Full control over the UI stack
- Simplified platform support
- Reduced maintenance overhead
- Better performance on resource-constrained devices
#### Integration with Native Platforms​
While Avalonia uses its own rendering engine, it still integrates seamlessly with native platform capabilities:
- Windows: Supports Win32 APIs and modern Windows features
- Linux: Works with X11, Wayland, and framebuffer rendering
- macOS: Integrates with Cocoa and platform services
- Mobile: Provides native lifecycle management and platform integration
- Web: Runs via WebAssembly with full browser integration
#### Platform Support Requirements​
At its core, Avalonia requires just two fundamental capabilities to support a new platform:
- The ability to draw pixels on a screen
- The ability to receive input events
This minimal requirement set is what allows Avalonia to support such a wide range of platforms, from desktop operating systems to embedded devices, and even unusual platforms like VNC servers.
This architecture enables Avalonia to deliver on its promise of "One codebase, infinite possibilities" while maintaining high performance and native platform integration where it matters most.
- Who Avalonia is for?
- How does Avalonia work?Architecture OverviewIntegration with Native PlatformsPlatform Support Requirements
- Architecture Overview
- Integration with Native Platforms
- Platform Support Requirements
- Architecture Overview
- Integration with Native Platforms
- Platform Support Requirements
# Welcome | Avalonia Docs
- Welcome
## Welcome
Welcome to the documentation for Avalonia.
### Overview​
Avalonia is a powerful framework that enables developers to create cross-platform application using .NET. It uses its own rendering engine to draw UI controls, ensuring consistent appearance and behavior across various platforms, including Windows, macOS, Linux, Android, iOS and WebAssembly. This means that developers can share their UI code and maintain a uniform look and feel regardless of the target platform.
Applications built with Avalonia are written in C# or F#, which makes it easy to rapidly prototype applications that can develop over time into complex systems. Unlike other toolkits that might be restricted by limited APIs, or poor performance, Avalonia applications have the advantage of full access to the platform's capabilities and deliver incredible performance, thanks to the compositional renderer.
As Avalonia applications are cross-platform applications, they are architected similarly to other traditional cross-platform applications. The most common approach is to create a core project that houses the shared code, and then develop platform-specific projects that will consume this shared code.
Avalonia offers two techniques to create user interfaces. The first one is to use code to build UI views leveraging the extensive API provided by Avalonia. Alternatively, developers can utilize the Extensible Application Markup Language (XAML), a declarative markup language that allows developers to define user interfaces. In this approach, the user interface structure is described in a XAML file, while the runtime behavior is defined in a separate code-behind file. To learn more about XAML, refer to Avalonia XAML.
### Get Started​
Get started right away even if you are completely new to Avalonia using a simple step-by-step tutorial, with introductions to the basic concepts behind the framework.
Get started here.
### Continue Your Learning​
Learn the basic concepts of Avalonia.
Get started here.
#### How-To Guides​
Our guides offer practical implementation advice, often as step-by-step procedures. This section is organised by task.
Get the guides for practical advice here.
#### Advanced Concepts​
Read this section to expand your knowledge of the concepts used by Avalonia. This section is organised by subject.
Explore the advanced Avalonia concepts here.
### Coming from WPF?​
We have specific guidance and some detailed reference material for developers who are converting applications from WPF (Windows Presentation Foundation).
See our WPF migration guide here.
### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
### Consult Our Reference​
See our reference section here.
### Getting Help​
If you encounter any issues or bugs with Avalonia, please open a new issue on GitHub.
Access the Avalonia GitHub here.
We have an active developer community on Gitter and Telegram that can often help.
Connect to community support using the details here.
In addition to community support, we offer a range of commercial support plans that provide priority assistance from the core contributors.
To learn more about commercial support, see our website page here.
- Overview
- Get Started
- Continue Your LearningHow-To GuidesAdvanced Concepts
- How-To Guides
- Advanced Concepts
- Coming from WPF?
- Consult Our Reference
- Getting Help
- How-To Guides
- Advanced Concepts
# How-To Guides | Avalonia Docs
- How-To Guides
## How-To Guides
This section has practical guidance to help you implement specific tasks using Avalonia UI. Many are at the level of "how do I do that?". This section is arranged by subject area.
# Deep Dives | Avalonia Docs
- Deep Dives
## Deep Dives
This section contains pages that will help you understand some of the concepts used by Avalonia UI. This is background and theory information, often supported by code samples you can work through. This section is arranged alphabetically by title.
If you are new to Avalonia UI, we recommend that you complete the 'Get Started' before you read these pages.
If you are looking for practical advice on how to achieve any of the above, learn the Basics.
# Migrating from WPF | Avalonia Docs
- Get Started
- Coming from WPF?
## Migrating from WPF
This reference will help you leverage your existing knowledge of Windows Presentation Foundation (WPF) to learn Avalonia UI quickly.
You will see how although Avalonia UI is often very similar to WPF; there are some differences. In particular, in the way in which the following work:
- Styling
- Data Templates
### Avalonia XPF - Cross-Platform WPF
Take your WPF apps to macOS and Linux in minutes, not months.
# Reference | Avalonia Docs
- Reference
## Reference
# Create a New Project | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Create a New Project
## Create a New Project
On this page you will lean how to create a new project for the app.
#### JetBrains Rider​
Before you start, check you have installed the Avalonia UI solution templates for JetBrains Rider.
For full instructions on preparing JetBrains Rider for developing with Avalonia UI, see here.
With the solution templates installed, begin this tutorial by following these instructions:
- On the Welcome to JetBrains Rider screen, click New Solution.
- From the project types list on the left, locate and click Avalonia .NET Core MVVM App. It will be under the section Other.
- Leave the MVVM Toolkit option as (the default) ReactiveUI framework.
- Enter the Solution name as 'Avalonia.MusicStore'.
- Click Create.
![](https://docs.avaloniaui.net/assets/images/CreateSolution-f2bc9ca073dff56d93923c922b629bce.png)
A new project will be created with the following solution folders and files:
![](https://docs.avaloniaui.net/assets/images/project-structure-1076d972726bb08038cb8b566d8d2cad.png)
Take some time to review the files and folders that the solution template created. You will see that the following the MVVM pattern, these folders were created:
`Images` `Icons` `Fonts` To explore the concepts behind the MVVM pattern, and when is appropriate to use it, see here.
The solution template has created enough files for the application to run. You will meet all of these during the rest of this tutorial.
### Run the Project​
Press the debug button top-right of the IDE to compile and run the project.
This will show a window that looks like:
![](https://docs.avaloniaui.net/assets/images/image-20210310192926578-b7e192b75a72d6125a1b073802e0b9d4.png)
It is a little plain - but you now have a running application, and a blank canvas to start developing with. On the next page you will learn how to add a modern-looking acrylic blur dark background.
- JetBrains Rider
- Run the Project
# Window Styling | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Window Styling
## Window Styling
On this page, you will make the main window look modern by applying a dark theme, and an acrylic blur to the window background.
### Dark Mode​
Follow this procedure to style the main window in 'dark' mode:
- Stop the app if it is still running.
- Locate and open the file App.axaml.
- In the XAML, change the RequestedThemeVariant attribute in the <Application> element from "Default" to "Dark"
`RequestedThemeVariant` `<Application>` ```bash
<Application ...  RequestedThemeVariant="Dark">
```
- Now locate and open the MainWindow.axaml file in the /Views folder.
Notice that the preview pane is still showing the window in 'light' mode. The application will require a rebuild for the new mode to show in the preview pane.
- Click Build Startup Project on the Build menu.
The preview pane now changes to the dark mode.
![](https://docs.avaloniaui.net/assets/images/dark-mode-preview-fc2e029ec50f95131a48b6740e516a4b.png)
### Acrylic Blur​
Follow this procedure to style the background of the main window with an acrylic blur:
- Locate and open the MainWindow.axaml file in the /Views folder.
- Find the end of the opening tag of the <Window> element.
- After the Title="Avalonia.MusicStore" attribute, add two new attributes as follows:
`<Window>` `Title="Avalonia.MusicStore"` ```bash
<Window ...    Title="Avalonia.MusicStore"    TransparencyLevelHint="AcrylicBlur"    Background="Transparent">
```
- To apply the acrylic effect to the whole window, replace the <TextBlock> element in the content zone of the main window with the following XAML for a panel:
`<TextBlock>` ```bash
<Window ... >    <Panel>      <ExperimentalAcrylicBorder IsHitTestVisible="False">        <ExperimentalAcrylicBorder.Material>          <ExperimentalAcrylicMaterial            BackgroundSource="Digger"            TintColor="Black"            TintOpacity="1"            MaterialOpacity="0.65" />        </ExperimentalAcrylicBorder.Material>      </ExperimentalAcrylicBorder>    </Panel>  </Window>
```
- Click Debug (top right of the IDE) to compile and run the project.
![](https://docs.avaloniaui.net/assets/images/acrylic-material-d4b10095603453969bc69d533df33601.png)
Notice that, as expected, the acrylic window effect covers the content zone of the main window. However the effect does not yet extend to the title bar.
Note that Linux users can not yet take advantage of the following code due to limitations of the X11 version. The tutorial code will run and the window will still work on Linux, but the full effect will not be realised.
Follow this procedure to extend the acrylic blur effect onto the title bar:
- Stop the app if is still running.
- Find the end of the opening tag of the <Window> element again.
- Add the ExtendClientAreaToDecorationsHint attribute as shown:
`<Window>` `ExtendClientAreaToDecorationsHint` ```bash
<Window ...      TransparencyLevelHint="AcrylicBlur"      Background="Transparent"      ExtendClientAreaToDecorationsHint="True">
```
- Click Debug to compile and run the project.
![](https://docs.avaloniaui.net/assets/images/full-acrylic-window-3364fd74d293898df12f3fd9a2523064.png)
Now you have the acrylic blur effect extending into the title bar. On the next page you will learn how to add and layout a control in the window.
- Dark Mode
- Acrylic Blur
# Add and Layout Controls | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Add and Layout Controls
## Add and Layout Controls
The main window of the app will eventually show a list of album covers in the user's collection, with a button at its top-right corner to allow the user to add a new album. The button will open a search dialog window to find new albums to add.
On this page you will learn how to layout the main window so that the button appears at its top-right corner, as required.
### Button Layout​
To display a button in the content zone of the main window, follow this procedure:
- Stop the app if it is still running.
- Locate and open the MainWindow.axaml file.
- Inside the panel element, add the following XAML for a button. The panel XAML should look like this:
```bash
<Panel>  <ExperimentalAcrylicBorder IsHitTestVisible="False">    <ExperimentalAcrylicBorder.Material>      <ExperimentalAcrylicMaterial         BackgroundSource="Digger"         TintColor="Black"         TintOpacity="1"         MaterialOpacity="0.65" />    </ExperimentalAcrylicBorder.Material>   </ExperimentalAcrylicBorder>   <Button Content="Buy Music"/></Panel>
```
- Click Debug to compile and run the project.
![](https://docs.avaloniaui.net/assets/images/buy-button-6d485acdfa5364bea50d7a45203e34b6.png)
You will see the button, but it is in the default position and not at the top-right of the window as required.
Follow this procedure to position the button correctly:
- Stop the app if it is still running
- Wrap the button element in a new panel element.
- Add a margin attribute to the new panel element, with a value of 40.
- Add horizontal and vertical alignment attributes to the button element, as shown:
```bash
<Panel Margin="40"> <Button Content="Buy Music"   HorizontalAlignment="Right" VerticalAlignment="Top" /></Panel>
```
You should see all these changes reflected in the preview pane as you add them.
### Button Icon​
Have a look back at the image of the finished app here.
You will see that the button shows an icon, and not text (as it currently does). This is actually the Microsoft Store icon from the Fluent Icons collection, and Avalonia UI has definitions for all these for you to use.
To use the Microsoft Store icon, follow this procedure:
- Navigate to the Avalonia UI GitHub to find the list of Fluent Icons at https://avaloniaui.github.io/icons.html
- Use your browser's text search to locate the name of the icon 'store_microsoft_regular'. There should be some code similar to:
```bash
<StreamGeometry x:Key="store_microsoft_regular">M11.5 9.5V13H8V9.5H11.5Z M11.5 17.5V14H8V17.5H11.5Z M16 9.5V13H12.5V9.5H16Z M16 17.5V14H12.5V17.5H16Z M8 6V3.75C8 2.7835 8.7835 2 9.75 2H14.25C15.2165 2 16 2.7835 16 3.75V6H21.25C21.6642 6 22 6.33579 22 6.75V18.25C22 19.7688 20.7688 21 19.25 21H4.75C3.23122 21 2 19.7688 2 18.25V6.75C2 6.33579 2.33579 6 2.75 6H8ZM9.5 3.75V6H14.5V3.75C14.5 3.61193 14.3881 3.5 14.25 3.5H9.75C9.61193 3.5 9.5 3.61193 9.5 3.75ZM3.5 18.25C3.5 18.9404 4.05964 19.5 4.75 19.5H19.25C19.9404 19.5 20.5 18.9404 20.5 18.25V7.5H3.5V18.25Z</StreamGeometry>
```
- Copy all of the code for the icon.
- In the Rider solution explorer, right-click the project.
- Click Add, then click Avalonia Styles
![](https://docs.avaloniaui.net/assets/images/add-styles-05c13ebecc8b800da8c49f8b29994159.png)
- Enter the Name 'Icons', press enter.
- Locate and open the new Icons.axaml file that is created. The XAML will look like this:
```bash
<Styles xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <Design.PreviewWith>    <Border Padding="20">      <!-- Add Controls for Previewer Here -->    </Border>  </Design.PreviewWith>  <!-- Add Styles Here --></Styles>
```
- Add a new <Style> element with start and end tags.
- Add a new <Style.Resources> element with start and end tags inside the new <Style> element.
- Paste your icon code inside the <Style.Resources> element.
`<Style>` `<Style.Resources>` `<Style>` `<Style.Resources>` The icons file now looks like this:
```bash
<Styles xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">  <Design.PreviewWith>    <Border Padding="20">      <!-- Add Controls for Previewer Here -->    </Border>  </Design.PreviewWith>  <!-- Add Styles Here -->  <Style>    <Style.Resources>      <StreamGeometry x:Key="store_microsoft_regular">M11.5 9.5V13H8V9.5H11.5Z M11.5 17.5V14H8V17.5H11.5Z M16 9.5V13H12.5V9.5H16Z M16 17.5V14H12.5V17.5H16Z M8 6V3.75C8 2.7835 8.7835 2 9.75 2H14.25C15.2165 2 16 2.7835 16 3.75V6H21.25C21.6642 6 22 6.33579 22 6.75V18.25C22 19.7688 20.7688 21 19.25 21H4.75C3.23122 21 2 19.7688 2 18.25V6.75C2 6.33579 2.33579 6 2.75 6H8ZM9.5 3.75V6H14.5V3.75C14.5 3.61193 14.3881 3.5 14.25 3.5H9.75C9.61193 3.5 9.5 3.61193 9.5 3.75ZM3.5 18.25C3.5 18.9404 4.05964 19.5 4.75 19.5H19.25C19.9404 19.5 20.5 18.9404 20.5 18.25V7.5H3.5V18.25Z</StreamGeometry>    </Style.Resources>  </Style></Styles>
```
With a new icons file prepared, you must now include it in your app.
Follow this procedure to include the icons file:
- Locate and open the App.axaml file.
- Add a <StyleInclude> element as shown:
`<StyleInclude>` ```bash
<Application.Styles>  <FluentTheme />  <StyleInclude Source="avares://Avalonia.MusicStore/Icons.axaml" /></Application.Styles>
```
You need to build the application so that the icons become available to the preview pane.
To change the button from text to icon content, follow this procedure:
- Locate and open the MainWindow.axaml file.
- Alter the XAML for the button, as shown:
```bash
<Button HorizontalAlignment="Right" VerticalAlignment="Top">      <PathIcon Data="{StaticResource store_microsoft_regular}" /> </Button>
```
- Click Debug to compile and run the project.
![](https://docs.avaloniaui.net/assets/images/pretty-button-1262f71e658a7f60414675cebde35698.png)
On the next page, you will learn how to link the button in the view (of the MVVM pattern) to a command in the view model, so it can act on the application logic there.
- Button Layout
- Button Icon
# Button Command | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Button Command
## Button Command
So far in this tutorial, you have altered only files from the view part of the MVVM pattern (for the main window and app). On this page you will learn how to link the button in the view for the main window, to a command in the view model. This will cause user interaction with the view (in this case a button click) to have an effect in the application logic of the view model.
When you are develop with Avalonia UI and the MVVM pattern, the solution template will give you a choice of MVVM toolkits. This tutorial is using the ReactiveUI framework, and the solution template has already added the packages necessary.
### Reactive Command​
The first step in linking the view and view model is to make the view model able to accept a command. You will achieve this by adding the .NET ICommand interface to the main window, and then implementing it with a ReactiveUI ReactiveCommand. Follow this procedure:
`ICommand` `ReactiveCommand` - Stop the app if it is still running.
- Locate and open the MainWindowViewModel.cs file in the /ViewModels folder.
- Delete the existing content of the class, and add the code shown:
```bash
using ReactiveUI;using System.Windows.Input;namespace Avalonia.MusicStore.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public ICommand BuyMusicCommand { get; }    public MainWindowViewModel()    {      BuyMusicCommand = ReactiveCommand.Create(() =>      {        // Code here will be executed when the button is clicked.      });    }  }}
```
- Place a debug breakpoint at the open (curly) bracket just above the comment line.
To complete the link from the view to your new BuyMusicCommand view model property, you will add a data binding to the button.
`BuyMusicCommand` For more information about the concept of data binding, see here.
To add the button data binding, follow this procedure:
- Locate and open the MainWindow.axaml file.
- Find the XAML for the button and add the command attribute and binding, as shown:
```bash
<Button HorizontalAlignment="Right" VerticalAlignment="Top"    Command="{Binding BuyMusicCommand}">  <PathIcon Data="{StaticResource store_microsoft_regular}"/></Button>
```
The Command attribute of an Avalonia UI button determines what happens when the button is clicked. In this case the data binding expression links to the BuyMusicCommand property of an underlying view model. To confirm that this is what happens:
`BuyMusicCommand` - Click Debug to compile and run the project.
- Click the icon button.
You will see the app stop executing at the breakpoint you previously set in the view model.
On the next page, you will create a new dialog window, and then add some code to display it (where the breakpoint currently is in the view model).
- Reactive Command
# Open a Dialog | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Open a Dialog
## Open a Dialog
On this page you will learn how to use ReactiveUI to manage another window in your app. The new window will eventually contain a search facility, and a button to add one of the album covers found to a list in the main window. This new window will be opened as a dialog - that is it will prevent activity in the main window while it is showing.
### Add a New Dialog Window​
There is nothing special about a window view file that makes it into a dialog; that is up to the way in which the window is controlled by the app; and you will use ReactiveUI to manage this. So the first step is to create a new window for the app.
To create a new window, follow this procedure:
- Stop the app if it is still running.
- In the solution explorer, right-click the /Views folder and then click Add.
- Click Avalonia Window.
- When prompted for the name, type 'MusicStoreWindow'
- Press enter.
![](https://docs.avaloniaui.net/assets/images/add-window-c6bcadbc5c6f2ef76e3c36240fc22958.png)
### Dialog Window Styling​
To style the new dialog window so that it matches the main window, follow this procedure:
- Locate and open the MusicStoreWindow.axaml file.
- Change this code as follows to add the acrylic blur background, extended into the title bar (as before) as shown:
```bash
<Window xmlns="https://github.com/avaloniaui"    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"    mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"    x:Class="Avalonia.MusicStore.Views.MusicStoreWindow"    Title="MusicStoreWindow"    TransparencyLevelHint="AcrylicBlur"    ExtendClientAreaToDecorationsHint="True">  <Panel>    <ExperimentalAcrylicBorder IsHitTestVisible="False">      <ExperimentalAcrylicBorder.Material>        <ExperimentalAcrylicMaterial          BackgroundSource="Digger"          TintColor="Black"          TintOpacity="1"          MaterialOpacity="0.65" />      </ExperimentalAcrylicBorder.Material>    </ExperimentalAcrylicBorder>    <Panel Margin="40">    </Panel>  </Panel></Window>
```
### Dialog Input and Output​
The application logic for the dialog will be controlled by its own view model. This will be created and linked to the dialog window view whenever the dialog is to be shown.
Similarly, the result of the users interaction with the dialog will eventually have to be passed back to the application logic for the main window for processing.
At this stage you will create two empty view model classes to act as placeholders for the dialog view model, and the dialog return (selected album) object. To create these view models, follow this procedure:
- In the solution explorer, right-click the /ViewModels folder and then click Add.
- Click Class.
- Name the class 'MusicStoreViewModel' and click Add.
- Right-click again the /ViewModels folder and then click Add a second time.
- Click Class.
- Name the class 'AlbumViewModel' and click Add.
### Show Dialog​
Now you have a new window for the dialog, and some view model classes for its interaction; there are two steps to create the dialog interaction:
- The main window view model starts the interaction.
- The main window view knows how to start the interaction.
Firstly, to alter the main window view model code so it starts the interaction to show the dialog, follow this procedure:
- Locate and open the MainWindowViewModel.cs file.
- Add a declaration for the interaction with the new dialog window, as shown:
```bash
public Interaction<MusicStoreViewModel, AlbumViewModel?> ShowDialog { get; }
```
- Alter the constructor code to create the reactive command from a asynchronous task, as shown:
```bash
using System;using System.Collections.Generic;using System.Reactive.Linq;using System.Text;using System.Windows.Input;using ReactiveUI;namespace Avalonia.MusicStore.ViewModels{  public class MainWindowViewModel : ViewModelBase  {    public MainWindowViewModel()    {      ShowDialog = new Interaction<MusicStoreViewModel, AlbumViewModel?>();      BuyMusicCommand = ReactiveCommand.CreateFromTask(async () =>      {        var store = new MusicStoreViewModel();        var result = await ShowDialog.Handle(store);      });    }    public ICommand BuyMusicCommand { get; }    public Interaction<MusicStoreViewModel, AlbumViewModel?> ShowDialog { get; }  }}
```
At this point, the code for the interaction is still incomplete. If you attempt to run the app now and click the icon button, you will get an exception of class ReactiveUI.UnhandledInteractionException.
`ReactiveUI.UnhandledInteractionException` Your next step is to make sure that the main window view knows how to start the interaction. This is implemented in the code-behind file for the main window view, and uses some features of the ReactiveUI framework. Follow this procedure:
- Locate and open the code-behind MainWindow.axaml.cs file. (You may need to expand the MainWindow.axaml file to find it.)
- Alter the class so that it inherits from ReactiveWindow<MainWindowViewModel>.
- Add the DoShowDialogAsync method as follows:
`ReactiveWindow<MainWindowViewModel>` `DoShowDialogAsync` ```bash
// This code is only valid in newer ReactiveUI which is shipped since avalonia 11.2.0 private async Task DoShowDialogAsync(IInteractionContext<MusicStoreViewModel,                    AlbumViewModel?> interaction){   var dialog = new MusicStoreWindow();   dialog.DataContext = interaction.Input;   var result = await dialog.ShowDialog<AlbumViewModel?>(this);   interaction.SetOutput(result);}
```
- Add the following code to the end of the constructor:
```bash
this.WhenActivated(action =>     action(ViewModel!.ShowDialog.RegisterHandler(DoShowDialogAsync)));
```
This means that whenever the main window view is activated, the DoShowDialogAsync handler is registered. The action is disposable, so that ReactiveUI can clean up the registration when the main window view is not on the screen.
`DoShowDialogAsync` Your whole file should now look like this:
```bash
using Avalonia.ReactiveUI;using Avalonia.MusicStore.ViewModels;using ReactiveUI;using System.Threading.Tasks;namespace Avalonia.MusicStore.Views{  public partial class MainWindow : ReactiveWindow<MainWindowViewModel>  {    public MainWindow()    {      InitializeComponent();      this.WhenActivated(action =>        action(ViewModel!.ShowDialog.RegisterHandler(DoShowDialogAsync)));    }    private async Task DoShowDialogAsync(IInteractionContext<MusicStoreViewModel,                         AlbumViewModel?> interaction)    {      var dialog = new MusicStoreWindow();      dialog.DataContext = interaction.Input;      var result = await dialog.ShowDialog<AlbumViewModel?>(this);      interaction.SetOutput(result);    }  }}
```
- Click Debug to compile and run the project.
- Click the icon button.
It all works - but the dialog window opens at the same size as the main window, and offset from it.
### Dialog Position and Size​
In the last step here, you will make the dialog smaller that the main window, and open centered on it. You will also make the main window open in the center of the user's screen.
Follow this procedure:
- Stop the app if it is still running.
- Locate and open the MainWindow.axaml file.
- Add an attribute to the <Window> element to set the start-up position:
`<Window>` ```bash
<Window ...  WindowStartupLocation="CenterScreen">
```
- Locate and open the MusicStoreWindow.axaml file.
- Add attributes for the width and height of the dialog, set at 1000 and 550 respectively.
- Add the start-up position attribute set to CenterOwner, as shown:
`CenterOwner` ```bash
<Window ...  Width="1000" Height="550"  WindowStartupLocation="CenterOwner">
```
- Click Debug to compile and run the project.
- Click the icon button.
![](https://docs.avaloniaui.net/assets/images/dialog-opened-80a72e3d908a1ce320cc2950ae60792e.png)
The dialog window is now opened centered inside the main window.
On the next page, you will learn how to add some content to the dialog window to represent a search for albums, and present the results.
- Add a New Dialog Window
- Dialog Window Styling
- Dialog Input and Output
- Show Dialog
- Dialog Position and Size
# Add Dialog Content | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Add Dialog Content
## Add Dialog Content
On the this page you will learn how to add some content to the dialog window. This will be some controls for the search and a dialog close button; together with a list of placeholders for the album covers - these will eventually be loaded as the results of the search.
To arrange the dialog controls, you will use the dock panel layout control, that is part of the Avalonia UI built-in controls. This will keep the search controls at the top of the dialog, and the button at the bottom, whatever the height. The list will be the 'fill' area of the dock panel, so it will always take up all the remaining content zone.
For full information on the dock panel control, see the reference here.
The dock panel itself will be located on an Avalonia UI user control. This is so the code that shows the dialog can be separated from the code that operates the controls within the dialog.
This is a common pattern of UI Composition, to read about this concept, see here.
Follow this procedure to add the user control and constituent controls for the dialog:
- Stop the app if it is still running.
- In the solution explorer, right-click the /Views folder and then click Add.
- Click Avalonia User Control.
- When prompted for the name, type 'MusicStoreView'.
- Press enter.
- Alter the XAML for the user control's content zone as follows:
```bash
<UserControl ... > <DockPanel>  <StackPanel DockPanel.Dock="Top">   <TextBox Watermark="Search for Albums...." />   <ProgressBar IsIndeterminate="True" />  </StackPanel>   <Button Content="Buy Album"        DockPanel.Dock="Bottom"        HorizontalAlignment="Center" />   <ListBox/> </DockPanel></UserControl>
```
Inside the dialog the user will be able to search for albums, but this will use a Web API, and may take some time to return. It is for this reason that you have added a progress bar. The progress bar will be active during the search - to provide visual feedback to the user.
Also, to ensure that the app remains responsive during the search, you will implement the operation itself as both asynchronous and cancellable. You will add this functionality later in the tutorial.
Now the next step is for you to add the new user control to the content zone of the dialog window.
To add the user control, follow this procedure:
- Locate and open the MusicStoreWindow.axaml file.
- Add the namespace for the views to the <Window> element:
`<Window>` ```bash
<Window ...  xmlns:views="using:Avalonia.MusicStore.Views" >
```
- Inside the panel element, add an element for new user control:
```bash
<Panel Margin="40">  <views:MusicStoreView/></Panel>
```
You will see the controls appear in the preview pane.
On the next page, you will learn how to use a mock for the album search feature - this is so that you can create the view and view model for the results, and leave the implementation of the real search until later.
# Mock Search | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Mock Search
## Mock Search
On this page you will create the view model for the album search feature, and then bind it to the controls on the new user control. At this stage you will use a mock of the search itself, so that you can concentrate on the view model.
### Reactive View Model​
The ReactiveUI framework provides Avalonia UI with support for its data binding system. You add this support by deriving your view model from the ReactiveObject class, via the ViewModelBase class that was added to your project at the start, by the solution template.
`ReactiveObject` `ViewModelBase` Follow this procedure to derive from the ReactiveObject class:
`ReactiveObject` - Locate and open the MusicStoreViewModel.cs file.
- Add the code to derive the class from ViewModelBase.
`ViewModelBase` ```bash
namespace Avalonia.MusicStore.ViewModels{  public class MusicStoreViewModel : ViewModelBase  {  }}
```
This adds the important extension method RaiseAndSetIfChanged to your view model, and will allow you to give the properties there the ability to notify changes to the view.
`RaiseAndSetIfChanged` To review the concepts behind the MVVM pattern and notification, see here.
At this stage, you will create two properties for the search application logic:
- A text string that is the search criteria,
- A Boolean that indicates whether the search is busy.
- Add the following code to implement the above properties:
```bash
using ReactiveUI;namespace Avalonia.MusicStore.ViewModels{  public class MusicStoreViewModel : ViewModelBase  {    private string? _searchText;    private bool _isBusy;    public string? SearchText    {      get => _searchText;      set => this.RaiseAndSetIfChanged(ref _searchText, value);    }    public bool IsBusy    {      get => _isBusy;      set => this.RaiseAndSetIfChanged(ref _isBusy, value);    }  }}
```
You can see that the properties have a normal public getter which returns the private value field; but the setter calls the RaiseAndSetIfChanged method - in order to implement the notification.
`RaiseAndSetIfChanged` ### Data Binding​
Next you will add a data binding to link the view to the view model. The text box will be bound to the search text, and whether the progress bar is visible to the user will be bound to the Boolean.
Follow this procedure to add data binding to the view:
- Locate and open the MusicStoreView.axaml file.
- Add the binding expressions shown:
```bash
<UserControl ...  xmlns:vm="clr-namespace:Avalonia.MusicStore.ViewModels"  x:DataType="vm:MusicStoreViewModel">  <!-- ... -->  <DockPanel>   <StackPanel DockPanel.Dock="Top">    <TextBox Text="{Binding SearchText}" Watermark="Search for Albums...." />    <ProgressBar IsIndeterminate="True" IsVisible="{Binding IsBusy}" />   </StackPanel>   <Button Content="Buy Album"       DockPanel.Dock="Bottom"       HorizontalAlignment="Center" />   <ListBox/>  </DockPanel>  <!-- ... --></UserControl>
```
### Album Search and Selection​
Your next step is to create the music store view model properties needed to process albums. These are:
- a collection of album view models to represent the albums that the search might find,
- and a property to hold an album if the user selects one.
Here you will use the ObservableCollection - this is a collection is capable of notification, and it is provided by the .NET framework.
`ObservableCollection` Follow this procedure to add the above properties:
- Locate and open the MusicStoreViewModel.cs file.
- Add the following code to the class:
```bash
private AlbumViewModel? _selectedAlbum;public ObservableCollection<AlbumViewModel> SearchResults { get; } = new();public AlbumViewModel? SelectedAlbum{  get => _selectedAlbum;  set => this.RaiseAndSetIfChanged(ref _selectedAlbum, value);}
```
Next to bind these properties to the list box in the view, follow this procedure:
- Locate and open the MusicStoreView.axaml file.
- Add the binding expressions shown to the <ListBox> element:
`<ListBox>` ```bash
<ListBox ItemsSource="{Binding SearchResults}" SelectedItem="{Binding SelectedAlbum}" />
```
### Mock Data​
Now, to test the app at this stage, you will add some mock data directly to the view model.
Follow this procedure:
- Locate and open the MusicStoreViewModel.cs file again.
- Add a constructor to the class, as shown:
```bash
public MusicStoreViewModel(){  SearchResults.Add(new AlbumViewModel());  SearchResults.Add(new AlbumViewModel());  SearchResults.Add(new AlbumViewModel());}
```
- Click Debug to compile and run the project.
![](https://docs.avaloniaui.net/assets/images/text-list-c02ea382366c5c5f266e1faa6fe4d351.png)
This shows that the data binding from the list to the album collection in the view model is working, but the view is not graphical yet. On the next page you will develop the app further by replacing the text with graphical album tiles.
- Reactive View Model
- Data Binding
- Album Search and Selection
- Mock Data
# Album View | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Album View
## Album View
On this page you will continue developing the search results list for the app by replacing the text currently shown with graphical album tiles.
### Icon Resource​
The first step here is to add a resource for the 'music note' icon. You will use this to act as a placeholder icon for the album covers in the app - they will eventually be replaced by the downloaded album cover artwork.
To add the music note icon resource, follow this procedure:
- Stop the app if it is still running.
- Navigate to the Avalonia UI GitHub to find the list of Fluent Icons at https://avaloniaui.github.io/icons.html
- Use your browser's text search to locate the name of the icon 'music_regular'. There should be some code similar to:
```bash
<StreamGeometry x:Key="music_regular">M11.5,2.75 C11.5,2.22634895 12.0230228,1.86388952 12.5133347,2.04775015 L18.8913911,4.43943933 C20.1598961,4.91511241 21.0002742,6.1277638 21.0002742,7.48252202 L21.0002742,10.7513533 C21.0002742,11.2750044 20.4772513,11.6374638 19.9869395,11.4536032 L13,8.83332147 L13,17.5 C13,17.5545945 12.9941667,17.6078265 12.9830895,17.6591069 C12.9940859,17.7709636 13,17.884807 13,18 C13,20.2596863 10.7242052,22 8,22 C5.27579485,22 3,20.2596863 3,18 C3,15.7403137 5.27579485,14 8,14 C9.3521238,14 10.5937815,14.428727 11.5015337,15.1368931 L11.5,2.75 Z M8,15.5 C6.02978478,15.5 4.5,16.6698354 4.5,18 C4.5,19.3301646 6.02978478,20.5 8,20.5 C9.97021522,20.5 11.5,19.3301646 11.5,18 C11.5,16.6698354 9.97021522,15.5 8,15.5 Z M13,3.83223733 L13,7.23159672 L19.5002742,9.669116 L19.5002742,7.48252202 C19.5002742,6.75303682 19.0477629,6.10007069 18.3647217,5.84393903 L13,3.83223733 Z</StreamGeometry>
```
- Copy all of the code for the icon.
- Locate and open the Icons.axaml file that you created earlier.
- Paste the copied<StreamGeometry> element inside <Style.Resources> element.
`<StreamGeometry>` `<Style.Resources>` ### Album View​
The next step is to create a graphical 'tile' view for an album. You will then cause this to be used instead of the text that currently shows for each album in the list.
To create the graphical 'tile' view, follow this procedure:
- In the solution explorer, right-click the /Views folder and then click Add.
- Click Avalonia User Control.
- When prompted for the name, type 'AlbumView'.
- Press enter.
- Add the attribute Width="200" to the <UserControl> element.
- Alter the XAML for the user control's content zone as follows:
`Width="200"` `<UserControl>` ```bash
<StackPanel Spacing="5" Width="200">  <Border CornerRadius="10" ClipToBounds="True">    <Panel Background="#7FFF22DD">      <Image Width="200" Stretch="Uniform" />      <Panel Height="200">        <PathIcon Height="75" Width="75" Data="{StaticResource music_regular}" />      </Panel>    </Panel>  </Border>  </StackPanel>
```
The preview pane will now show the new tile view with the music note icon placed in the center.
### View Locator​
The album view model will eventually contain data for the name of an album, the artist, and its downloaded cover art, but at this stage you will continue to use just the placeholder music note icon.
As you saw on the last page, at this point the album list currently just shows the (fully qualified) name of the album view model class.
In this step you will be using the view locator class (ViewLocator.cs file) that was added to the project by the solution template. This class was registered (by the solution template) as a data template at the highest level in the app in the App.axaml file. The data template registration looks like this:
```bash
<Application ...       xmlns:local="using:Avalonia.MusicStore"       ... >  <Application.DataTemplates>    <local:ViewLocator/>  </Application.DataTemplates>  ...</Application>
```
The view locator can therefore always be found by Avalonia UI, when it searches for a data template.
For more details about the data template concept, see here.
The view locator acts as a data template for a view model (in this case the album view model) under the conditions that:
- the view model inherits from the ViewModelBase class,
- and there is a view that exists with the same base name.
`ViewModelBase` The view AlbumView and the view model AlbumViewModel already have the same base name 'Album' and the view AlbumView exists. So the only remaining condition for the view locator to work is that the view model has to inherit from the ViewModelBase class.
`AlbumView` `AlbumViewModel` `AlbumView` `ViewModelBase` Follow this procedure:
- Locate and open the AlbumViewModel.cs file you created earlier.
- Add the code for the class to inherit from ViewModelBase as shown:
`ViewModelBase` ```bash
public class AlbumViewModel : ViewModelBase{    }
```
- Click Debug to compile and run the project.
- Click the icon button.
![](https://docs.avaloniaui.net/assets/images/image-20210310010932979-cfb16340445309073fbd3a6abd33306f.png)
The view locator is finding the view AlbumView to use as a data template for the list items.
`AlbumView` ### List Items Panel Template​
In this step you will tidy up the list display so that the album covers wrap around to fill all the space available.
A list box has a property that contains a template control for laying out the list items. By default this is a stack panel. To make the album covers wrap around to fill all the space, you can change the panel template to be a wrap panel.
You will also add some style attributes to the list box.
To tidy up the list, follow this procedure:
- Stop the app if it is still running.
- Locate and open the MusicStoreView.axaml file.
- Expand the <ListBox> element so that it has start and end tags.
- Add the <ListBox.ItemsPanel> XAML shown:
`<ListBox>` `<ListBox.ItemsPanel>` ```bash
<ListBox ItemsSource="{Binding SearchResults}" SelectedItem="{Binding SelectedAlbum}"  Background="Transparent" Margin="0 20">  <ListBox.ItemsPanel>    <ItemsPanelTemplate>      <WrapPanel />    </ItemsPanelTemplate>  </ListBox.ItemsPanel></ListBox>
```
- Click Debug to compile and run the project.
- Click the icon button.
![](https://docs.avaloniaui.net/assets/images/image-20210310011526700-214f473436e4b92f6b3334778f405463.png)
On the next page, you will add some business logic in the form of a data service, so that you can get real album data from the search.
- Icon Resource
- Album View
- View Locator
- List Items Panel Template
# Album Service | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Album Service
## Album Service
On this page, you will add some business logic to the app This will allow you to replace the mock data and get some real album data from the search. This business logic code forms the 'Model' part of the MVVM pattern.
To implement a real album search in the app, you will use a NuGet package that can call the Apple iTunes Web API album search.
### Apple Web API Package​
Follow this procedure to add the required NuGet package:
- Stop the app if it is still running.
- Right-click the project.
- Click Manage NuGet Packages.
![](https://docs.avaloniaui.net/assets/images/image-20210310013703557-4b3a740b00d571905d1a77964fa72a62.png)
- Type 'itunes' in the search box (top-left).
- Click iTunesSearch, then click Install.
### MVVM Model​
In this tutorial the application is simple, and you can implement the business services required for the 'Model' part of the MVVM pattern, in one class. This class will contain both the data model for an album, and the method needed for the search.
Follow this procedure to add the album business logic:
- In the solution explorer, right-click the /Models folder and then click Add.
- Click Class.
- When prompted for the name, type 'Album'.
- Add the following code:
```bash
using iTunesSearch.Library;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;namespace Avalonia.MusicStore.Models{  public class Album  {    private static iTunesSearchManager s_SearchManager = new();    public string Artist { get; set; }    public string Title { get; set; }    public string CoverUrl { get; set; }    public Album(string artist, string title, string coverUrl)    {      Artist = artist;      Title = title;      CoverUrl = coverUrl;    }    public static async Task<IEnumerable<Album>> SearchAsync(string searchTerm)    {      var query = await s_SearchManager.GetAlbumsAsync(searchTerm)        .ConfigureAwait(false);              return query.Albums.Select(x =>        new Album(x.ArtistName, x.CollectionName,           x.ArtworkUrl100.Replace("100x100bb", "600x600bb")));    }  } }
```
### Album View Model​
In order to display the data from the Web API for each album (data model) in the search results list, you will create an album view model, and this will be bound to the album view (tile) for display.
Your album view model is currently empty. It will need to be able to store the album data from the search, and have some properties for the artist name and album title. These will then be bound to the view for display.
In this step you will use a common pattern for the dependent relationship between a view model and a (business logic) model. This is where the view model contains an instance of the data model, and then exposes certain of its properties, as required for display.
Follow this procedure to prepare the album view model:
- Locate and open the AlbumViewModel.cs file.
- Add the code as shown:
```bash
private readonly Album _album;public AlbumViewModel(Album album){  _album = album;}public string Artist => _album.Artist;public string Title => _album.Title;
```
Note that as the view model properties will not change in the UI during runtime, they have no setter and a plain getter - there is no need to use the RaiseAndSetIfChanged method here.
`RaiseAndSetIfChanged` ### Start the Search​
In this step, you will add some code to the music store view model so that whenever the search text changes, the SearchAsync method on the album model (business service) is started. When it finishes, the search places its results in the observable collection SearchResults. This collection is already bound to the list box, so with a small adjustment to the album view, the results of the search will display as the tiles you prepared earlier.
`SearchAsync` `SearchResults` Follow this procedure to start the search whenever the search text changes:
- Locate and open the MusicStoreViewModel.cs file.
- Replace the constructor code, and add the extra code as shown:
```bash
using Avalonia.MusicStore.Models;using ReactiveUI;using System;using System.Collections.ObjectModel;using System.Reactive.Linq;using System.Threading;namespace Avalonia.MusicStore.ViewModels{  public class MusicStoreViewModel : ViewModelBase  {    ...        public MusicStoreViewModel()    {      this.WhenAnyValue(x => x.SearchText)        .Throttle(TimeSpan.FromMilliseconds(400))        .ObserveOn(RxApp.MainThreadScheduler)        .Subscribe(DoSearch!);    }        private async void DoSearch(string? s)    {      IsBusy = true;      SearchResults.Clear();      if (!string.IsNullOrWhiteSpace(s))      {        var albums = await Album.SearchAsync(s);        foreach (var album in albums)        {          var vm = new AlbumViewModel(album);          SearchResults.Add(vm);        }      }      IsBusy = false;    }  }}
```
The WhenAnyValue method is provided by the ReactiveUI framework as part of the ReactiveObject(inherited via ViewModelBase). The method takes a lambda expression parameter that gets the property you want to observe for changes. So in the above code, an event occurs whenever the user types to change the search text.
`WhenAnyValue` `ReactiveObject` `ViewModelBase` It will be good design to wait until the user has stopped typing before attempting to run the search. The Throttle method prevents the events being processed until the time span (400 milliseconds) is up. This means processing will not start until the user has stopped typing for 400 milliseconds or longer.
`Throttle` The ObserveOn method is required to ensure that the subscribed method is always called on the UI thread. In Avalonia UI applications, you must always update the UI on the UI thread.
`ObserveOn` Lastly, the Subscribe method calls the DoSearch method for each observed event. The DoSearch method runs asynchronously, and has no return value.
`Subscribe` `DoSearch` `DoSearch` ### Bind the Album View​
Your work on the previous page to format the album 'tile' view did not add any way to display the text results of the search.
Follow this procedure to add the album name and artist name to the tile:
- Locate and open the AlbumView.axaml file.
- Add the two text block controls with their data bindings, as shown:
- To have compiled binding working, you need to indicate the datatype used in the view : AlbumViewModel.
```bash
<UserControl ... xmlns:vm="using:Avalonia.MusicStore.ViewModels" x:DataType="vm:AlbumViewModel" > <StackPanel Spacing="5" Width="200">  <Border CornerRadius="10" ClipToBounds="True">   <Panel Background="#7FFF22DD">    <Image Width="200" Stretch="Uniform" />    <Panel Height="200">     <PathIcon Height="75" Width="75" Data="{StaticResource music_regular}" />    </Panel>   </Panel>  </Border>  <TextBlock HorizontalAlignment="Center" Text="{Binding Title}"/>  <TextBlock HorizontalAlignment="Center" Text="{Binding Artist}"/> </StackPanel></UserControl>
```
- Click Debug to compile and run the project.
- Click the icon button.
- Type some search text.
![](https://docs.avaloniaui.net/assets/images/image-20210310110401944-65cd68e142357ed5ab9932b89a96d791.png)
On the next page, you will learn how to improve the look of the app by retrieving the cover art for each album. This will be displayed on the tile instead of the note icon.
- Apple Web API Package
- MVVM Model
- Album View Model
- Start the Search
- Bind the Album View
# Displaying Images | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Displaying Images
## Displaying Images
On this page, you will learn how to retrieve the cover art bitmap for each album in the search results. You will then be able to display the image on each album tile view instead of the placeholder note icon.
### Album Service​
Your first step is to modify the business service to retrieve the album cover art from the Apple iTunes Web API.
Follow this procedure to get the album cover art from the Web API:
- Stop the app if it is still running.
- Locate and open the Album.cs file in the /Models folder.
- Add the code as shown:
```bash
private static HttpClient s_httpClient = new();private string CachePath => $"./Cache/{Artist} - {Title}";public async Task<Stream> LoadCoverBitmapAsync(){  if (File.Exists(CachePath + ".bmp"))  {    return File.OpenRead(CachePath + ".bmp");  }  else  {    var data = await s_httpClient.GetByteArrayAsync(CoverUrl);    return new MemoryStream(data);  }}
```
This method returns a stream that can be used to load a bitmap from, either from a cache file or from the API.
Note that the cache is not active at this time, you will implement it later in the tutorial.
- So that you will see as soon as the cache becomes active, place a debug breakpoint at the following line:;
```bash
return File.OpenRead(CachePath + ".bmp");
```
### Album View Model​
In this step , you will add a property to the album view model to store the cover art as a bitmap.
Note: You must reference Avalonia.Media.Imaging in the album view model because you must use the Avalonia UI bitmap here, and not the .NET System.Bitmap.
`Avalonia.Media.Imaging` `System.Bitmap` Follow this procedure to update the album view model:
- Locate and open the AlbumViewModel.cs file.
- Add the using Avalonia.Media.Imaging; reference.
- Add the extra code for the album cover, as shown:
`using Avalonia.Media.Imaging;` ```bash
using Avalonia.Media.Imaging;...public class AlbumViewModel : ViewModelBase{  ...    private Bitmap? _cover;  public Bitmap? Cover  {    get => _cover;    private set => this.RaiseAndSetIfChanged(ref _cover, value);  }    public async Task LoadCover()  {    await using (var imageStream = await _album.LoadCoverBitmapAsync())    {      Cover = await Task.Run(() => Bitmap.DecodeToWidth(imageStream, 400));    }  }}
```
Take some time to examine this code because it gives an insight into manipulating images with Avalonia UI. For example, the above uses the DecodeToWidth method to convert the image stream for display in Avalonia UI. This method can convert a stream for a large high resolution image into a smaller bitmap, at a specified width and while maintaining the aspect ratio.
`DecodeToWidth` This means that you will not waste large amounts of memory to display the album cover art, even though the Web API returns quite large files.
Also notice how the LoadCover method is coded to run asynchronously, and on a background thread. This is so that the UI thread does not get blocked and make the UI unresponsive.
`LoadCover` ### Load Cover Art​
In this step you will alter the album search (in the music store view model) so that the cover art is loaded for each album that is found. To maintain the responsiveness of the app, you will make this process both asynchronous and cancellable.
Firstly, you will need to add a method that can start loading the album covers whenever search results are returned. You will make this method asynchronous and cancellable.
To add the method to load album cover art, follow this procedure:
- Locate and open the MusicStoreViewModel.cs file.
- Add the code as shown:
```bash
private async void LoadCovers(CancellationToken cancellationToken){  foreach (var album in SearchResults.ToList())  {    await album.LoadCover();    if (cancellationToken.IsCancellationRequested)    {      return;    }  }}
```
Important note: this method iterates through a copy of the search results collection (created by the ToList method). This is because it runs asynchronously on its own thread, and the original results collection could get changed at any time by another thread.
`ToList` The cancellation token argument will allow you to stop the method loading album covers whenever needed.
### Cancellable Image Load​
In this step you will call the LoadCovers method in the DoSearch method (in the music store view model) but with full cancellation management.
`LoadCovers` `DoSearch` Follow this procedure:
- Add this field to the MusicStoreViewModel.cs file.
```bash
private CancellationTokenSource? _cancellationTokenSource;
```
- Modify the code at the beginning of the DoSearch method to set up the cancellation token:
`DoSearch` ```bash
_cancellationTokenSource?.Cancel();_cancellationTokenSource = new CancellationTokenSource();var cancellationToken = _cancellationTokenSource.Token;
```
So if there is an existing request still loading album art, this will cancel it. Again, because _cancellationTokenSource might be replaced asynchronously by another thread, you have to work with a copy stored as a local variable.
`_cancellationTokenSource` - Add the following code to the end of DoSearch method:
`DoSearch` ```bash
if (!cancellationToken.IsCancellationRequested){  LoadCovers(cancellationToken);}
```
At this stage, your DoSearch method should look like this:
`DoSearch` ```bash
private async void DoSearch(string s){  IsBusy = true;  SearchResults.Clear();  _cancellationTokenSource?.Cancel();  _cancellationTokenSource = new CancellationTokenSource();  var cancellationToken = _cancellationTokenSource.Token;  if (!string.IsNullOrWhiteSpace(s))  {    var albums = await Album.SearchAsync(s);    foreach (var album in albums)    {      var vm = new AlbumViewModel(album);      SearchResults.Add(vm);    }    if (!cancellationToken.IsCancellationRequested)    {      LoadCovers(cancellationToken);    }  }  IsBusy = false;}
```
### Album View​
In the last step here, you will alter the data bindings in the album view so that the tile can display the album cover image. You will also add a test so that the placeholder panel is visible only when the album cover image is not available (is null).
Follow this procedure:
- Locate and open the AlbumView.axaml file.
- Add the data binding Source="{Binding Cover}" to the <Image> element:
- Add this data binding and converter to the panel element below:
`Source="{Binding Cover}"` `<Image>` ```bash
IsVisible="{Binding Cover, Converter={x:Static ObjectConverters.IsNull}}"
```
A converter is an extension of a data binding expression that can convert the binding value before it is passed to the bound control. The IsNull converter returns a Boolean that is true when the value object is null.
`IsNull` For more information about the Avalonia UI built-in binding converters, see the reference here.
- Click Debug to compile and run the project.
- Click the icon button.
- Type some search text.
![](https://docs.avaloniaui.net/assets/images/image-20210310173858088-01c46b8609b7d0f2b7ce9f682a2ac9f0.png)
Notice how the album covers load one by one, and the UI remains responsive.
On the next page, you will learn how to return the selected album from dialog, when the user clicks Buy Album.
- Album Service
- Album View Model
- Load Cover Art
- Cancellable Image Load
- Album View
# Dialog Return | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Dialog Return
## Dialog Return
On the this page you add code to return a selected album from the search dialog to the main window.
### Buy Album Command​
The first step here is for you to add a reactive command to the music store view model. You will bind this to the Buy Album button on the music store view.
Follow this procedure to add the reactive command:
- Stop the app if it is running.
- Locate and open the MusicStoreViewModel.cs file.
- Add the reactive command declaration, as shown:
```bash
public ReactiveCommand<Unit, AlbumViewModel?> BuyMusicCommand { get; }
```
- Add code to the constructor to initialize the reactive command, as shown:
```bash
public MusicStoreViewModel(){  BuyMusicCommand = ReactiveCommand.Create(() =>  {     return SelectedAlbum;  });    ...}
```
Notice you are using ReactiveCommand here. This is provided by the ReactiveUI framework to implement some of the MVVM interactions. Specifically, it will allow us to pass an argument of class AlbumViewModel back to the main window view model, when the button is clicked.
`ReactiveCommand` `AlbumViewModel` ### Button Data Binding​
Your next step is bind the Buy Album button to the reactive command in the music store view model, follow this procedure:
- Locate and open the MusicStoreView .axaml file.
- Add the data binding Command="{Binding BuyMusicCommand}" to the button element.
`Command="{Binding BuyMusicCommand}"` ### Close the Dialog​
In this step, you will add some window management so that the dialog closes when the user clicks the Buy Album button. This is needed in addition to the data binding you just added.
As you saw during coding for the dialog open, you implement window management in the code-behind for a window, and use features of the ReactiveWindow from the ReactiveUI framework.
`ReactiveWindow` To add code to close the dialog, follow this procedure:
- Locate and open the MusicStoreWindow.axaml.cs file.
- Add a reference to the system using System;
- Change the base class so the view inherits from ReactiveWindow<MusicStoreViewModel>.
- Then add the following line to the end of the constructor:
`using System;` `ReactiveWindow<MusicStoreViewModel>` ```bash
this.WhenActivated(action => action(ViewModel!.BuyMusicCommand.Subscribe(Close)));
```
The ReactiveUI WhenActivated method defines what happens when the window is activated (becomes visible on the screen). The lambda expression will be called, and it is passed an action that is disposable, so that it can be unsubscribed when the window is no longer active.
`WhenActivated` Your music store window code-behind should now look like this.
```bash
using Avalonia.ReactiveUI;using Avalonia.MusicStore.ViewModels;using ReactiveUI;using System;namespace Avalonia.MusicStore.Views{  public partial class MusicStoreWindow : ReactiveWindow<MusicStoreViewModel>  {    public MusicStoreWindow()    {      InitializeComponent();            // This line is needed to make the previewer happy (the previewer plugin cannot handle the following line).      if (Design.IsDesignMode) return;            this.WhenActivated(action => action(ViewModel!.BuyMusicCommand.Subscribe(Close)));    }  }}
```
- Click Debug to compile and run the project.
- Click the icon button.
- Type some search text.
- Click an album to select it.
- Click Buy Album.
You will see the dialog close, but nothing happens in the main window! On the next page you will learn how to add the selected album to a collection in the main window.
- Buy Album Command
- Button Data Binding
- Close the Dialog
# Add Items to the User's Collection | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Add Items to the User's Collection
## Add Items to the User's Collection
On this page you will implement a collection of albums that the user has selected using the search dialog and the Buy Album button, and display them in the main window.
### Observable Collection​
Your first step here is to add an observable collection to the main window view model. This will hold the albums that the user has selected using the search dialog.
Follow this procedure:
- Stop the app if it is running.
- Locate and open the MainWindowViewModel.cs file.
- Add an observable collection, as shown:
```bash
public ObservableCollection<AlbumViewModel> Albums { get; } = new();
```
### Process the Dialog Result​
Your next step is to alter the buy music reactive command so that it adds the dialog return object (an AlbumViewModel) to the observable collection. Follow this procedure:
`AlbumViewModel` - Alter the code that initializes the reactive command, as shown:
```bash
BuyMusicCommand = ReactiveCommand.CreateFromTask(async () =>{  var store = new MusicStoreViewModel();  var result = await ShowDialog.Handle(store);  if (result != null)  {    Albums.Add(result);  }});
```
### Main Window View​
Next you will add XAML to the main window view to display the items in the observable collection. Again you will use a data template, this time inside an ItemsControl. The items control is actually the base class for controls that display multiple items (like the list box), so some of this will already be familiar.
`ItemsControl` To add the items control and its data template, follow this procedure:
- Locate and open the MainWindow.axaml file.
- Add the following namespace declaration to the <Window> element:
`<Window>` ```bash
xmlns:views="clr-namespace:Avalonia.MusicStore.Views"
```
- Under the button element, add the XAML as shown:
```bash
<ItemsControl Margin="0 40 0 0" ItemsSource="{Binding Albums}"> <ItemsControl.ItemsPanel>  <ItemsPanelTemplate>   <WrapPanel />  </ItemsPanelTemplate> </ItemsControl.ItemsPanel> <ItemsControl.ItemTemplate>  <DataTemplate>   <views:AlbumView Margin="0 0 20 20" />  </DataTemplate> </ItemsControl.ItemTemplate></ItemsControl>
```
- Click Debug to compile and run the project.
- Click the icon button.
- Type some search text.
- Click an album to select it.
- Click Buy Album.
- Repeat another time.
![](https://docs.avaloniaui.net/assets/images/image-20210310175949319-7970fc71954634335555dcac14a52bdc.png)
You will see the user's album collection building as you search and select. However, if you stop the app running and then start it again, the collection reverts to empty.
For the finishing touch, on the next page you will learn how to add some data persistence to the app.
- Observable Collection
- Process the Dialog Result
- Main Window View
# Add Data Persistence | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Add Data Persistence
## Add Data Persistence
On this page, you will add some code to the album model (business service) to save the user's album collection to disk, so that it can be recovered when the app next runs.
As a welcome side-effect, this will also activate the album cover cache - so that album cover images can be retrieved from disk (if they exist), rather than from the Web API.
### Album Model​
Follow this procedure to add persistence services (save and load) to the album model:
- Stop the app if it is running.
- Locate and open the Album.cs file in the /Models folder.
- Add the code to implement save to disk, as shown:
```bash
public async Task SaveAsync(){  if (!Directory.Exists("./Cache"))  {    Directory.CreateDirectory("./Cache");  }  using (var fs = File.OpenWrite(CachePath))  {    await SaveToStreamAsync(this, fs);  }}public Stream SaveCoverBitmapStream(){  return File.OpenWrite(CachePath + ".bmp");}private static async Task SaveToStreamAsync(Album data, Stream stream){  await JsonSerializer.SerializeAsync(stream, data).ConfigureAwait(false);}
```
- Add the code to implement load from disk, as shown:
```bash
public static async Task<Album> LoadFromStream(Stream stream){  return (await JsonSerializer.DeserializeAsync<Album>(stream).ConfigureAwait(false))!;}public static async Task<IEnumerable<Album>> LoadCachedAsync(){  if (!Directory.Exists("./Cache"))  {    Directory.CreateDirectory("./Cache");  }  var results = new List<Album>();  foreach (var file in Directory.EnumerateFiles("./Cache"))  {    if (!string.IsNullOrWhiteSpace(new DirectoryInfo(file).Extension)) continue;    await using var fs = File.OpenRead(file);    results.Add(await Album.LoadFromStream(fs).ConfigureAwait(false));  }  return results;}
```
### Album View Model​
Your next step is to add a method to the album view model that it can call the business service persistence save methods:
SaveAsync - persists the album text data as a JSON file,
`SaveAsync` SaveCoverBitmapStream - saves the cover art as a bitmap (.BMP) file.
`SaveCoverBitmapStream` To alter the album view model , follow this procedure:
- Locate and open the AlbumViewModel.cs file.
- Add the method as shown:
```bash
public async Task SaveToDiskAsync(){  await _album.SaveAsync();  if (Cover != null)  {    var bitmap = Cover;    await Task.Run(() =>    {      using (var fs = _album.SaveCoverBitmapStream())      {        bitmap.Save(fs);      }    });  }}
```
Once again, you will notice that the bitmap is saved from a copy in case the Cover property gets changed mid-operation by another thread.
`Cover` ### Main Window View Model​
Lastly, you will call the new album view model persistence method SaveToDiskAsync whenever the dialog returns with a non-null result.
`SaveToDiskAsync` To alter the main window view model, follow this procedure:
- Locate and open the MainWindowViewModel.cs file.
- Add the code await result.SaveToDiskAsync(); as shown below.
`await result.SaveToDiskAsync();` Your code to initialize the reactive command will now look like this:
```bash
BuyMusicCommand = ReactiveCommand.CreateFromTask(async () =>{  var store = new MusicStoreViewModel();  var result = await ShowDialog.Handle(store);  if (result != null)  {    Albums.Add(result);    await result.SaveToDiskAsync();  }});
```
- Click Debug to compile and run the project.
- Click the icon button.
- Type some search text.
- Click an album to select it.
- Click Buy Album.
- Repeat another time for a different album.
You will not see any difference in the app yet. But you can check to see that the persistence files are being written. To do this open the project location and browse to the /bin/Debug folder. Open the folder for your .NET version, and you will find the /Cache folder there. You will see two cache files for each of the albums that you just selected.
### Bitmap Cache Activated​
Notice that because the SaveToDiskAsync method writes both the JSON data and the album cover art bitmap to the cache folder, this step has effectively activated the bitmap loading cache behaviour that you built earlier. This is where: if an album cover has already been retrieved from the Web API and saved to the cache, the next bitmap load will be from the file not the API - saving time and making the app more responsive.
`SaveToDiskAsync` To show that the bitmap loading cache is now in operation, follow this procedure:
- Stop the app if it is running.
- Locate and open the Album.cs file in the /Models folder.
- Check to see that there is still a debug breakpoint in the LoadCoverBitmapAsync method at this line:
`LoadCoverBitmapAsync` ```bash
return File.OpenRead(CachePath + ".bmp");
```
- Click Debug to compile and run the project.
- Click the icon button.
- Type the same search text you just used.
- Select one of the same albums from the previous test run.
- Click Buy Album
The debug breakpoint should stop the app. This demonstrates that the album art is about to be read from disk, rather than retrieved from the Web API.
On the next page, you will complete the persistence feature, and load the user's album collection from the cache when the app first starts up.
- Album Model
- Album View Model
- Main Window View Model
- Bitmap Cache Activated
# Load Data at Start-up | Avalonia Docs
- Samples & Tutorials
- Music Store App
- Load Data at Start-up
## Load Data at Start-up
On this page you will add code to load the user's album collection from disk when the app starts.
You have already added code to the business service that can load both the files you will need from disk. All that remains for you to do, is to add some code to the main window view model to handle the start-up.
Follow this procedure to add a method to load the user's album collection from disk:
- Stop the app if it is running
- Locate and open the MainWindowViewModel.cs file.
- Add the code as shown:
```bash
private async void LoadAlbums(){  var albums = (await Album.LoadCachedAsync()).Select(x => new AlbumViewModel(x));  foreach (var album in albums)  {    Albums.Add(album);  }  foreach (var album in Albums.ToList())  {    await album.LoadCover();  }}
```
As you can see this method uses the business service to load the list of albums from the disk cache. It then transforms each data model (Album class) into a view model (AlbumViewModel class). After this all the album view models are added to the observable collection - this will instantly update the UI with the text data for the albums.
`Album` `AlbumViewModel` You will notice that after the JSON album files are loaded, the second loop loads the cover art image files. This provides your user with visual feedback as quickly as possible (in the form of album tiles with text and the placeholder music note icon) about what albums are in the collection. The cover art is then loaded asynchronously. This ensures that the app remains responsive during the image loading process.
Your next step is to schedule the LoadAlbum method to run when the app starts.
`LoadAlbum` To schedule the method on the main thread, follow this procedure:
- Keep the MainWindowViewModel.cs file open.
- Add a reference to using System.Reactive.Concurrency;
- Add this code to the class constructor:
`using System.Reactive.Concurrency;` ```bash
RxApp.MainThreadScheduler.Schedule(LoadAlbums);
```
- Click Debug to compile and run the project.
![](https://docs.avaloniaui.net/assets/images/image-20210310184202271-35e14134bed2848aeda7400d5f259daa.png)
# How To Develop For Mobile iOS | Avalonia Docs
- How-To Guides
- Platforms
- iOS
- How To Develop For Mobile iOS
## 👉 How To Develop For Mobile iOS
In this section we describe how to setup you machine for iOS development. Then, if you have a Mac, how to run it on a simulator or an actual iPhone or iPad.
Due to Apple's policies it is unfortunately not possible to run the iOS simulators or test on an iPhone or iPad without a genuine Apple device running macOS and Xcode.
We hope this might change in the future, if you do not have access to a Mac, a workaround is to run your application in a Window sized appropriately. Or follow the guides on Android.
You should always test on a real device before releasing.
Before getting started ensure you have followed the guide Building Cross Platform Applications.
# Android | Avalonia Docs
- How-To Guides
- Platforms
- Android
## Android